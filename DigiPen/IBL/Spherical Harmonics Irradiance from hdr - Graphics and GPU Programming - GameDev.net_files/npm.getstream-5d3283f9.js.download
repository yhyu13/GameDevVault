(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.getstream"],{

/***/ "148I":
/*!************************************************!*\
  !*** ./node_modules/getstream/lib/lib/feed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"pVnL\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"cDf5\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"jN2H\");\n\nvar isObject = __webpack_require__(/*! lodash/isObject */ \"GoyQ\");\n\nvar isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ \"YO3V\");\n\nvar StreamUser = __webpack_require__(/*! ./user */ \"tXJw\");\n\nvar signing = __webpack_require__(/*! ./signing */ \"nlBe\");\n\nvar StreamFeed = function StreamFeed() {\n  /**\n   * Manage api calls for specific feeds\n   * The feed object contains convenience functions such add activity, remove activity etc\n   * @class StreamFeed\n   */\n  this.initialize.apply(this, arguments);\n};\n\nfunction replaceStreamObjects(obj) {\n  var cloned = obj;\n\n  if (Array.isArray(obj)) {\n    cloned = obj.map(function (v) {\n      return replaceStreamObjects(v);\n    });\n  } else if (isPlainObject(obj)) {\n    cloned = {};\n\n    for (var k in obj) {\n      cloned[k] = replaceStreamObjects(obj[k]);\n    }\n  } else if (isObject(obj) && obj._streamRef !== undefined) {\n    cloned = obj._streamRef();\n  }\n\n  return cloned;\n}\n\nStreamFeed.prototype = {\n  initialize: function initialize(client, feedSlug, userId, token) {\n    /**\n     * Initialize a feed object\n     * @method intialize\n     * @memberof StreamFeed.prototype\n     * @param {StreamClient} client - The stream client this feed is constructed from\n     * @param {string} feedSlug - The feed slug\n     * @param {string} userId - The user id\n     * @param {string} [token] - The authentication token\n     */\n    if (!feedSlug || !userId) {\n      throw new errors.FeedError('Please provide a feed slug and user id, ie client.feed(\"user\", \"1\")');\n    }\n\n    if (feedSlug.indexOf(':') !== -1) {\n      throw new errors.FeedError('Please initialize the feed using client.feed(\"user\", \"1\") not client.feed(\"user:1\")');\n    }\n\n    utils.validateFeedSlug(feedSlug);\n    utils.validateUserId(userId); // raise an error if there is no token\n\n    if (!this.apiSecret && !token) {\n      throw new errors.FeedError('Missing token, in client side mode please provide a feed secret');\n    }\n\n    this.client = client;\n    this.slug = feedSlug;\n    this.userId = userId;\n    this.id = this.slug + ':' + this.userId;\n    this.token = token;\n    this.feedUrl = this.id.replace(':', '/');\n    this.feedTogether = this.id.replace(':', '');\n    this.signature = this.feedTogether + ' ' + this.token; // faye setup\n\n    this.notificationChannel = 'site-' + this.client.appId + '-feed-' + this.feedTogether;\n    this.enrichByDefault = false;\n  },\n  addActivity: function addActivity(activity, callback) {\n    /**\n     * Adds the given activity to the feed and\n     * calls the specified callback\n     * @method addActivity\n     * @memberof StreamFeed.prototype\n     * @param {object} activity - The activity to add\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object\n     */\n    activity = replaceStreamObjects(activity);\n\n    if (!activity.actor && this.client.currentUser) {\n      activity.actor = this.client.currentUser._streamRef();\n    }\n\n    return this.client.post({\n      url: 'feed/' + this.feedUrl + '/',\n      body: activity,\n      signature: this.signature\n    }, callback);\n  },\n  removeActivity: function removeActivity(activityId, callback) {\n    /**\n     * Removes the activity by activityId\n     * @method removeActivity\n     * @memberof StreamFeed.prototype\n     * @param  {string}   activityId Identifier of activity to remove\n     * @param  {requestCallback} callback   Callback to call on completion\n     * @return {Promise} Promise object\n     * @example\n     * feed.removeActivity(activityId);\n     * @example\n     * feed.removeActivity({'foreignId': foreignId});\n     */\n    var identifier = activityId.foreignId ? activityId.foreignId : activityId;\n    var params = {};\n\n    if (activityId.foreignId) {\n      params['foreign_id'] = '1';\n    }\n\n    return this.client['delete']({\n      url: 'feed/' + this.feedUrl + '/' + identifier + '/',\n      qs: params,\n      signature: this.signature\n    }, callback);\n  },\n  addActivities: function addActivities(activities, callback) {\n    /**\n     * Adds the given activities to the feed and calls the specified callback\n     * @method addActivities\n     * @memberof StreamFeed.prototype\n     * @param  {Array}   activities Array of activities to add\n     * @param  {requestCallback} callback   Callback to call on completion\n     * @return {Promise}               XHR request object\n     */\n    activities = replaceStreamObjects(activities);\n    var data = {\n      activities: activities\n    };\n    var xhr = this.client.post({\n      url: 'feed/' + this.feedUrl + '/',\n      body: data,\n      signature: this.signature\n    }, callback);\n    return xhr;\n  },\n  follow: function follow(targetSlug, targetUserId, options, callback) {\n    /**\n     * Follows the given target feed\n     * @method follow\n     * @memberof StreamFeed.prototype\n     * @param  {string}   targetSlug   Slug of the target feed\n     * @param  {string}   targetUserId User identifier of the target feed\n     * @param  {object}   options      Additional options\n     * @param  {number}   options.activityCopyLimit Limit the amount of activities copied over on follow\n     * @param  {requestCallback} callback     Callback to call on completion\n     * @return {Promise}  Promise object\n     * @example feed.follow('user', '1');\n     * @example feed.follow('user', '1', callback);\n     * @example feed.follow('user', '1', options, callback);\n     */\n    if (targetUserId instanceof StreamUser) {\n      targetUserId = targetUserId.id;\n    }\n\n    utils.validateFeedSlug(targetSlug);\n    utils.validateUserId(targetUserId);\n    var activityCopyLimit;\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n    var target = targetSlug + ':' + targetUserId; // check for additional options\n\n    if (options && !options.call) {\n      if (typeof options.limit !== 'undefined' && options.limit !== null) {\n        activityCopyLimit = options.limit;\n      }\n    }\n\n    var body = {\n      target: target\n    };\n\n    if (typeof activityCopyLimit !== 'undefined' && activityCopyLimit !== null) {\n      body['activity_copy_limit'] = activityCopyLimit;\n    }\n\n    return this.client.post({\n      url: 'feed/' + this.feedUrl + '/following/',\n      body: body,\n      signature: this.signature\n    }, callback);\n  },\n  unfollow: function unfollow(targetSlug, targetUserId, optionsOrCallback, callback) {\n    /**\n     * Unfollow the given feed\n     * @method unfollow\n     * @memberof StreamFeed.prototype\n     * @param  {string}   targetSlug   Slug of the target feed\n     * @param  {string}   targetUserId [description]\n     * @param  {requestCallback|object} optionsOrCallback\n     * @param  {boolean}  optionOrCallback.keepHistory when provided the activities from target\n     *                                                 feed will not be kept in the feed\n     * @param  {requestCallback} callback     Callback to call on completion\n     * @return {object}                XHR request object\n     * @example feed.unfollow('user', '2', callback);\n     */\n    var options = {},\n        qs = {};\n    if (typeof optionsOrCallback === 'function') callback = optionsOrCallback;\n    if (_typeof(optionsOrCallback) === 'object') options = optionsOrCallback;\n    if (typeof options.keepHistory === 'boolean' && options.keepHistory) qs['keep_history'] = '1';\n    utils.validateFeedSlug(targetSlug);\n    utils.validateUserId(targetUserId);\n    var targetFeedId = targetSlug + ':' + targetUserId;\n    var xhr = this.client['delete']({\n      url: 'feed/' + this.feedUrl + '/following/' + targetFeedId + '/',\n      qs: qs,\n      signature: this.signature\n    }, callback);\n    return xhr;\n  },\n  following: function following(options, callback) {\n    /**\n     * List which feeds this feed is following\n     * @method following\n     * @memberof StreamFeed.prototype\n     * @param  {object}   options  Additional options\n     * @param  {string}   options.filter Filter to apply on search operation\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example feed.following({limit:10, filter: ['user:1', 'user:2']}, callback);\n     */\n    if (options !== undefined && options.filter) {\n      options.filter = options.filter.join(',');\n    }\n\n    return this.client.get({\n      url: 'feed/' + this.feedUrl + '/following/',\n      qs: options,\n      signature: this.signature\n    }, callback);\n  },\n  followers: function followers(options, callback) {\n    /**\n     * List the followers of this feed\n     * @method followers\n     * @memberof StreamFeed.prototype\n     * @param  {object}   options  Additional options\n     * @param  {string}   options.filter Filter to apply on search operation\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example\n     * feed.followers({limit:10, filter: ['user:1', 'user:2']}, callback);\n     */\n    if (options !== undefined && options.filter) {\n      options.filter = options.filter.join(',');\n    }\n\n    return this.client.get({\n      url: 'feed/' + this.feedUrl + '/followers/',\n      qs: options,\n      signature: this.signature\n    }, callback);\n  },\n  get: function get(options, callback) {\n    /**\n     * Reads the feed\n     * @method get\n     * @memberof StreamFeed.prototype\n     * @param  {object}   options  Additional options\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example feed.get({limit: 10, id_lte: 'activity-id'})\n     * @example feed.get({limit: 10, mark_seen: true})\n     */\n    var path;\n\n    if (options && options['mark_read'] && options['mark_read'].join) {\n      options['mark_read'] = options['mark_read'].join(',');\n    }\n\n    if (options && options['mark_seen'] && options['mark_seen'].join) {\n      options['mark_seen'] = options['mark_seen'].join(',');\n    }\n\n    this.client.replaceReactionOptions(options);\n\n    if (this.client.shouldUseEnrichEndpoint(options)) {\n      path = 'enrich/feed/';\n    } else {\n      path = 'feed/';\n    }\n\n    return this.client.get({\n      url: path + this.feedUrl + '/',\n      qs: options,\n      signature: this.signature\n    }, callback);\n  },\n  getReadOnlyToken: function getReadOnlyToken() {\n    /**\n     * Returns a token that allows only read operations\n     *\n     * @deprecated since version 4.0\n     * @method getReadOnlyToken\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug to get a read only token for\n     * @param {string} userId - The user identifier\n     * @return {string} token\n     * @example\n     * client.getReadOnlyToken('user', '1');\n     */\n    var feedId = '' + this.slug + this.userId;\n    return signing.JWTScopeToken(this.client.apiSecret, '*', 'read', {\n      feedId: feedId,\n      expireTokens: this.client.expireTokens\n    });\n  },\n  getReadWriteToken: function getReadWriteToken() {\n    /**\n     * Returns a token that allows read and write operations\n     * @deprecated since version 4.0\n     * @method getReadWriteToken\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug to get a read only token for\n     * @param {string} userId - The user identifier\n     * @return {string} token\n     * @example\n     * client.getReadWriteToken('user', '1');\n     */\n    var feedId = '' + this.slug + this.userId;\n    return signing.JWTScopeToken(this.client.apiSecret, '*', '*', {\n      feedId: feedId,\n      expireTokens: this.client.expireTokens\n    });\n  },\n  getActivityDetail: function getActivityDetail(activityId, options, callback) {\n    /**\n     * Retrieves one activity from a feed and adds enrichment\n     * @method getActivityDetail\n     * @memberof StreamFeed.prototype\n     * @param  {string}   activityId Identifier of activity to retrieve\n     * @param  {object}   options  Additional options\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example feed.getActivityDetail(activityId)\n     * @example feed.getActivityDetail(activityId, {withRecentReactions: true})\n     * @example feed.getActivityDetail(activityId, {withReactionCounts: true})\n     * @example feed.getActivityDetail(activityId, {withOwnReactions: true, withReactionCounts: true})\n     */\n    return this.get(_extends({\n      id_lte: activityId,\n      id_gte: activityId,\n      limit: 1\n    }, options || {}), callback);\n  },\n  getFayeClient: function getFayeClient() {\n    /**\n     * Returns the current faye client object\n     * @method getFayeClient\n     * @memberof StreamFeed.prototype\n     * @access private\n     * @return {object} Faye client\n     */\n    return this.client.getFayeClient();\n  },\n  subscribe: function subscribe(callback) {\n    /**\n     * Subscribes to any changes in the feed, return a promise\n     * @method subscribe\n     * @memberof StreamFeed.prototype\n     * @param  {function} callback Callback to call on completion\n     * @return {Promise}           Promise object\n     * @example\n     * feed.subscribe(callback).then(function(){\n     * \t\tconsole.log('we are now listening to changes');\n     * });\n     */\n    if (!this.client.appId) {\n      throw new errors.SiteError('Missing app id, which is needed to subscribe, use var client = stream.connect(key, secret, appId);');\n    }\n\n    var subscription = this.getFayeClient().subscribe('/' + this.notificationChannel, callback);\n    this.client.subscriptions['/' + this.notificationChannel] = {\n      token: this.token,\n      userId: this.notificationChannel,\n      fayeSubscription: subscription\n    };\n    return subscription;\n  },\n  unsubscribe: function unsubscribe() {\n    /**\n     * Cancel updates created via feed.subscribe()\n     * @return void\n     */\n    var streamSubscription = this.client.subscriptions['/' + this.notificationChannel];\n\n    if (streamSubscription) {\n      delete this.client.subscriptions['/' + this.notificationChannel];\n      streamSubscription.fayeSubscription.cancel();\n    }\n  },\n  updateActivityToTargets: function updateActivityToTargets(foreign_id, time, new_targets, added_targets, removed_targets) {\n    /**\n     * Updates an activity's \"to\" fields\n     * @since 3.10.0\n     * @param {string} foreign_id The foreign_id of the activity to update\n     * @param {string} time The time of the activity to update\n     * @param {array} new_targets Set the new \"to\" targets for the activity - will remove old targets\n     * @param {array} added_targets Add these new targets to the activity\n     * @param {array} removed_targets Remove these targets from the activity\n     */\n    if (!foreign_id) {\n      throw new Error('Missing `foreign_id` parameter!');\n    } else if (!time) {\n      throw new Error('Missing `time` parameter!');\n    }\n\n    if (!new_targets && !added_targets && !removed_targets) {\n      throw new Error('Requires you to provide at least one parameter for `new_targets`, `added_targets`, or `removed_targets` - example: `updateActivityToTargets(\"foreignID:1234\", new Date(), [new_targets...], [added_targets...], [removed_targets...])`');\n    }\n\n    if (new_targets) {\n      if (added_targets || removed_targets) {\n        throw new Error(\"Can't include add_targets or removed_targets if you're also including new_targets\");\n      }\n    }\n\n    if (added_targets && removed_targets) {\n      // brute force - iterate through added, check to see if removed contains that element\n      for (var i = 0; i < added_targets.length; i++) {\n        // would normally use Array.prototype.includes here, but it's not supported in Node.js v4 :(\n        for (var j = 0; j < removed_targets.length; j++) {\n          if (removed_targets[j] == added_targets[i]) {\n            throw new Error(\"Can't have the same feed ID in added_targets and removed_targets.\");\n          }\n        }\n      }\n    }\n\n    var body = {\n      foreign_id: foreign_id,\n      time: time\n    };\n\n    if (new_targets) {\n      body['new_targets'] = new_targets;\n    }\n\n    if (added_targets) {\n      body['added_targets'] = added_targets;\n    }\n\n    if (removed_targets) {\n      body['removed_targets'] = removed_targets;\n    }\n\n    return this.client.post({\n      url: 'feed_targets/' + this.feedUrl + '/activity_to_targets/',\n      signature: this.signature,\n      body: body\n    });\n  }\n};\nmodule.exports = StreamFeed;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/feed.js?");

/***/ }),

/***/ "31cZ":
/*!**************************************************!*\
  !*** ./node_modules/getstream/lib/lib/images.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"pVnL\");\n\nvar fetch = __webpack_require__(/*! @stream-io/cross-fetch */ \"QGad\");\n\nvar Headers = __webpack_require__(/*! @stream-io/cross-fetch */ \"QGad\").Headers;\n\nvar FormData = __webpack_require__(/*! form-data */ \"WjD0\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"jN2H\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar StreamImageStore = function StreamImageStore() {\n  this.initialize.apply(this, arguments);\n};\n\nStreamImageStore.prototype = {\n  initialize: function initialize(client, token) {\n    this.client = client;\n    this.token = token;\n  },\n  // React Native does not auto-detect MIME type, you need to pass that via contentType\n  // param. If you don't then Android will refuse to perform the upload\n  upload: function upload(uri, name, contentType) {\n    var data = new FormData();\n    var fileField;\n\n    if (utils.isReadableStream(uri)) {\n      fileField = uri;\n    } else {\n      fileField = {\n        uri: uri,\n        name: name || uri.split('/').reverse()[0]\n      };\n\n      if (contentType != null) {\n        fileField.type = contentType;\n      }\n    }\n\n    data.append('file', fileField);\n    return fetch(\"\".concat(this.client.enrichUrl('images/'), \"?api_key=\").concat(this.client.apiKey), {\n      method: 'post',\n      body: data,\n      headers: new Headers({\n        Authorization: this.token\n      })\n    }).then(function (r) {\n      if (r.ok) {\n        return r.json();\n      } // error\n\n\n      return r.text().then(function (responseData) {\n        r.statusCode = r.status;\n\n        try {\n          responseData = JSON.parse(responseData);\n        } catch (e) {// ignore json parsing errors\n        }\n\n        throw new errors.StreamApiError(JSON.stringify(responseData) + ' with HTTP status code ' + r.status, responseData, r);\n      });\n    });\n  },\n  delete: function _delete(uri) {\n    return this.client.delete({\n      url: \"images/\",\n      qs: {\n        url: uri\n      },\n      signature: this.token\n    });\n  },\n  process: function process(uri, options) {\n    var params = _extends(options, {\n      url: uri\n    });\n\n    if (Array.isArray(params.crop)) {\n      params.crop = params.crop.join(',');\n    }\n\n    return this.client.get({\n      url: \"images/\",\n      qs: params,\n      signature: this.token\n    });\n  },\n  thumbmail: function thumbmail(uri, w, h) {\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      crop: 'center',\n      resize: 'clip'\n    },\n        crop = _ref.crop,\n        resize = _ref.resize;\n\n    return this.process(uri, {\n      w: w,\n      h: h,\n      crop: crop,\n      resize: resize\n    });\n  }\n};\nmodule.exports = StreamImageStore;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/images.js?");

/***/ }),

/***/ "BfrC":
/*!**************************************************!*\
  !*** ./node_modules/getstream/lib/lib/errors.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var errors = module.exports;\nvar canCapture = typeof Error.captureStackTrace === 'function';\nvar canStack = !!new Error().stack;\n/**\n * Abstract error object\n * @class ErrorAbstract\n * @access private\n * @param  {string}      [msg]         Error message\n * @param  {function}    constructor\n */\n\nfunction ErrorAbstract(msg, constructor) {\n  this.message = msg;\n  Error.call(this, this.message);\n  /* istanbul ignore else */\n\n  if (canCapture) {\n    Error.captureStackTrace(this, constructor);\n  } else if (canStack) {\n    this.stack = new Error().stack;\n  } else {\n    this.stack = '';\n  }\n}\n\nerrors._Abstract = ErrorAbstract;\nErrorAbstract.prototype = new Error();\n/**\n * FeedError\n * @class FeedError\n * @access private\n * @extends ErrorAbstract\n * @memberof Stream.errors\n * @param {String} [msg] - An error message that will probably end up in a log.\n */\n\nerrors.FeedError = function FeedError(msg) {\n  ErrorAbstract.call(this, msg);\n};\n\nerrors.FeedError.prototype = new ErrorAbstract();\n/**\n * SiteError\n * @class SiteError\n * @access private\n * @extends ErrorAbstract\n * @memberof Stream.errors\n * @param  {string}  [msg]  An error message that will probably end up in a log.\n */\n\nerrors.SiteError = function SiteError(msg) {\n  ErrorAbstract.call(this, msg);\n};\n\nerrors.SiteError.prototype = new ErrorAbstract();\n/**\n * MissingSchemaError\n * @method MissingSchemaError\n * @access private\n * @extends ErrorAbstract\n * @memberof Stream.errors\n * @param  {string} msg\n */\n\nerrors.MissingSchemaError = function MissingSchemaError(msg) {\n  ErrorAbstract.call(this, msg);\n};\n\nerrors.MissingSchemaError.prototype = new ErrorAbstract();\n/**\n * StreamApiError\n * @method StreamApiError\n * @access private\n * @extends ErrorAbstract\n * @memberof Stream.errors\n * @param  {string} msg\n * @param  {object} data\n * @param  {object} response\n */\n\nerrors.StreamApiError = function StreamApiError(msg, data, response) {\n  this.error = data;\n  this.response = response;\n  ErrorAbstract.call(this, msg);\n};\n\nerrors.StreamApiError.prototype = new ErrorAbstract();\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/errors.js?");

/***/ }),

/***/ "NapP":
/*!*************************************************!*\
  !*** ./node_modules/getstream/lib/getstream.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * @module stream\n * @author Thierry Schellenbach\n * BSD License\n */\nvar StreamClient = __webpack_require__(/*! ./lib/client */ \"jLAC\");\n\nvar errors = __webpack_require__(/*! ./lib/errors */ \"BfrC\");\n\nvar signing = __webpack_require__(/*! ./lib/signing */ \"nlBe\");\n\nvar request = __webpack_require__(/*! request */ \"jUTl\");\n\nfunction connect(apiKey, apiSecret, appId, options) {\n  /**\n   * Create StreamClient\n   * @method connect\n   * @param  {string} apiKey    API key\n   * @param  {string} [apiSecret] API secret (only use this on the server)\n   * @param  {string} [appId]     Application identifier\n   * @param  {object} [options]   Additional options\n   * @param  {string} [options.location] Datacenter location\n   * @return {StreamClient}     StreamClient\n   * @example <caption>Basic usage</caption>\n   * stream.connect(apiKey, apiSecret);\n   * @example <caption>or if you want to be able to subscribe and listen</caption>\n   * stream.connect(apiKey, apiSecret, appId);\n   * @example <caption>or on Heroku</caption>\n   * stream.connect(streamURL);\n   * @example <caption>where streamURL looks like</caption>\n   * \"https://thierry:pass@gestream.io/?app=1\"\n   */\n  if (typeof process !== 'undefined' && process.env.STREAM_URL && !apiKey) {\n    var parts = /https:\\/\\/(\\w+):(\\w+)@([\\w-]*).*\\?app_id=(\\d+)/.exec(process.env.STREAM_URL);\n    apiKey = parts[1];\n    apiSecret = parts[2];\n    var location = parts[3];\n    appId = parts[4];\n\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (location !== 'getstream' && location !== 'stream-io-api') {\n      options.location = location;\n    }\n  }\n\n  return new StreamClient(apiKey, apiSecret, appId, options);\n}\n\nmodule.exports.connect = connect;\nmodule.exports.errors = errors;\nmodule.exports.request = request;\nmodule.exports.signing = signing;\nmodule.exports.Client = StreamClient;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"8oxB\")))\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/getstream.js?");

/***/ }),

/***/ "ToOg":
/*!*************************************************!*\
  !*** ./node_modules/getstream/lib/lib/files.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fetch = __webpack_require__(/*! @stream-io/cross-fetch */ \"QGad\");\n\nvar Headers = __webpack_require__(/*! @stream-io/cross-fetch */ \"QGad\").Headers;\n\nvar utils = __webpack_require__(/*! ./utils */ \"jN2H\");\n\nvar FormData = __webpack_require__(/*! form-data */ \"WjD0\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar StreamFileStore = function StreamFileStore() {\n  this.initialize.apply(this, arguments);\n};\n\nStreamFileStore.prototype = {\n  initialize: function initialize(client, token) {\n    this.client = client;\n    this.token = token;\n  },\n  // React Native does not auto-detect MIME type, you need to pass that via contentType\n  // param. If you don't then Android will refuse to perform the upload\n  upload: function upload(uri, name, contentType) {\n    var data = new FormData();\n    var fileField;\n\n    if (utils.isReadableStream(uri)) {\n      fileField = uri;\n    } else {\n      fileField = {\n        uri: uri,\n        name: name || uri.split('/').reverse()[0]\n      };\n\n      if (contentType != null) {\n        fileField.type = contentType;\n      }\n    }\n\n    data.append('file', fileField);\n    return fetch(\"\".concat(this.client.enrichUrl('files/'), \"?api_key=\").concat(this.client.apiKey), {\n      method: 'post',\n      body: data,\n      headers: new Headers({\n        Authorization: this.token\n      })\n    }).then(function (r) {\n      if (r.ok) {\n        return r.json();\n      } // error\n\n\n      return r.text().then(function (responseData) {\n        r.statusCode = r.status;\n\n        try {\n          responseData = JSON.parse(responseData);\n        } catch (e) {// ignore json parsing errors\n        }\n\n        throw new errors.StreamApiError(JSON.stringify(responseData) + ' with HTTP status code ' + r.status, responseData, r);\n      });\n    });\n  },\n  delete: function _delete(uri) {\n    return this.client.delete({\n      url: \"files/\",\n      qs: {\n        url: uri\n      },\n      signature: this.token\n    });\n  }\n};\nmodule.exports = StreamFileStore;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/files.js?");

/***/ }),

/***/ "Xay2":
/*!****************************************************!*\
  !*** ./node_modules/getstream/lib/lib/reaction.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"QILm\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar StreamReaction = function StreamReaction() {\n  this.initialize.apply(this, arguments);\n};\n\nStreamReaction.prototype = {\n  initialize: function initialize(client, token) {\n    /**\n     * Initialize a feed object\n     * @method intialize\n     * @memberof StreamReaction.prototype\n     * @param {StreamClient} client Stream client this feed is constructed from\n     * @param {string} token JWT token\n     * @example new StreamReaction(client, \"eyJhbGciOiJIUzI1...\")\n     */\n    this.client = client;\n    this.token = token;\n    this.signature = token;\n  },\n  buildURL: function buildURL() {\n    var url = 'reaction/';\n\n    for (var i = 0; i < arguments.length; i++) {\n      url += arguments[i] + '/';\n    }\n\n    return url;\n  },\n  all: function all(options, callback) {\n    /**\n     * get all reactions\n     * @method all\n     * @memberof StreamReaction.prototype\n     * @param  {object}   options  {limit:}\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.all()\n     * @example reactions.all({limit:100})\n     */\n    return this.client.get({\n      url: this.buildURL(),\n      signature: this.signature\n    }, callback);\n  },\n  _convertTargetFeeds: function _convertTargetFeeds() {\n    var targetFeeds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return targetFeeds.map(function (elem) {\n      return typeof elem === 'string' ? elem : elem.id;\n    });\n  },\n  add: function add(kind, activity) {\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        id = _ref.id,\n        _ref$targetFeeds = _ref.targetFeeds,\n        targetFeeds = _ref$targetFeeds === void 0 ? [] : _ref$targetFeeds,\n        userId = _ref.userId,\n        targetFeedsExtraData = _ref.targetFeedsExtraData;\n\n    var callback = arguments.length > 4 ? arguments[4] : undefined;\n    /**\n     * add reaction\n     * @method add\n     * @memberof StreamReaction.prototype\n     * @param  {string}   kind  kind of reaction\n     * @param  {string}   activity Activity or an ActivityID\n     * @param  {object}   data  data related to reaction\n     * @param  {array}    targetFeeds  an array of feeds to which to send an activity with the reaction\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.add(\"like\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\")\n     * @example reactions.add(\"comment\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", {\"text\": \"love it!\"},)\n     */\n\n    if (activity instanceof Object) {\n      activity = activity.id;\n    }\n\n    targetFeeds = this._convertTargetFeeds(targetFeeds);\n    var body = {\n      id: id,\n      activity_id: activity,\n      kind: kind,\n      data: data,\n      target_feeds: targetFeeds,\n      user_id: userId\n    };\n\n    if (targetFeedsExtraData != null) {\n      body.target_feeds_extra_data = targetFeedsExtraData;\n    }\n\n    return this.client.post({\n      url: this.buildURL(),\n      body: body,\n      signature: this.signature\n    }, callback);\n  },\n  addChild: function addChild(kind, reaction) {\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref2$targetFeeds = _ref2.targetFeeds,\n        targetFeeds = _ref2$targetFeeds === void 0 ? [] : _ref2$targetFeeds,\n        userId = _ref2.userId,\n        targetFeedsExtraData = _ref2.targetFeedsExtraData;\n\n    var callback = arguments.length > 4 ? arguments[4] : undefined;\n    /**\n     * add reaction\n     * @method add\n     * @memberof StreamReaction.prototype\n     * @param  {string}   kind  kind of reaction\n     * @param  {string}   reaction Reaction or a ReactionID\n     * @param  {object}   data  data related to reaction\n     * @param  {array}    targetFeeds  an array of feeds to which to send an activity with the reaction\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.add(\"like\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\")\n     * @example reactions.add(\"comment\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", {\"text\": \"love it!\"},)\n     */\n\n    if (reaction instanceof Object) {\n      reaction = reaction.id;\n    }\n\n    targetFeeds = this._convertTargetFeeds(targetFeeds);\n    var body = {\n      parent: reaction,\n      kind: kind,\n      data: data,\n      target_feeds: targetFeeds,\n      user_id: userId\n    };\n\n    if (targetFeedsExtraData != null) {\n      body.target_feeds_extra_data = targetFeedsExtraData;\n    }\n\n    return this.client.post({\n      url: this.buildURL(),\n      body: body,\n      signature: this.signature\n    }, callback);\n  },\n  get: function get(id, callback) {\n    /**\n     * get reaction\n     * @method add\n     * @memberof StreamReaction.prototype\n     * @param  {string}   id Reaction Id\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.get(\"67b3e3b5-b201-4697-96ac-482eb14f88ec\")\n     */\n    return this.client.get({\n      url: this.buildURL(id),\n      signature: this.signature\n    }, callback);\n  },\n  filter: function filter(conditions, callback) {\n    /**\n     * retrieve reactions by activity_id, user_id or reaction_id (to paginate children reactions), pagination can be done using id_lt, id_lte, id_gt and id_gte parameters\n     * id_lt and id_lte return reactions order by creation descending starting from the reaction with the ID provided, when id_lte is used\n     * the reaction with ID equal to the value provided is included.\n     * id_gt and id_gte return reactions order by creation ascending (oldest to newest) starting from the reaction with the ID provided, when id_gte is used\n     * the reaction with ID equal to the value provided is included.\n     * results are limited to 25 at most and are ordered newest to oldest by default.\n     * @method lookup\n     * @memberof StreamReaction.prototype\n     * @param  {object}   conditions Reaction Id {activity_id|user_id|foreign_id:string, kind:string, next:string, previous:string, limit:integer}\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.lookup({activity_id: \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", kind:\"like\"})\n     * @example reactions.lookup({user_id: \"john\", kinds:\"like\"})\n     */\n    var user_id = conditions.user_id,\n        activity_id = conditions.activity_id,\n        reaction_id = conditions.reaction_id,\n        qs = _objectWithoutProperties(conditions, [\"user_id\", \"activity_id\", \"reaction_id\"]);\n\n    if (!qs.limit) {\n      qs.limit = 10;\n    }\n\n    if ((user_id ? 1 : 0) + (activity_id ? 1 : 0) + (reaction_id ? 1 : 0) != 1) {\n      throw new errors.SiteError('Must provide exactly one value for one of these params: user_id, activity_id, reaction_id');\n    }\n\n    var lookupType = user_id && 'user_id' || activity_id && 'activity_id' || reaction_id && 'reaction_id';\n    var value = user_id || activity_id || reaction_id;\n    var url = this.buildURL(lookupType, value);\n\n    if (conditions.kind) {\n      url = this.buildURL(lookupType, value, conditions.kind);\n    }\n\n    return this.client.get({\n      url: url,\n      qs: qs,\n      signature: this.signature\n    }, callback);\n  },\n  update: function update(id, data) {\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref3$targetFeeds = _ref3.targetFeeds,\n        targetFeeds = _ref3$targetFeeds === void 0 ? [] : _ref3$targetFeeds,\n        targetFeedsExtraData = _ref3.targetFeedsExtraData;\n\n    var callback = arguments.length > 3 ? arguments[3] : undefined;\n    /**\n     * update reaction\n     * @method add\n     * @memberof StreamReaction.prototype\n     * @param  {string}   id Reaction Id\n     * @param  {object}   data  Data associated to reaction\n     * @param  {array}   targetFeeds  Optional feeds to post the activity to. If you sent this before and don't set it here it will be removed.\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.update(\"67b3e3b5-b201-4697-96ac-482eb14f88ec\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", \"like\")\n     * @example reactions.update(\"67b3e3b5-b201-4697-96ac-482eb14f88ec\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", \"comment\", {\"text\": \"love it!\"},)\n     */\n\n    targetFeeds = this._convertTargetFeeds(targetFeeds);\n    var body = {\n      data: data,\n      target_feeds: targetFeeds\n    };\n\n    if (targetFeedsExtraData != null) {\n      body.target_feeds_extra_data = targetFeedsExtraData;\n    }\n\n    return this.client.put({\n      url: this.buildURL(id),\n      body: body,\n      signature: this.signature\n    }, callback);\n  },\n  delete: function _delete(id, callback) {\n    /**\n     * delete reaction\n     * @method delete\n     * @memberof StreamReaction.prototype\n     * @param  {string}   id Reaction Id\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example reactions.delete(\"67b3e3b5-b201-4697-96ac-482eb14f88ec\")\n     */\n    return this.client.delete({\n      url: this.buildURL(id),\n      signature: this.signature\n    }, callback);\n  }\n};\nmodule.exports = StreamReaction;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/reaction.js?");

/***/ }),

/***/ "jLAC":
/*!**************************************************!*\
  !*** ./node_modules/getstream/lib/lib/client.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"pVnL\");\n\nvar _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"QILm\");\n\nvar Personalization = __webpack_require__(/*! ./personalization */ \"tsR5\");\n\nvar request = __webpack_require__(/*! request */ \"jUTl\");\n\nvar StreamFeed = __webpack_require__(/*! ./feed */ \"148I\");\n\nvar signing = __webpack_require__(/*! ./signing */ \"nlBe\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"jN2H\");\n\nvar BatchOperations = __webpack_require__(/*! ./batch_operations */ 1);\n\nvar Promise = __webpack_require__(/*! ./promise */ \"sQbz\");\n\nvar qs = __webpack_require__(/*! qs */ 2);\n\nvar url = __webpack_require__(/*! url */ 3);\n\nvar Faye = __webpack_require__(/*! faye */ \"ju1d\");\n\nvar Collections = __webpack_require__(/*! ./collections */ \"yE4Z\");\n\nvar StreamFileStore = __webpack_require__(/*! ./files */ \"ToOg\");\n\nvar StreamImageStore = __webpack_require__(/*! ./images */ \"31cZ\");\n\nvar StreamReaction = __webpack_require__(/*! ./reaction */ \"Xay2\");\n\nvar StreamUser = __webpack_require__(/*! ./user */ \"tXJw\");\n\nvar jwtDecode = __webpack_require__(/*! jwt-decode */ \"BOF4\");\n\nvar assignIn = __webpack_require__(/*! lodash/assignIn */ \"qbnB\");\n/**\n * @callback requestCallback\n * @param {object} [errors]\n * @param {object} response\n * @param {object} body\n */\n\n\nvar StreamClient = function StreamClient() {\n  /**\n   * Client to connect to Stream api\n   * @class StreamClient\n   */\n  this.initialize.apply(this, arguments);\n};\n\nStreamClient.prototype = {\n  baseUrl: 'https://api.stream-io-api.com/api/',\n  baseAnalyticsUrl: 'https://analytics.stream-io-api.com/analytics/',\n  initialize: function initialize(apiKey, apiSecretOrToken, appId) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    /**\n     * Initialize a client\n     * @method intialize\n     * @memberof StreamClient.prototype\n     * @param {string} apiKey - the api key\n     * @param {string} [apiSecret] - the api secret\n     * @param {string} [appId] - id of the app\n     * @param {object} [options] - additional options\n     * @param {string} [options.location] - which data center to use\n     * @param {boolean} [options.expireTokens=false] - whether to use a JWT timestamp field (i.e. iat)\n     * @example <caption>initialize is not directly called by via stream.connect, ie:</caption>\n     * stream.connect(apiKey, apiSecret)\n     * @example <caption>secret is optional and only used in server side mode</caption>\n     * stream.connect(apiKey, null, appId);\n     */\n\n    this.apiKey = apiKey;\n    this.usingApiSecret = apiSecretOrToken != null && !signing.isJWT(apiSecretOrToken);\n    this.apiSecret = this.usingApiSecret ? apiSecretOrToken : null;\n    this.userToken = this.usingApiSecret ? null : apiSecretOrToken;\n    this.enrichByDefault = !this.usingApiSecret;\n\n    if (this.userToken != null) {\n      var jwtBody = jwtDecode(this.userToken);\n\n      if (!jwtBody.user_id) {\n        throw new TypeError('user_id is missing in user token');\n      }\n\n      this.userId = jwtBody.user_id;\n      this.currentUser = this.user(this.userId);\n      this.authPayload = jwtBody;\n    }\n\n    this.appId = appId;\n    this.options = options;\n    this.version = this.options.version || 'v1.0';\n    this.fayeUrl = this.options.fayeUrl || 'https://faye-us-east.stream-io-api.com/faye';\n    this.fayeClient = null;\n    this.request = request; // track a source name for the api calls, ie get started or databrowser\n\n    this.group = this.options.group || 'unspecified'; // track subscriptions made on feeds created by this client\n\n    this.subscriptions = {};\n    this.expireTokens = this.options.expireTokens ? this.options.expireTokens : false; // which data center to use\n\n    this.location = this.options.location;\n    this.baseUrl = this.getBaseUrl();\n\n    if (typeof process !== 'undefined' && process.env.LOCAL_FAYE) {\n      this.fayeUrl = 'http://localhost:9999/faye/';\n    }\n\n    if (typeof process !== 'undefined' && process.env.STREAM_ANALYTICS_BASE_URL) {\n      this.baseAnalyticsUrl = process.env.STREAM_ANALYTICS_BASE_URL;\n    }\n\n    this.handlers = {};\n    this.browser = typeof this.options.browser !== 'undefined' ? this.options.browser : typeof window !== 'undefined';\n    this.node = !this.browser;\n\n    if (!this.browser) {\n      var keepAlive = this.options.keepAlive;\n\n      if (keepAlive === undefined) {\n        keepAlive = true;\n      }\n\n      var http = __webpack_require__(/*! http */ 4);\n\n      var https = __webpack_require__(/*! https */ 5);\n\n      var httpsAgent = new https.Agent({\n        keepAlive: keepAlive,\n        keepAliveMsecs: 3000\n      });\n      var httpAgent = new http.Agent({\n        keepAlive: keepAlive,\n        keepAliveMsecs: 3000\n      });\n      this.requestAgent = this.baseUrl.startsWith('https://') ? httpsAgent : httpAgent;\n    }\n\n    this.personalization = new Personalization(this);\n    /* istanbul ignore next */\n\n    if (this.browser && this.usingApiSecret) {\n      throw new errors.FeedError('You are publicly sharing your App Secret. Do not expose the App Secret in browsers, \"native\" mobile apps, or other non-trusted environments.');\n    }\n\n    this.collections = new Collections(this, this.getOrCreateToken());\n    this.files = new StreamFileStore(this, this.getOrCreateToken());\n    this.images = new StreamImageStore(this, this.getOrCreateToken());\n    this.reactions = new StreamReaction(this, this.getOrCreateToken());\n  },\n  getPersonalizationToken: function getPersonalizationToken() {\n    if (this._personalizationToken) {\n      return this._personalizationToken;\n    }\n\n    if (this.apiSecret) {\n      this._personalizationToken = signing.JWTScopeToken(this.apiSecret, 'personalization', '*', {\n        userId: '*',\n        feedId: '*',\n        expireTokens: this.expireTokens\n      });\n    } else {\n      throw new errors.SiteError('Missing secret, which is needed to perform signed requests, use var client = stream.connect(key, secret);');\n    }\n\n    return this._personalizationToken;\n  },\n  getCollectionsToken: function getCollectionsToken() {\n    if (this._collectionsToken) {\n      return this._collectionsToken;\n    }\n\n    if (this.apiSecret) {\n      this._collectionsToken = signing.JWTScopeToken(this.apiSecret, 'collections', '*', {\n        feedId: '*',\n        expireTokens: this.expireTokens\n      });\n    } else {\n      throw new errors.SiteError('Missing secret, which is needed to perform signed requests, use var client = stream.connect(key, secret);');\n    }\n\n    return this._collectionsToken;\n  },\n  getAnalyticsToken: function getAnalyticsToken() {\n    if (this.apiSecret) {\n      return signing.JWTScopeToken(this.apiSecret, 'analytics', '*', {\n        userId: '*',\n        expireTokens: this.expireTokens\n      });\n    } else {\n      throw new errors.SiteError('Missing secret, which is needed to perform signed requests, use var client = stream.connect(key, secret);');\n    }\n  },\n  getBaseUrl: function getBaseUrl(serviceName) {\n    if (!serviceName) {\n      serviceName = 'api';\n    }\n\n    var url = this.baseUrl;\n\n    if (serviceName != 'api') {\n      url = 'https://' + serviceName + '.stream-io-api.com/' + serviceName + '/';\n    }\n\n    if (this.location) {\n      var protocol = this.options.protocol || 'https';\n      url = protocol + '://' + this.location + '-' + serviceName + '.stream-io-api.com/' + serviceName + '/';\n    }\n\n    if (typeof process !== 'undefined' && process.env.LOCAL || this.options.local) {\n      url = 'http://localhost:8000/' + serviceName + '/';\n    }\n\n    var urlEnvironmentKey;\n\n    if (serviceName == 'api') {\n      urlEnvironmentKey = 'STREAM_BASE_URL';\n    } else {\n      urlEnvironmentKey = 'STREAM_' + serviceName.toUpperCase() + '_URL';\n    }\n\n    if (typeof process !== 'undefined' && process.env[urlEnvironmentKey]) {\n      url = process.env[urlEnvironmentKey];\n    }\n\n    if (this.options.urlOverride && this.options.urlOverride[serviceName]) {\n      return this.options.urlOverride[serviceName];\n    }\n\n    return url;\n  },\n  on: function on(event, callback) {\n    /**\n     * Support for global event callbacks\n     * This is useful for generic error and loading handling\n     * @method on\n     * @memberof StreamClient.prototype\n     * @param {string} event - Name of the event\n     * @param {function} callback - Function that is called when the event fires\n     * @example\n     * client.on('request', callback);\n     * client.on('response', callback);\n     */\n    this.handlers[event] = callback;\n  },\n  off: function off(key) {\n    /**\n     * Remove one or more event handlers\n     * @method off\n     * @memberof StreamClient.prototype\n     * @param {string} [key] - Name of the handler\n     * @example\n     * client.off() removes all handlers\n     * client.off(name) removes the specified handler\n     */\n    if (key === undefined) {\n      this.handlers = {};\n    } else {\n      delete this.handlers[key];\n    }\n  },\n  send: function send() {\n    /**\n     * Call the given handler with the arguments\n     * @method send\n     * @memberof StreamClient.prototype\n     * @access private\n     */\n    var args = Array.prototype.slice.call(arguments);\n    var key = args[0];\n    args = args.slice(1);\n\n    if (this.handlers[key]) {\n      this.handlers[key].apply(this, args);\n    }\n  },\n  wrapPromiseTask: function wrapPromiseTask(cb, fulfill, reject) {\n    /**\n     * Wrap a task to be used as a promise\n     * @method wrapPromiseTask\n     * @memberof StreamClient.prototype\n     * @private\n     * @param {requestCallback} cb\n     * @param {function} fulfill\n     * @param {function} reject\n     * @return {function}\n     */\n    var client = this;\n    var callback = this.wrapCallback(cb);\n    return function task(error, response, body) {\n      if (error) {\n        reject(new errors.StreamApiError(error, body, response));\n      } else if (!/^2/.test('' + response.statusCode)) {\n        reject(new errors.StreamApiError(JSON.stringify(body) + ' with HTTP status code ' + response.statusCode, body, response));\n      } else {\n        fulfill(body);\n      }\n\n      callback.call(client, error, response, body);\n    };\n  },\n  wrapCallback: function wrapCallback(cb) {\n    /**\n     * Wrap callback for HTTP request\n     * @method wrapCallBack\n     * @memberof StreamClient.prototype\n     * @access private\n     */\n    var client = this;\n\n    function callback() {\n      // first hit the global callback, subsequently forward\n      var args = Array.prototype.slice.call(arguments);\n      var sendArgs = ['response'].concat(args);\n      client.send.apply(client, sendArgs);\n\n      if (cb !== undefined) {\n        cb.apply(client, args);\n      }\n    }\n\n    return callback;\n  },\n  userAgent: function userAgent() {\n    /**\n     * Get the current user agent\n     * @method userAgent\n     * @memberof StreamClient.prototype\n     * @return {string} current user agent\n     */\n    var description = this.node ? 'node' : 'browser'; // TODO: get the version here in a way which works in both and browserify\n\n    var version = 'unknown';\n    return 'stream-javascript-client-' + description + '-' + version;\n  },\n  getReadOnlyToken: function getReadOnlyToken(feedSlug, userId) {\n    /**\n     * Returns a token that allows only read operations\n     *\n     * @method getReadOnlyToken\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug to get a read only token for\n     * @param {string} userId - The user identifier\n     * @return {string} token\n     * @example\n     * client.getReadOnlyToken('user', '1');\n     */\n    return this.feed(feedSlug, userId).getReadOnlyToken();\n  },\n  getReadWriteToken: function getReadWriteToken(feedSlug, userId) {\n    /**\n     * Returns a token that allows read and write operations\n     *\n     * @method getReadWriteToken\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug to get a read only token for\n     * @param {string} userId - The user identifier\n     * @return {string} token\n     * @example\n     * client.getReadWriteToken('user', '1');\n     */\n    return this.feed(feedSlug, userId).getReadWriteToken();\n  },\n  feed: function feed(feedSlug) {\n    var userId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.userId;\n    var token = arguments.length > 2 ? arguments[2] : undefined;\n    /**\n     * Returns a feed object for the given feed id and token\n     * @method feed\n     * @memberof StreamClient.prototype\n     * @param {string} feedSlug - The feed slug\n     * @param {string} userId - The user identifier\n     * @param {string} [token] - The token (DEPRECATED)\n     * @return {StreamFeed}\n     * @example\n     * client.feed('user', '1');\n     */\n\n    if (token === undefined) {\n      if (this.usingApiSecret) {\n        token = signing.JWTScopeToken(this.apiSecret, '*', '*', {\n          feedId: '' + feedSlug + userId\n        });\n      } else {\n        token = this.userToken;\n      }\n    }\n\n    if (userId instanceof StreamUser) {\n      userId = userId.id;\n    }\n\n    var feed = new StreamFeed(this, feedSlug, userId, token);\n    return feed;\n  },\n  enrichUrl: function enrichUrl(relativeUrl, serviceName) {\n    /**\n     * Combines the base url with version and the relative url\n     * @method enrichUrl\n     * @memberof StreamClient.prototype\n     * @private\n     * @param {string} relativeUrl\n     */\n    if (!serviceName) {\n      serviceName = 'api';\n    }\n\n    var base_url = this.getBaseUrl(serviceName);\n    var url = base_url + this.version + '/' + relativeUrl;\n    return url;\n  },\n  replaceReactionOptions: function replaceReactionOptions(options) {\n    // Shortcut options for reaction enrichment\n    if (options && options.reactions) {\n      if (options.reactions.own != null) {\n        options.withOwnReactions = options.reactions.own;\n      }\n\n      if (options.reactions.recent != null) {\n        options.withRecentReactions = options.reactions.recent;\n      }\n\n      if (options.reactions.counts != null) {\n        options.withReactionCounts = options.reactions.counts;\n      }\n\n      if (options.reactions.own_children != null) {\n        options.withOwnChildren = options.reactions.own_children;\n      }\n\n      delete options.reactions;\n    }\n  },\n  shouldUseEnrichEndpoint: function shouldUseEnrichEndpoint(options) {\n    if (options && options.enrich) {\n      var result = options.enrich;\n      delete options.enrich;\n      return result;\n    }\n\n    return this.enrichByDefault || options.ownReactions != null || options.withRecentReactions != null || options.withReactionCounts != null || options.withOwnChildren != null;\n  },\n  enrichKwargs: function enrichKwargs(kwargs) {\n    /**\n     * Adds the API key and the signature\n     * @method enrichKwargs\n     * @memberof StreamClient.prototype\n     * @param {object} kwargs\n     * @private\n     */\n    kwargs.url = this.enrichUrl(kwargs.url, kwargs.serviceName);\n\n    if (kwargs.qs === undefined) {\n      kwargs.qs = {};\n    }\n\n    if (!this.browser) {\n      kwargs.agent = this.requestAgent;\n    }\n\n    kwargs.qs['api_key'] = this.apiKey;\n    kwargs.qs.location = this.group;\n    kwargs.json = true;\n    var signature = kwargs.signature || this.signature;\n    kwargs.headers = {}; // auto-detect authentication type and set HTTP headers accordingly\n\n    if (signing.isJWTSignature(signature)) {\n      kwargs.headers['stream-auth-type'] = 'jwt';\n      signature = signature.split(' ').reverse()[0];\n    } else {\n      kwargs.headers['stream-auth-type'] = 'simple';\n    }\n\n    kwargs.timeout = 10 * 1000; // 10 seconds\n\n    kwargs.headers.Authorization = signature;\n    kwargs.headers['X-Stream-Client'] = this.userAgent(); // Make sure withCredentials is not enabled, different browser\n    // fallbacks handle it differently by default (meteor)\n\n    kwargs.withCredentials = false;\n    return kwargs;\n  },\n  getFayeAuthorization: function getFayeAuthorization() {\n    /**\n     * Get the authorization middleware to use Faye with getstream.io\n     * @method getFayeAuthorization\n     * @memberof StreamClient.prototype\n     * @private\n     * @return {object} Faye authorization middleware\n     */\n    var apiKey = this.apiKey,\n        self = this;\n    return {\n      incoming: function incoming(message, callback) {\n        callback(message);\n      },\n      outgoing: function outgoing(message, callback) {\n        if (message.subscription && self.subscriptions[message.subscription]) {\n          var subscription = self.subscriptions[message.subscription];\n          message.ext = {\n            user_id: subscription.userId,\n            api_key: apiKey,\n            signature: subscription.token\n          };\n        }\n\n        callback(message);\n      }\n    };\n  },\n  getFayeClient: function getFayeClient() {\n    /**\n     * Returns this client's current Faye client\n     * @method getFayeClient\n     * @memberof StreamClient.prototype\n     * @private\n     * @return {object} Faye client\n     */\n    if (this.fayeClient === null) {\n      this.fayeClient = new Faye.Client(this.fayeUrl, {\n        timeout: 10\n      });\n      var authExtension = this.getFayeAuthorization();\n      this.fayeClient.addExtension(authExtension);\n    }\n\n    return this.fayeClient;\n  },\n  get: function get(kwargs, cb) {\n    /**\n     * Shorthand function for get request\n     * @method get\n     * @memberof StreamClient.prototype\n     * @private\n     * @param  {object}   kwargs\n     * @param  {requestCallback} cb     Callback to call on completion\n     * @return {Promise}                Promise object\n     */\n    return new Promise(function (fulfill, reject) {\n      this.send('request', 'get', kwargs, cb);\n      kwargs = this.enrichKwargs(kwargs);\n      kwargs.method = 'GET';\n      kwargs.gzip = true;\n      var callback = this.wrapPromiseTask(cb, fulfill, reject);\n      this.request(kwargs, callback);\n    }.bind(this));\n  },\n  post: function post(kwargs, cb) {\n    /**\n     * Shorthand function for post request\n     * @method post\n     * @memberof StreamClient.prototype\n     * @private\n     * @param  {object}   kwargs\n     * @param  {requestCallback} cb     Callback to call on completion\n     * @return {Promise}                Promise object\n     */\n    return new Promise(function (fulfill, reject) {\n      this.send('request', 'post', kwargs, cb);\n      kwargs = this.enrichKwargs(kwargs);\n      kwargs.method = 'POST';\n      kwargs.gzip = true;\n      var callback = this.wrapPromiseTask(cb, fulfill, reject);\n      this.request(kwargs, callback);\n    }.bind(this));\n  },\n  delete: function _delete(kwargs, cb) {\n    /**\n     * Shorthand function for delete request\n     * @method delete\n     * @memberof StreamClient.prototype\n     * @private\n     * @param  {object}   kwargs\n     * @param  {requestCallback} cb     Callback to call on completion\n     * @return {Promise}                Promise object\n     */\n    return new Promise(function (fulfill, reject) {\n      this.send('request', 'delete', kwargs, cb);\n      kwargs = this.enrichKwargs(kwargs);\n      kwargs.gzip = true;\n      kwargs.method = 'DELETE';\n      var callback = this.wrapPromiseTask(cb, fulfill, reject);\n      this.request(kwargs, callback);\n    }.bind(this));\n  },\n  put: function put(kwargs, cb) {\n    /**\n     * Shorthand function for put request\n     * @method put\n     * @memberof StreamClient.prototype\n     * @private\n     * @param  {object}   kwargs\n     * @param  {requestCallback} cb     Callback to call on completion\n     * @return {Promise}                Promise object\n     */\n    return new Promise(function (fulfill, reject) {\n      this.send('request', 'put', kwargs, cb);\n      kwargs = this.enrichKwargs(kwargs);\n      kwargs.method = 'PUT';\n      kwargs.gzip = true;\n      var callback = this.wrapPromiseTask(cb, fulfill, reject);\n      this.request(kwargs, callback);\n    }.bind(this));\n  },\n\n  /**\n   * Deprecated: use createUserToken instead\n   * @param {string} userId\n   * @param {object} extraData\n   */\n  createUserSessionToken: function createUserSessionToken(userId) {\n    var extraData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.usingApiSecret || this.apiKey == null) {\n      throw new errors.FeedError('In order to create user tokens you need to initialize the API client with your API Secret');\n    }\n\n    return signing.JWTUserSessionToken(this.apiSecret, userId, extraData, {\n      noTimestamp: !this.expireTokens\n    });\n  },\n  createUserToken: function createUserToken(userId) {\n    var extraData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.createUserSessionToken(userId, extraData);\n  },\n  updateActivities: function updateActivities(activities, callback) {\n    /**\n     * Updates all supplied activities on the getstream-io api\n     * @since  3.1.0\n     * @param  {array} activities list of activities to update\n     * @return {Promise}\n     */\n    if (!this.usingApiSecret || this.apiKey == null) {\n      throw new errors.SiteError('This method can only be used server-side using your API Secret');\n    }\n\n    if (!(activities instanceof Array)) {\n      throw new TypeError('The activities argument should be an Array');\n    }\n\n    var authToken = signing.JWTScopeToken(this.apiSecret, 'activities', '*', {\n      feedId: '*',\n      expireTokens: this.expireTokens\n    });\n    var data = {\n      activities: activities\n    };\n    return this.post({\n      url: 'activities/',\n      body: data,\n      signature: authToken\n    }, callback);\n  },\n  updateActivity: function updateActivity(activity, callback) {\n    /**\n     * Updates one activity on the getstream-io api\n     * @since  3.1.0\n     * @param  {object} activity The activity to update\n     * @return {Promise}\n     */\n    if (!this.usingApiSecret || this.apiKey == null) {\n      throw new errors.SiteError('This method can only be used server-side using your API Secret');\n    }\n\n    return this.updateActivities([activity], callback);\n  },\n  getActivities: function getActivities(params, callback) {\n    /**\n     * Retrieve activities by ID or foreign ID and time\n     * @since  3.19.0\n     * @param  {object} params object containing either the list of activity IDs as {ids: ['...', ...]} or foreign IDs and time as {foreignIDTimes: [{foreignID: ..., time: ...}, ...]}\n     * @return {Promise}\n     */\n    var ids = params.ids,\n        foreignIDTimes = params.foreignIDTimes,\n        qs = _objectWithoutProperties(params, [\"ids\", \"foreignIDTimes\"]);\n\n    if (ids) {\n      if (!(ids instanceof Array)) {\n        throw new TypeError('The ids argument should be an Array');\n      }\n\n      qs['ids'] = ids.join(',');\n    } else if (foreignIDTimes) {\n      if (!(foreignIDTimes instanceof Array)) {\n        throw new TypeError('The foreignIDTimes argument should be an Array');\n      }\n\n      var foreignIDs = [];\n      var timestamps = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = foreignIDTimes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var fidTime = _step.value;\n\n          if (!(fidTime instanceof Object)) {\n            throw new TypeError('foreignIDTimes elements should be Objects');\n          }\n\n          foreignIDs.push(fidTime.foreignID);\n          timestamps.push(fidTime.time);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      qs['foreign_ids'] = foreignIDs.join(',');\n      qs['timestamps'] = timestamps.join(',');\n    } else {\n      throw new TypeError('Missing ids or foreignIDTimes params');\n    }\n\n    var token;\n\n    if (this.usingApiSecret) {\n      token = signing.JWTScopeToken(this.apiSecret, 'activities', '*', {\n        feedId: '*',\n        expireTokens: this.expireTokens\n      });\n    } else {\n      token = this.userToken;\n    }\n\n    var path;\n    this.replaceReactionOptions(qs);\n\n    if (this.shouldUseEnrichEndpoint(qs)) {\n      path = 'enrich/activities/';\n    } else {\n      path = 'activities/';\n    }\n\n    return this.get({\n      url: path,\n      qs: qs,\n      signature: token\n    }, callback);\n  },\n  getOrCreateToken: function getOrCreateToken() {\n    return this.usingApiSecret ? signing.JWTScopeToken(this.apiSecret, '*', '*', {\n      feedId: '*'\n    }) : this.userToken;\n  },\n  user: function user(userId) {\n    return new StreamUser(this, userId, this.getOrCreateToken());\n  },\n  setUser: function setUser(data) {\n    var _this = this;\n\n    if (this.usingApiSecret) {\n      throw new errors.SiteError('This method can only be used client-side using a user token');\n    }\n\n    var body = _extends(data);\n\n    delete body.id;\n    return this.currentUser.getOrCreate(body).then(function (user) {\n      _this.currentUser = user;\n      return user;\n    });\n  },\n  og: function og(url) {\n    return this.get({\n      url: 'og/',\n      qs: {\n        url: url\n      },\n      signature: this.getOrCreateToken()\n    });\n  },\n  personalizedFeed: function personalizedFeed() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments.length > 1 ? arguments[1] : undefined;\n    return this.get({\n      url: 'enrich/personalization/feed/',\n      qs: options,\n      signature: this.getOrCreateToken()\n    }, callback);\n  },\n  activityPartialUpdate: function activityPartialUpdate(data, callback) {\n    /**\n     * Update a single activity with partial operations.\n     * @since 3.20.0\n     * @param {object} data object containing either the ID or the foreign ID and time of the activity and the operations to issue as set:{...} and unset:[...].\n     * @return {Promise}\n     * @example\n     * client.activityPartialUpdate({\n     *   id: \"54a60c1e-4ee3-494b-a1e3-50c06acb5ed4\",\n     *   set: {\n     *     \"product.price\": 19.99,\n     *     \"shares\": {\n     *       \"facebook\": \"...\",\n     *       \"twitter\": \"...\",\n     *     }\n     *   },\n     *   unset: [\n     *     \"daily_likes\",\n     *     \"popularity\"\n     *   ]\n     * })\n     * @example\n     * client.activityPartialUpdate({\n     *   foreignID: \"product:123\",\n     *   time: \"2016-11-10T13:20:00.000000\",\n     *   set: {\n     *     ...\n     *   },\n     *   unset: [\n     *     ...\n     *   ]\n     * })\n     */\n    return this.activitiesPartialUpdate([data], callback).then(function (response) {\n      var activity = response.activities[0];\n      delete response.activities;\n      assignIn(activity, response);\n      return activity;\n    });\n  },\n  activitiesPartialUpdate: function activitiesPartialUpdate(changes, callback) {\n    /**\n     * Update multiple activities with partial operations.\n     * @since v3.20.0\n     * @param {array} changes array containing the changesets to be applied. Every changeset contains the activity identifier which is either the ID or the pair of of foreign ID and time of the activity. The operations to issue can be set:{...} and unset:[...].\n     * @return {Promise}\n     * @xample\n     * client.activitiesPartialUpdate([\n     *   {\n     *     id: \"4b39fda2-d6e2-42c9-9abf-5301ef071b12\",\n     *     set: {\n     *       \"product.price.eur\": 12.99,\n     *       \"colors\": {\n     *         \"blue\": \"#0000ff\",\n     *         \"green\": \"#00ff00\",\n     *       },\n     *     },\n     *     unset: [ \"popularity\", \"size.x2\" ],\n     *   },\n     *   {\n     *     id: \"8d2dcad8-1e34-11e9-8b10-9cb6d0925edd\",\n     *     set: {\n     *       \"product.price.eur\": 17.99,\n     *       \"colors\": {\n     *         \"red\": \"#ff0000\",\n     *         \"green\": \"#00ff00\",\n     *       },\n     *     },\n     *     unset: [ \"rating\" ],\n     *   },\n     * ])\n     * @example\n     * client.activitiesPartialUpdate([\n     *   {\n     *     foreignID: \"product:123\",\n     *     time: \"2016-11-10T13:20:00.000000\",\n     *     set: {\n     *       ...\n     *     },\n     *     unset: [\n     *       ...\n     *     ]\n     *   },\n     *   {\n     *     foreignID: \"product:321\",\n     *     time: \"2016-11-10T13:20:00.000000\",\n     *     set: {\n     *       ...\n     *     },\n     *     unset: [\n     *       ...\n     *     ]\n     *   },\n     * ])\n     */\n    if (!(changes instanceof Array)) {\n      throw new TypeError('changes should be an Array');\n    }\n\n    changes.forEach(function (item) {\n      if (!(item instanceof Object)) {\n        throw new TypeError(\"changeset should be and Object\");\n      }\n\n      if (item.foreignID) {\n        item.foreign_id = item.foreignID;\n      }\n\n      if (item.id === undefined && (item.foreign_id === undefined || item.time === undefined)) {\n        throw new TypeError('missing id or foreign ID and time');\n      }\n\n      if (item.set && !(item.set instanceof Object)) {\n        throw new TypeError('set field should be an Object');\n      }\n\n      if (item.unset && !(item.unset instanceof Array)) {\n        throw new TypeError('unset field should be an Array');\n      }\n    });\n    var authToken;\n\n    if (this.usingApiSecret) {\n      authToken = signing.JWTScopeToken(this.apiSecret, 'activities', '*', {\n        feedId: '*',\n        expireTokens: this.expireTokens\n      });\n    } else {\n      authToken = this.userToken;\n    }\n\n    return this.post({\n      url: 'activity/',\n      body: {\n        changes: changes\n      },\n      signature: authToken\n    }, callback);\n  }\n};\nStreamClient.prototype.collection = StreamClient.prototype.collections;\n\nif (qs) {\n  StreamClient.prototype.createRedirectUrl = function (targetUrl, userId, events) {\n    /**\n     * Creates a redirect url for tracking the given events in the context of\n     * an email using Stream's analytics platform. Learn more at\n     * getstream.io/personalization\n     * @method createRedirectUrl\n     * @memberof StreamClient.prototype\n     * @param  {string} targetUrl Target url\n     * @param  {string} userId    User id to track\n     * @param  {array} events     List of events to track\n     * @return {string}           The redirect url\n     */\n    var uri = url.parse(targetUrl);\n\n    if (!(uri.host || uri.hostname && uri.port) && !uri.isUnix) {\n      throw new errors.MissingSchemaError('Invalid URI: \"' + url.format(uri) + '\"');\n    }\n\n    var authToken = signing.JWTScopeToken(this.apiSecret, 'redirect_and_track', '*', {\n      userId: '*',\n      expireTokens: this.expireTokens\n    });\n    var analyticsUrl = this.baseAnalyticsUrl + 'redirect/';\n    var kwargs = {\n      auth_type: 'jwt',\n      authorization: authToken,\n      url: targetUrl,\n      api_key: this.apiKey,\n      events: JSON.stringify(events)\n    };\n    var qString = utils.rfc3986(qs.stringify(kwargs, null, null, {}));\n    return analyticsUrl + '?' + qString;\n  };\n} // If we are in a node environment and batchOperations is available add the methods to the prototype of StreamClient\n\n\nif (BatchOperations) {\n  for (var key in BatchOperations) {\n    if (BatchOperations.hasOwnProperty(key)) {\n      StreamClient.prototype[key] = BatchOperations[key];\n    }\n  }\n}\n\nmodule.exports = StreamClient;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"8oxB\")))\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/client.js?");

/***/ }),

/***/ "jN2H":
/*!*************************************************!*\
  !*** ./node_modules/getstream/lib/lib/utils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"cDf5\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar validFeedSlugRe = /^[\\w]+$/;\nvar validUserIdRe = /^[\\w-]+$/;\n\nfunction validateFeedId(feedId) {\n  /*\n   * Validate that the feedId matches the spec user:1\n   */\n  var parts = feedId.split(':');\n\n  if (parts.length !== 2) {\n    throw new errors.FeedError('Invalid feedId, expected something like user:1 got ' + feedId);\n  }\n\n  var feedSlug = parts[0];\n  var userId = parts[1];\n  validateFeedSlug(feedSlug);\n  validateUserId(userId);\n  return feedId;\n}\n\nexports.validateFeedId = validateFeedId;\n\nfunction validateFeedSlug(feedSlug) {\n  /*\n   * Validate that the feedSlug matches \\w\n   */\n  var valid = validFeedSlugRe.test(feedSlug);\n\n  if (!valid) {\n    throw new errors.FeedError('Invalid feedSlug, please use letters, numbers or _: ' + feedSlug);\n  }\n\n  return feedSlug;\n}\n\nexports.validateFeedSlug = validateFeedSlug;\n\nfunction validateUserId(userId) {\n  /*\n   * Validate the userId matches \\w\n   */\n  var valid = validUserIdRe.test(userId);\n\n  if (!valid) {\n    throw new errors.FeedError('Invalid userId, please use letters, numbers, - or _: ' + userId);\n  }\n\n  return userId;\n}\n\nexports.validateUserId = validateUserId;\n\nfunction rfc3986(str) {\n  return str.replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\nexports.rfc3986 = rfc3986;\n\nfunction isReadableStream(obj) {\n  return _typeof(obj) === 'object' && _typeof(obj._read === 'function') && _typeof(obj._readableState === 'object');\n}\n\nexports.isReadableStream = isReadableStream;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/utils.js?");

/***/ }),

/***/ "nlBe":
/*!***************************************************!*\
  !*** ./node_modules/getstream/lib/lib/signing.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"pVnL\");\n\nvar _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread */ \"MVZn\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"cDf5\");\n\nvar jwt = __webpack_require__(/*! jsonwebtoken */ 0);\n\nvar JWS_REGEX = /^[a-zA-Z0-9\\-_]+?\\.[a-zA-Z0-9\\-_]+?\\.([a-zA-Z0-9\\-_]+)?$/;\n\nvar Base64 = __webpack_require__(/*! Base64 */ \"xoYq\");\n\nfunction decodeBase64Url(base64UrlString) {\n  try {\n    return Base64.atob(toBase64(base64UrlString));\n  } catch (e) {\n    /* istanbul ignore else */\n    if (e.name === 'InvalidCharacterError') {\n      return undefined;\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction safeJsonParse(thing) {\n  if (_typeof(thing) === 'object') return thing;\n\n  try {\n    return JSON.parse(thing);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction padString(string) {\n  var segmentLength = 4;\n  var diff = string.length % segmentLength;\n  if (!diff) return string;\n  var padLength = segmentLength - diff;\n\n  while (padLength--) {\n    string += '=';\n  }\n\n  return string;\n}\n\nfunction toBase64(base64UrlString) {\n  var b64str = padString(base64UrlString).replace(/\\-/g, '+') // eslint-disable-line no-useless-escape\n  .replace(/_/g, '/');\n  return b64str;\n}\n\nfunction headerFromJWS(jwsSig) {\n  var encodedHeader = jwsSig.split('.', 1)[0];\n  return safeJsonParse(decodeBase64Url(encodedHeader));\n}\n\nexports.headerFromJWS = headerFromJWS;\n\nexports.JWTScopeToken = function (apiSecret, resource, action, opts) {\n  /**\n   * Creates the JWT token for feedId, resource and action using the apiSecret\n   * @method JWTScopeToken\n   * @memberof signing\n   * @private\n   * @param {string} apiSecret - API Secret key\n   * @param {string} resource - JWT payload resource\n   * @param {string} action - JWT payload action\n   * @param {object} [options] - Optional additional options\n   * @param {string} [options.feedId] - JWT payload feed identifier\n   * @param {string} [options.userId] - JWT payload user identifier\n   * @return {string} JWT Token\n   */\n  var options = opts || {},\n      noTimestamp = options.expireTokens ? !options.expireTokens : true;\n  var payload = {\n    resource: resource,\n    action: action\n  };\n\n  if (options.feedId) {\n    payload['feed_id'] = options.feedId;\n  }\n\n  if (options.userId) {\n    payload['user_id'] = options.userId;\n  }\n\n  var token = jwt.sign(payload, apiSecret, {\n    algorithm: 'HS256',\n    noTimestamp: noTimestamp\n  });\n  return token;\n};\n\nexports.JWTUserSessionToken = function (apiSecret, userId) {\n  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var jwtOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  /**\n   * Creates the JWT token that can be used for a UserSession\n   * @method JWTUserSessionToken\n   * @memberof signing\n   * @private\n   * @param {string} apiSecret - API Secret key\n   * @param {string} userId - The user_id key in the JWT payload\n   * @param {string} [extraData] - Extra that should be part of the JWT token\n   * @param {object} [jwtOptions] - Options that can be past to jwt.sign\n   * @return {string} JWT Token\n   */\n\n  if (typeof userId !== 'string') {\n    throw new TypeError('userId should be a string');\n  }\n\n  var payload = _objectSpread({\n    user_id: userId\n  }, extraData);\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  var token = jwt.sign(payload, apiSecret, opts);\n  return token;\n};\n\nexports.isJWTSignature = exports.isJWT = function (signature) {\n  /**\n   * check if token is a valid JWT token\n   * @method isJWTSignature\n   * @memberof signing\n   * @private\n   * @param {string} signature - Signature to check\n   * @return {boolean}\n   */\n  if (signature == null || signature.length == 0) {\n    return false;\n  }\n\n  var token = signature.split(' ')[1] || signature;\n  return JWS_REGEX.test(token) && !!headerFromJWS(token);\n};\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/signing.js?");

/***/ }),

/***/ "sQbz":
/*!***************************************************!*\
  !*** ./node_modules/getstream/lib/lib/promise.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Promise = __webpack_require__(/*! faye/src/util/promise */ \"1xLH\");\n\nmodule.exports = Promise;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/promise.js?");

/***/ }),

/***/ "tXJw":
/*!************************************************!*\
  !*** ./node_modules/getstream/lib/lib/user.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"pVnL\");\n\nvar StreamUser = function StreamUser() {\n  this.initialize.apply(this, arguments);\n};\n\nStreamUser.prototype = {\n  initialize: function initialize(client, userId, userAuthToken) {\n    /**\n     * Initialize a user session object\n     * @method intialize\n     * @memberof StreamUser.prototype\n     * @param {StreamClient} client Stream client this collection is constructed from\n     * @param {string} userId The ID of the user\n     * @param {string} token JWT token\n     * @example new StreamUser(client, \"123\", \"eyJhbGciOiJIUzI1...\")\n     */\n    this.client = client;\n    this.id = userId;\n    this.data = undefined;\n    this.full = undefined;\n    this.token = userAuthToken;\n    this.url = 'user/' + this.id + '/';\n  },\n  _streamRef: function _streamRef() {\n    return \"SU:\".concat(this.id);\n  },\n  ref: function ref() {\n    return this._streamRef();\n  },\n  delete: function _delete(callback) {\n    return this.client.delete({\n      url: this.url,\n      signature: this.token\n    }).then(function (response) {\n      if (callback) {\n        callback(response);\n      }\n\n      return response;\n    });\n  },\n  get: function get(options, callback) {\n    var _this = this;\n\n    return this.client.get({\n      url: this.url,\n      signature: this.token,\n      qs: options\n    }).then(function (response) {\n      _this.full = _extends({}, response);\n      delete _this.full.duration;\n      _this.data = _this.full.data;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return _this;\n    });\n  },\n  _chooseData: function _chooseData(data) {\n    if (data !== undefined) {\n      return data;\n    }\n\n    if (this.data !== undefined) {\n      return this.data;\n    }\n\n    return {};\n  },\n  create: function create(data, options, callback) {\n    var _this2 = this;\n\n    return this.client.post({\n      url: 'user/',\n      body: {\n        id: this.id,\n        data: this._chooseData(data)\n      },\n      qs: options,\n      signature: this.token\n    }).then(function (response) {\n      _this2.full = _extends({}, response);\n      delete _this2.full.duration;\n      _this2.data = _this2.full.data;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return _this2;\n    });\n  },\n  update: function update(data, callback) {\n    var _this3 = this;\n\n    return this.client.put({\n      url: this.url,\n      body: {\n        data: this._chooseData(data)\n      },\n      signature: this.token\n    }).then(function (response) {\n      _this3.full = _extends({}, response);\n      delete _this3.full.duration;\n      _this3.data = _this3.full.data;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return _this3;\n    });\n  },\n  getOrCreate: function getOrCreate(data, callback) {\n    return this.create(data, {\n      get_or_create: true\n    }, callback);\n  },\n  profile: function profile(callback) {\n    return this.get({\n      with_follow_counts: true\n    }, callback);\n  }\n};\nmodule.exports = StreamUser;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/user.js?");

/***/ }),

/***/ "tsR5":
/*!***********************************************************!*\
  !*** ./node_modules/getstream/lib/lib/personalization.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Personalization = function Personalization() {\n  /**\n   * Manage api calls for personalization\n   * The collection object contains convenience functions such as  get, post, delete\n   * @class Personalization\n   */\n  this.initialize.apply(this, arguments);\n};\n\nPersonalization.prototype = {\n  /**\n   * Initialize the Personalization object\n   *\n   * @method intialize\n   * @memberof Personalization.prototype\n   * @param {StreamClient} client - The stream client\n   */\n  initialize: function initialize(client) {\n    this.client = client;\n  },\n  get: function get(resource, options, callback) {\n    /**\n     * Get personalized activities for this feed\n     *\n     * @method get\n     * @memberof Personalization.prototype\n     * @param {object} resource - personalized resource endpoint i.e \"follow_recommendations\"\n     * @param {object} options  Additional options\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object. Personalized feed\n     * @example client.personalization.get('follow_recommendations', {foo: 'bar', baz: 'qux'}, cb)\n     */\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n\n    if (!options || options.call) {\n      options = {};\n    }\n\n    return this.client.get({\n      url: resource + '/',\n      serviceName: 'personalization',\n      qs: options,\n      signature: options.token || this.client.getPersonalizationToken()\n    }, callback);\n  },\n  post: function post(resource, options, data, callback) {\n    /**\n     * Post data to personalization endpoint\n     *\n     * @method post\n     * @memberof Personalization.prototype\n     * @param {object} resource - personalized resource endpoint i.e \"follow_recommendations\"\n     * @param {object} options - Additional options\n     * @param {object} data - Data to send in the payload\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object. Data that was posted if successful, or an error.\n     * @example client.personalization.post('follow_recommendations', {foo: 'bar', baz: 'qux'}, cb)\n     */\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n\n    if (!options || options.call) {\n      options = {};\n    }\n\n    if (!data || data.call) {\n      data = {};\n    }\n\n    return this.client.post({\n      url: resource + '/',\n      serviceName: 'personalization',\n      qs: options,\n      body: data,\n      signature: this.client.getPersonalizationToken()\n    }, callback);\n  },\n  delete: function _delete(resource, options, callback) {\n    /**\n     * Delete metadata or activities\n     *\n     * @method delete\n     * @memberof Personalization.prototype\n     * @param {object} resource - personalized resource endpoint i.e \"follow_recommendations\"\n     * @param {object} options - Additional options\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object. Data that was deleted if successful, or an error.\n     * @example client.personalization.delete('follow_recommendations', {foo: 'bar', baz: 'qux'}, cb)\n     */\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n\n    if (!options || options.call) {\n      options = {};\n    }\n\n    return this.client.delete({\n      url: resource + '/',\n      serviceName: 'personalization',\n      qs: options,\n      signature: this.client.getPersonalizationToken()\n    }, callback);\n  }\n};\nmodule.exports = Personalization;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/personalization.js?");

/***/ }),

/***/ "yE4Z":
/*!*******************************************************!*\
  !*** ./node_modules/getstream/lib/lib/collections.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var errors = __webpack_require__(/*! ./errors */ \"BfrC\");\n\nvar Collections = function Collections() {\n  this.initialize.apply(this, arguments);\n};\n\nCollections.prototype = {\n  initialize: function initialize(client, token) {\n    /**\n     * Initialize a feed object\n     * @method intialize\n     * @memberof Collections.prototype\n     * @param {StreamCloudClient} client Stream client this collection is constructed from\n     * @param {string} token JWT token\n     */\n    this.client = client;\n    this.token = token;\n  },\n  buildURL: function buildURL(collection, itemId) {\n    var url = 'collections/' + collection + '/';\n\n    if (itemId === undefined) {\n      return url;\n    }\n\n    return url + itemId + '/';\n  },\n  entry: function entry(collection, itemId, itemData) {\n    return new CollectionEntry(this, collection, itemId, itemData);\n  },\n  get: function get(collection, itemId, callback) {\n    /**\n     * get item from collection\n     * @method get\n     * @memberof Collections.prototype\n     * @param  {string}   collection  collection name\n     * @param  {object}   itemId  id for this entry\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example collection.get(\"food\", \"0c7db91c-67f9-11e8-bcd9-fe00a9219401\")\n     */\n    var self = this;\n    return this.client.get({\n      url: this.buildURL(collection, itemId),\n      signature: this.token\n    }).then(function (response) {\n      var entry = self.client.collections.entry(response.collection, response.id, response.data);\n      entry.full = response;\n\n      if (callback) {\n        callback(entry);\n      }\n\n      return entry;\n    });\n  },\n  add: function add(collection, itemId, itemData, callback) {\n    /**\n     * Add item to collection\n     * @method add\n     * @memberof Collections.prototype\n     * @param  {string}   collection  collection name\n     * @param  {string}   itemId  entry id\n     * @param  {object}   itemData  ObjectStore data\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example collection.add(\"food\", \"cheese101\", {\"name\": \"cheese burger\",\"toppings\": \"cheese\"})\n     */\n    var self = this;\n\n    if (itemId === null) {\n      itemId = undefined;\n    }\n\n    var body = {\n      id: itemId,\n      data: itemData\n    };\n    return this.client.post({\n      url: this.buildURL(collection),\n      body: body,\n      signature: this.token\n    }).then(function (response) {\n      var entry = self.client.collections.entry(response.collection, response.id, response.data);\n      entry.full = response;\n\n      if (callback) {\n        callback(entry);\n      }\n\n      return entry;\n    });\n  },\n  update: function update(collection, entryId, data, callback) {\n    /**\n     * Update entry in the collection\n     * @method update\n     * @memberof Collections.prototype\n     * @param  {string}   collection  collection name\n     * @param  {object}   entryId  Collection object id\n     * @param  {object}   data  ObjectStore data\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example store.update(\"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", {\"name\": \"cheese burger\",\"toppings\": \"cheese\"})\n     * @example store.update(\"food\", \"cheese101\", {\"name\": \"cheese burger\",\"toppings\": \"cheese\"})\n     */\n    var self = this;\n    var body = {\n      data: data\n    };\n    return this.client.put({\n      url: this.buildURL(collection, entryId),\n      body: body,\n      signature: this.token\n    }).then(function (response) {\n      var entry = self.client.collections.entry(response.collection, response.id, response.data);\n      entry.full = response;\n\n      if (callback) {\n        callback(entry);\n      }\n\n      return entry;\n    });\n  },\n  delete: function _delete(collection, entryId, callback) {\n    /**\n     * Delete entry from collection\n     * @method delete\n     * @memberof Collections.prototype\n     * @param  {object}   entryId  Collection entry id\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example collection.delete(\"food\", \"cheese101\")\n     */\n    return this.client['delete']({\n      url: this.buildURL(collection, entryId),\n      signature: this.token\n    }, callback);\n  },\n  upsert: function upsert(collection, data, callback) {\n    /**\n     * Upsert one or more items within a collection.\n     *\n     * @method upsert\n     * @memberof Collections.prototype\n     * @param {object|array} data - A single json object or an array of objects\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object.\n     */\n    if (!this.client.usingApiSecret) {\n      throw new errors.SiteError('This method can only be used server-side using your API Secret');\n    }\n\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n\n    var data_json = {\n      data: {}\n    };\n    data_json['data'][collection] = data;\n    return this.client.post({\n      url: 'collections/',\n      serviceName: 'api',\n      body: data_json,\n      signature: this.client.getCollectionsToken()\n    }, callback);\n  },\n  select: function select(collection, ids, callback) {\n    /**\n     * Select all objects with ids from the collection.\n     *\n     * @method select\n     * @memberof Collections.prototype\n     * @param {object|array} ids - A single json object or an array of objects\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object.\n     */\n    if (!this.client.usingApiSecret) {\n      throw new errors.SiteError('This method can only be used server-side using your API Secret');\n    }\n\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n\n    if (!Array.isArray(ids)) {\n      ids = [ids];\n    }\n\n    var params = {\n      foreign_ids: ids.map(function (id) {\n        return collection + ':' + id;\n      }).join(',')\n    };\n    return this.client.get({\n      url: 'collections/',\n      serviceName: 'api',\n      qs: params,\n      signature: this.client.getCollectionsToken()\n    }, callback);\n  },\n  deleteMany: function deleteMany(collection, ids, callback) {\n    /**\n     * Remove all objects by id from the collection.\n     *\n     * @method delete\n     * @memberof Collections.prototype\n     * @param {object|array} ids - A single json object or an array of objects\n     * @param {requestCallback} callback - Callback to call on completion\n     * @return {Promise} Promise object.\n     */\n    if (!this.client.usingApiSecret) {\n      throw new errors.SiteError('This method can only be used server-side using your API Secret');\n    }\n\n    var last = arguments[arguments.length - 1]; // callback is always the last argument\n\n    callback = last.call ? last : undefined;\n\n    if (!Array.isArray(ids)) {\n      ids = [ids];\n    }\n\n    ids = ids.map(function (id) {\n      return id.toString();\n    }).join(',');\n    var params = {\n      collection_name: collection,\n      ids: ids\n    };\n    return this.client.delete({\n      url: 'collections/',\n      serviceName: 'api',\n      qs: params,\n      signature: this.client.getCollectionsToken()\n    }, callback);\n  }\n};\n\nvar CollectionEntry = function CollectionEntry() {\n  this.initialize.apply(this, arguments);\n};\n\nCollectionEntry.prototype = {\n  initialize: function initialize(store, collection, id, data) {\n    this.collection = collection;\n    this.store = store;\n    this.id = id;\n    this.data = data;\n  },\n  _streamRef: function _streamRef() {\n    return \"SO:\".concat(this.collection, \":\").concat(this.id);\n  },\n  get: function get(callback) {\n    var _this = this;\n    /**\n     * get item from collection and sync data\n     * @method get\n     * @memberof CollectionEntry.prototype\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example collection.get(\"0c7db91c-67f9-11e8-bcd9-fe00a9219401\")\n     */\n\n\n    return this.store.get(this.collection, this.id).then(function (response) {\n      _this.data = response.data;\n      _this.full = response;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return response;\n    });\n  },\n  add: function add(callback) {\n    var _this2 = this;\n    /**\n     * Add item to collection\n     * @method add\n     * @memberof CollectionEntry.prototype\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example collection.add(\"cheese101\", {\"name\": \"cheese burger\",\"toppings\": \"cheese\"})\n     */\n\n\n    return this.store.add(this.collection, this.id, this.data).then(function (response) {\n      _this2.data = response.data;\n      _this2.full = response;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return response;\n    });\n  },\n  update: function update(callback) {\n    var _this3 = this;\n    /**\n     * Update item in the object storage\n     * @method update\n     * @memberof CollectionEntry.prototype\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example store.update(\"0c7db91c-67f9-11e8-bcd9-fe00a9219401\", {\"name\": \"cheese burger\",\"toppings\": \"cheese\"})\n     * @example store.update(\"cheese101\", {\"name\": \"cheese burger\",\"toppings\": \"cheese\"})\n     */\n\n\n    return this.store.update(this.collection, this.id, this.data).then(function (response) {\n      _this3.data = response.data;\n      _this3.full = response;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return response;\n    });\n  },\n  delete: function _delete(callback) {\n    var _this4 = this;\n    /**\n     * Delete item from collection\n     * @method delete\n     * @memberof CollectionEntry.prototype\n     * @param  {requestCallback} callback Callback to call on completion\n     * @return {Promise} Promise object\n     * @example collection.delete(\"cheese101\")\n     */\n\n\n    return this.store.delete(this.collection, this.id).then(function (response) {\n      _this4.data = null;\n      _this4.full = null;\n\n      if (callback) {\n        callback(response);\n      }\n\n      return response;\n    });\n  }\n};\nmodule.exports = Collections;\n\n//# sourceURL=webpack:///./node_modules/getstream/lib/lib/collections.js?");

/***/ })

}]);