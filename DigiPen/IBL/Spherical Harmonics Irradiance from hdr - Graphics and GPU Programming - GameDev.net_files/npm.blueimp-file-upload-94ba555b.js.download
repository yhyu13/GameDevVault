(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.blueimp-file-upload"],{

/***/ "++bc":
/*!******************************************************************!*\
  !*** ./node_modules/blueimp-file-upload/js/jquery.fileupload.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * jQuery File Upload Plugin\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2010, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* jshint nomen:false */\n\n/* global define, require, window, document, location, Blob, FormData */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"EVdn\"), __webpack_require__(/*! jquery-ui/ui/widget */ \"MIQu\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  'use strict'; // Detect file input support, based on\n  // http://viljamis.com/blog/2012/file-upload-support-on-mobile/\n\n  $.support.fileInput = !(new RegExp( // Handle devices which give false positives for the feature detection:\n  '(Android (1\\\\.[0156]|2\\\\.[01]))' + '|(Windows Phone (OS 7|8\\\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' + '|(w(eb)?OSBrowser)|(webOS)' + '|(Kindle/(1\\\\.0|2\\\\.[05]|3\\\\.0))').test(window.navigator.userAgent) || // Feature detection for all other devices:\n  $('<input type=\"file\"/>').prop('disabled')); // The FileReader API is not actually used, but works as feature detection,\n  // as some Safari versions (5?) support XHR file uploads via the FormData API,\n  // but not non-multipart XHR file uploads.\n  // window.XMLHttpRequestUpload is not available on IE10, so we check for\n  // window.ProgressEvent instead to detect XHR2 file upload capability:\n\n  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\n  $.support.xhrFormDataFileUpload = !!window.FormData; // Detect support for Blob slicing (required for chunked uploads):\n\n  $.support.blobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice); // Helper function to create drag handlers for dragover/dragenter/dragleave:\n\n  function getDragHandler(type) {\n    var isDragOver = type === 'dragover';\n    return function (e) {\n      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\n      var dataTransfer = e.dataTransfer;\n\n      if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 && this._trigger(type, $.Event(type, {\n        delegatedEvent: e\n      })) !== false) {\n        e.preventDefault();\n\n        if (isDragOver) {\n          dataTransfer.dropEffect = 'copy';\n        }\n      }\n    };\n  } // The fileupload widget listens for change events on file input fields defined\n  // via fileInput setting and paste or drop events of the given dropZone.\n  // In addition to the default jQuery Widget methods, the fileupload widget\n  // exposes the \"add\" and \"send\" methods, to add or directly send files using\n  // the fileupload API.\n  // By default, files added via file input selection, paste, drag & drop or\n  // \"add\" method are uploaded immediately, but it is possible to override\n  // the \"add\" callback option to queue file uploads.\n\n\n  $.widget('blueimp.fileupload', {\n    options: {\n      // The drop target element(s), by the default the complete document.\n      // Set to null to disable drag & drop support:\n      dropZone: $(document),\n      // The paste target element(s), by the default undefined.\n      // Set to a DOM node or jQuery object to enable file pasting:\n      pasteZone: undefined,\n      // The file input field(s), that are listened to for change events.\n      // If undefined, it is set to the file input fields inside\n      // of the widget element on plugin initialization.\n      // Set to null to disable the change listener.\n      fileInput: undefined,\n      // By default, the file input field is replaced with a clone after\n      // each input field change event. This is required for iframe transport\n      // queues and allows change events to be fired for the same file\n      // selection, but can be disabled by setting the following option to false:\n      replaceFileInput: true,\n      // The parameter name for the file form data (the request argument name).\n      // If undefined or empty, the name property of the file input field is\n      // used, or \"files[]\" if the file input name property is also empty,\n      // can be a string or an array of strings:\n      paramName: undefined,\n      // By default, each file of a selection is uploaded using an individual\n      // request for XHR type uploads. Set to false to upload file\n      // selections in one request each:\n      singleFileUploads: true,\n      // To limit the number of files uploaded with one XHR request,\n      // set the following option to an integer greater than 0:\n      limitMultiFileUploads: undefined,\n      // The following option limits the number of files uploaded with one\n      // XHR request to keep the request size under or equal to the defined\n      // limit in bytes:\n      limitMultiFileUploadSize: undefined,\n      // Multipart file uploads add a number of bytes to each uploaded file,\n      // therefore the following option adds an overhead for each file used\n      // in the limitMultiFileUploadSize configuration:\n      limitMultiFileUploadSizeOverhead: 512,\n      // Set the following option to true to issue all file upload requests\n      // in a sequential order:\n      sequentialUploads: false,\n      // To limit the number of concurrent uploads,\n      // set the following option to an integer greater than 0:\n      limitConcurrentUploads: undefined,\n      // Set the following option to true to force iframe transport uploads:\n      forceIframeTransport: false,\n      // Set the following option to the location of a redirect url on the\n      // origin server, for cross-domain iframe transport uploads:\n      redirect: undefined,\n      // The parameter name for the redirect url, sent as part of the form\n      // data and set to 'redirect' if this option is empty:\n      redirectParamName: undefined,\n      // Set the following option to the location of a postMessage window,\n      // to enable postMessage transport uploads:\n      postMessage: undefined,\n      // By default, XHR file uploads are sent as multipart/form-data.\n      // The iframe transport is always using multipart/form-data.\n      // Set to false to enable non-multipart XHR uploads:\n      multipart: true,\n      // To upload large files in smaller chunks, set the following option\n      // to a preferred maximum chunk size. If set to 0, null or undefined,\n      // or the browser does not support the required Blob API, files will\n      // be uploaded as a whole.\n      maxChunkSize: undefined,\n      // When a non-multipart upload or a chunked multipart upload has been\n      // aborted, this option can be used to resume the upload by setting\n      // it to the size of the already uploaded bytes. This option is most\n      // useful when modifying the options object inside of the \"add\" or\n      // \"send\" callbacks, as the options are cloned for each file upload.\n      uploadedBytes: undefined,\n      // By default, failed (abort or error) file uploads are removed from the\n      // global progress calculation. Set the following option to false to\n      // prevent recalculating the global progress data:\n      recalculateProgress: true,\n      // Interval in milliseconds to calculate and trigger progress events:\n      progressInterval: 100,\n      // Interval in milliseconds to calculate progress bitrate:\n      bitrateInterval: 500,\n      // By default, uploads are started automatically when adding files:\n      autoUpload: true,\n      // By default, duplicate file names are expected to be handled on\n      // the server-side. If this is not possible (e.g. when uploading\n      // files directly to Amazon S3), the following option can be set to\n      // an empty object or an object mapping existing filenames, e.g.:\n      // { \"image.jpg\": true, \"image (1).jpg\": true }\n      // If it is set, all files will be uploaded with unique filenames,\n      // adding increasing number suffixes if necessary, e.g.:\n      // \"image (2).jpg\"\n      uniqueFilenames: undefined,\n      // Error and info messages:\n      messages: {\n        uploadedBytes: 'Uploaded bytes exceed file size'\n      },\n      // Translation function, gets the message key to be translated\n      // and an object with context specific data as arguments:\n      i18n: function (message, context) {\n        message = this.messages[message] || message.toString();\n\n        if (context) {\n          $.each(context, function (key, value) {\n            message = message.replace('{' + key + '}', value);\n          });\n        }\n\n        return message;\n      },\n      // Additional form data to be sent along with the file uploads can be set\n      // using this option, which accepts an array of objects with name and\n      // value properties, a function returning such an array, a FormData\n      // object (for XHR file uploads), or a simple object.\n      // The form of the first fileInput is given as parameter to the function:\n      formData: function (form) {\n        return form.serializeArray();\n      },\n      // The add callback is invoked as soon as files are added to the fileupload\n      // widget (via file input selection, drag & drop, paste or add API call).\n      // If the singleFileUploads option is enabled, this callback will be\n      // called once for each file in the selection for XHR file uploads, else\n      // once for each file selection.\n      //\n      // The upload starts when the submit method is invoked on the data parameter.\n      // The data object contains a files property holding the added files\n      // and allows you to override plugin options as well as define ajax settings.\n      //\n      // Listeners for this callback can also be bound the following way:\n      // .bind('fileuploadadd', func);\n      //\n      // data.submit() returns a Promise object and allows to attach additional\n      // handlers using jQuery's Deferred callbacks:\n      // data.submit().done(func).fail(func).always(func);\n      add: function (e, data) {\n        if (e.isDefaultPrevented()) {\n          return false;\n        }\n\n        if (data.autoUpload || data.autoUpload !== false && $(this).fileupload('option', 'autoUpload')) {\n          data.process().done(function () {\n            data.submit();\n          });\n        }\n      },\n      // Other callbacks:\n      // Callback for the submit event of each file upload:\n      // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\n      // Callback for the start of each file upload request:\n      // send: function (e, data) {}, // .bind('fileuploadsend', func);\n      // Callback for successful uploads:\n      // done: function (e, data) {}, // .bind('fileuploaddone', func);\n      // Callback for failed (abort or error) uploads:\n      // fail: function (e, data) {}, // .bind('fileuploadfail', func);\n      // Callback for completed (success, abort or error) requests:\n      // always: function (e, data) {}, // .bind('fileuploadalways', func);\n      // Callback for upload progress events:\n      // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\n      // Callback for global upload progress events:\n      // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\n      // Callback for uploads start, equivalent to the global ajaxStart event:\n      // start: function (e) {}, // .bind('fileuploadstart', func);\n      // Callback for uploads stop, equivalent to the global ajaxStop event:\n      // stop: function (e) {}, // .bind('fileuploadstop', func);\n      // Callback for change events of the fileInput(s):\n      // change: function (e, data) {}, // .bind('fileuploadchange', func);\n      // Callback for paste events to the pasteZone(s):\n      // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\n      // Callback for drop events of the dropZone(s):\n      // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\n      // Callback for dragover events of the dropZone(s):\n      // dragover: function (e) {}, // .bind('fileuploaddragover', func);\n      // Callback before the start of each chunk upload request (before form data initialization):\n      // chunkbeforesend: function (e, data) {}, // .bind('fileuploadchunkbeforesend', func);\n      // Callback for the start of each chunk upload request:\n      // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\n      // Callback for successful chunk uploads:\n      // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\n      // Callback for failed (abort or error) chunk uploads:\n      // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\n      // Callback for completed (success, abort or error) chunk upload requests:\n      // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\n      // The plugin options are used as settings object for the ajax calls.\n      // The following are jQuery ajax settings required for the file uploads:\n      processData: false,\n      contentType: false,\n      cache: false,\n      timeout: 0\n    },\n    // A list of options that require reinitializing event listeners and/or\n    // special initialization code:\n    _specialOptions: ['fileInput', 'dropZone', 'pasteZone', 'multipart', 'forceIframeTransport'],\n    _blobSlice: $.support.blobSlice && function () {\n      var slice = this.slice || this.webkitSlice || this.mozSlice;\n      return slice.apply(this, arguments);\n    },\n    _BitrateTimer: function () {\n      this.timestamp = Date.now ? Date.now() : new Date().getTime();\n      this.loaded = 0;\n      this.bitrate = 0;\n\n      this.getBitrate = function (now, loaded, interval) {\n        var timeDiff = now - this.timestamp;\n\n        if (!this.bitrate || !interval || timeDiff > interval) {\n          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\n          this.loaded = loaded;\n          this.timestamp = now;\n        }\n\n        return this.bitrate;\n      };\n    },\n    _isXHRUpload: function (options) {\n      return !options.forceIframeTransport && (!options.multipart && $.support.xhrFileUpload || $.support.xhrFormDataFileUpload);\n    },\n    _getFormData: function (options) {\n      var formData;\n\n      if ($.type(options.formData) === 'function') {\n        return options.formData(options.form);\n      }\n\n      if ($.isArray(options.formData)) {\n        return options.formData;\n      }\n\n      if ($.type(options.formData) === 'object') {\n        formData = [];\n        $.each(options.formData, function (name, value) {\n          formData.push({\n            name: name,\n            value: value\n          });\n        });\n        return formData;\n      }\n\n      return [];\n    },\n    _getTotal: function (files) {\n      var total = 0;\n      $.each(files, function (index, file) {\n        total += file.size || 1;\n      });\n      return total;\n    },\n    _initProgressObject: function (obj) {\n      var progress = {\n        loaded: 0,\n        total: 0,\n        bitrate: 0\n      };\n\n      if (obj._progress) {\n        $.extend(obj._progress, progress);\n      } else {\n        obj._progress = progress;\n      }\n    },\n    _initResponseObject: function (obj) {\n      var prop;\n\n      if (obj._response) {\n        for (prop in obj._response) {\n          if (obj._response.hasOwnProperty(prop)) {\n            delete obj._response[prop];\n          }\n        }\n      } else {\n        obj._response = {};\n      }\n    },\n    _onProgress: function (e, data) {\n      if (e.lengthComputable) {\n        var now = Date.now ? Date.now() : new Date().getTime(),\n            loaded;\n\n        if (data._time && data.progressInterval && now - data._time < data.progressInterval && e.loaded !== e.total) {\n          return;\n        }\n\n        data._time = now;\n        loaded = Math.floor(e.loaded / e.total * (data.chunkSize || data._progress.total)) + (data.uploadedBytes || 0); // Add the difference from the previously loaded state\n        // to the global loaded counter:\n\n        this._progress.loaded += loaded - data._progress.loaded;\n        this._progress.bitrate = this._bitrateTimer.getBitrate(now, this._progress.loaded, data.bitrateInterval);\n        data._progress.loaded = data.loaded = loaded;\n        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(now, loaded, data.bitrateInterval); // Trigger a custom progress event with a total data property set\n        // to the file size(s) of the current upload and a loaded data\n        // property calculated accordingly:\n\n        this._trigger('progress', $.Event('progress', {\n          delegatedEvent: e\n        }), data); // Trigger a global progress event for all current file uploads,\n        // including ajax calls queued for sequential file uploads:\n\n\n        this._trigger('progressall', $.Event('progressall', {\n          delegatedEvent: e\n        }), this._progress);\n      }\n    },\n    _initProgressListener: function (options) {\n      var that = this,\n          xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr(); // Accesss to the native XHR object is required to add event listeners\n      // for the upload progress event:\n\n      if (xhr.upload) {\n        $(xhr.upload).bind('progress', function (e) {\n          var oe = e.originalEvent; // Make sure the progress event properties get copied over:\n\n          e.lengthComputable = oe.lengthComputable;\n          e.loaded = oe.loaded;\n          e.total = oe.total;\n\n          that._onProgress(e, options);\n        });\n\n        options.xhr = function () {\n          return xhr;\n        };\n      }\n    },\n    _deinitProgressListener: function (options) {\n      var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\n\n      if (xhr.upload) {\n        $(xhr.upload).unbind('progress');\n      }\n    },\n    _isInstanceOf: function (type, obj) {\n      // Cross-frame instanceof check\n      return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n    },\n    _getUniqueFilename: function (name, map) {\n      name = String(name);\n\n      if (map[name]) {\n        name = name.replace(/(?: \\(([\\d]+)\\))?(\\.[^.]+)?$/, function (_, p1, p2) {\n          var index = p1 ? Number(p1) + 1 : 1;\n          var ext = p2 || '';\n          return ' (' + index + ')' + ext;\n        });\n        return this._getUniqueFilename(name, map);\n      }\n\n      map[name] = true;\n      return name;\n    },\n    _initXHRData: function (options) {\n      var that = this,\n          formData,\n          file = options.files[0],\n          // Ignore non-multipart setting if not supported:\n      multipart = options.multipart || !$.support.xhrFileUpload,\n          paramName = $.type(options.paramName) === 'array' ? options.paramName[0] : options.paramName;\n      options.headers = $.extend({}, options.headers);\n\n      if (options.contentRange) {\n        options.headers['Content-Range'] = options.contentRange;\n      }\n\n      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\n        options.headers['Content-Disposition'] = 'attachment; filename=\"' + encodeURI(file.uploadName || file.name) + '\"';\n      }\n\n      if (!multipart) {\n        options.contentType = file.type || 'application/octet-stream';\n        options.data = options.blob || file;\n      } else if ($.support.xhrFormDataFileUpload) {\n        if (options.postMessage) {\n          // window.postMessage does not allow sending FormData\n          // objects, so we just add the File/Blob objects to\n          // the formData array and let the postMessage window\n          // create the FormData object out of this array:\n          formData = this._getFormData(options);\n\n          if (options.blob) {\n            formData.push({\n              name: paramName,\n              value: options.blob\n            });\n          } else {\n            $.each(options.files, function (index, file) {\n              formData.push({\n                name: $.type(options.paramName) === 'array' && options.paramName[index] || paramName,\n                value: file\n              });\n            });\n          }\n        } else {\n          if (that._isInstanceOf('FormData', options.formData)) {\n            formData = options.formData;\n          } else {\n            formData = new FormData();\n            $.each(this._getFormData(options), function (index, field) {\n              formData.append(field.name, field.value);\n            });\n          }\n\n          if (options.blob) {\n            formData.append(paramName, options.blob, file.uploadName || file.name);\n          } else {\n            $.each(options.files, function (index, file) {\n              // This check allows the tests to run with\n              // dummy objects:\n              if (that._isInstanceOf('File', file) || that._isInstanceOf('Blob', file)) {\n                var fileName = file.uploadName || file.name;\n\n                if (options.uniqueFilenames) {\n                  fileName = that._getUniqueFilename(fileName, options.uniqueFilenames);\n                }\n\n                formData.append($.type(options.paramName) === 'array' && options.paramName[index] || paramName, file, fileName);\n              }\n            });\n          }\n        }\n\n        options.data = formData;\n      } // Blob reference is not needed anymore, free memory:\n\n\n      options.blob = null;\n    },\n    _initIframeSettings: function (options) {\n      var targetHost = $('<a></a>').prop('href', options.url).prop('host'); // Setting the dataType to iframe enables the iframe transport:\n\n      options.dataType = 'iframe ' + (options.dataType || ''); // The iframe transport accepts a serialized array as form data:\n\n      options.formData = this._getFormData(options); // Add redirect url to form data on cross-domain uploads:\n\n      if (options.redirect && targetHost && targetHost !== location.host) {\n        options.formData.push({\n          name: options.redirectParamName || 'redirect',\n          value: options.redirect\n        });\n      }\n    },\n    _initDataSettings: function (options) {\n      if (this._isXHRUpload(options)) {\n        if (!this._chunkedUpload(options, true)) {\n          if (!options.data) {\n            this._initXHRData(options);\n          }\n\n          this._initProgressListener(options);\n        }\n\n        if (options.postMessage) {\n          // Setting the dataType to postmessage enables the\n          // postMessage transport:\n          options.dataType = 'postmessage ' + (options.dataType || '');\n        }\n      } else {\n        this._initIframeSettings(options);\n      }\n    },\n    _getParamName: function (options) {\n      var fileInput = $(options.fileInput),\n          paramName = options.paramName;\n\n      if (!paramName) {\n        paramName = [];\n        fileInput.each(function () {\n          var input = $(this),\n              name = input.prop('name') || 'files[]',\n              i = (input.prop('files') || [1]).length;\n\n          while (i) {\n            paramName.push(name);\n            i -= 1;\n          }\n        });\n\n        if (!paramName.length) {\n          paramName = [fileInput.prop('name') || 'files[]'];\n        }\n      } else if (!$.isArray(paramName)) {\n        paramName = [paramName];\n      }\n\n      return paramName;\n    },\n    _initFormSettings: function (options) {\n      // Retrieve missing options from the input field and the\n      // associated form, if available:\n      if (!options.form || !options.form.length) {\n        options.form = $(options.fileInput.prop('form')); // If the given file input doesn't have an associated form,\n        // use the default widget file input's form:\n\n        if (!options.form.length) {\n          options.form = $(this.options.fileInput.prop('form'));\n        }\n      }\n\n      options.paramName = this._getParamName(options);\n\n      if (!options.url) {\n        options.url = options.form.prop('action') || location.href;\n      } // The HTTP request method must be \"POST\" or \"PUT\":\n\n\n      options.type = (options.type || $.type(options.form.prop('method')) === 'string' && options.form.prop('method') || '').toUpperCase();\n\n      if (options.type !== 'POST' && options.type !== 'PUT' && options.type !== 'PATCH') {\n        options.type = 'POST';\n      }\n\n      if (!options.formAcceptCharset) {\n        options.formAcceptCharset = options.form.attr('accept-charset');\n      }\n    },\n    _getAJAXSettings: function (data) {\n      var options = $.extend({}, this.options, data);\n\n      this._initFormSettings(options);\n\n      this._initDataSettings(options);\n\n      return options;\n    },\n    // jQuery 1.6 doesn't provide .state(),\n    // while jQuery 1.8+ removed .isRejected() and .isResolved():\n    _getDeferredState: function (deferred) {\n      if (deferred.state) {\n        return deferred.state();\n      }\n\n      if (deferred.isResolved()) {\n        return 'resolved';\n      }\n\n      if (deferred.isRejected()) {\n        return 'rejected';\n      }\n\n      return 'pending';\n    },\n    // Maps jqXHR callbacks to the equivalent\n    // methods of the given Promise object:\n    _enhancePromise: function (promise) {\n      promise.success = promise.done;\n      promise.error = promise.fail;\n      promise.complete = promise.always;\n      return promise;\n    },\n    // Creates and returns a Promise object enhanced with\n    // the jqXHR methods abort, success, error and complete:\n    _getXHRPromise: function (resolveOrReject, context, args) {\n      var dfd = $.Deferred(),\n          promise = dfd.promise();\n      context = context || this.options.context || promise;\n\n      if (resolveOrReject === true) {\n        dfd.resolveWith(context, args);\n      } else if (resolveOrReject === false) {\n        dfd.rejectWith(context, args);\n      }\n\n      promise.abort = dfd.promise;\n      return this._enhancePromise(promise);\n    },\n    // Adds convenience methods to the data callback argument:\n    _addConvenienceMethods: function (e, data) {\n      var that = this,\n          getPromise = function (args) {\n        return $.Deferred().resolveWith(that, args).promise();\n      };\n\n      data.process = function (resolveFunc, rejectFunc) {\n        if (resolveFunc || rejectFunc) {\n          data._processQueue = this._processQueue = (this._processQueue || getPromise([this])).then(function () {\n            if (data.errorThrown) {\n              return $.Deferred().rejectWith(that, [data]).promise();\n            }\n\n            return getPromise(arguments);\n          }).then(resolveFunc, rejectFunc);\n        }\n\n        return this._processQueue || getPromise([this]);\n      };\n\n      data.submit = function () {\n        if (this.state() !== 'pending') {\n          data.jqXHR = this.jqXHR = that._trigger('submit', $.Event('submit', {\n            delegatedEvent: e\n          }), this) !== false && that._onSend(e, this);\n        }\n\n        return this.jqXHR || that._getXHRPromise();\n      };\n\n      data.abort = function () {\n        if (this.jqXHR) {\n          return this.jqXHR.abort();\n        }\n\n        this.errorThrown = 'abort';\n\n        that._trigger('fail', null, this);\n\n        return that._getXHRPromise(false);\n      };\n\n      data.state = function () {\n        if (this.jqXHR) {\n          return that._getDeferredState(this.jqXHR);\n        }\n\n        if (this._processQueue) {\n          return that._getDeferredState(this._processQueue);\n        }\n      };\n\n      data.processing = function () {\n        return !this.jqXHR && this._processQueue && that._getDeferredState(this._processQueue) === 'pending';\n      };\n\n      data.progress = function () {\n        return this._progress;\n      };\n\n      data.response = function () {\n        return this._response;\n      };\n    },\n    // Parses the Range header from the server response\n    // and returns the uploaded bytes:\n    _getUploadedBytes: function (jqXHR) {\n      var range = jqXHR.getResponseHeader('Range'),\n          parts = range && range.split('-'),\n          upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);\n      return upperBytesPos && upperBytesPos + 1;\n    },\n    // Uploads a file in multiple, sequential requests\n    // by splitting the file up in multiple blob chunks.\n    // If the second parameter is true, only tests if the file\n    // should be uploaded in chunks, but does not invoke any\n    // upload requests:\n    _chunkedUpload: function (options, testOnly) {\n      options.uploadedBytes = options.uploadedBytes || 0;\n      var that = this,\n          file = options.files[0],\n          fs = file.size,\n          ub = options.uploadedBytes,\n          mcs = options.maxChunkSize || fs,\n          slice = this._blobSlice,\n          dfd = $.Deferred(),\n          promise = dfd.promise(),\n          jqXHR,\n          upload;\n\n      if (!(this._isXHRUpload(options) && slice && (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)) || options.data) {\n        return false;\n      }\n\n      if (testOnly) {\n        return true;\n      }\n\n      if (ub >= fs) {\n        file.error = options.i18n('uploadedBytes');\n        return this._getXHRPromise(false, options.context, [null, 'error', file.error]);\n      } // The chunk upload method:\n\n\n      upload = function () {\n        // Clone the options object for each chunk upload:\n        var o = $.extend({}, options),\n            currentLoaded = o._progress.loaded;\n        o.blob = slice.call(file, ub, ub + ($.type(mcs) === 'function' ? mcs(o) : mcs), file.type); // Store the current chunk size, as the blob itself\n        // will be dereferenced after data processing:\n\n        o.chunkSize = o.blob.size; // Expose the chunk bytes position range:\n\n        o.contentRange = 'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs; // Trigger chunkbeforesend to allow form data to be updated for this chunk\n\n        that._trigger('chunkbeforesend', null, o); // Process the upload data (the blob and potential form data):\n\n\n        that._initXHRData(o); // Add progress listeners for this chunk upload:\n\n\n        that._initProgressListener(o);\n\n        jqXHR = (that._trigger('chunksend', null, o) !== false && $.ajax(o) || that._getXHRPromise(false, o.context)).done(function (result, textStatus, jqXHR) {\n          ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize; // Create a progress event if no final progress event\n          // with loaded equaling total has been triggered\n          // for this chunk:\n\n          if (currentLoaded + o.chunkSize - o._progress.loaded) {\n            that._onProgress($.Event('progress', {\n              lengthComputable: true,\n              loaded: ub - o.uploadedBytes,\n              total: ub - o.uploadedBytes\n            }), o);\n          }\n\n          options.uploadedBytes = o.uploadedBytes = ub;\n          o.result = result;\n          o.textStatus = textStatus;\n          o.jqXHR = jqXHR;\n\n          that._trigger('chunkdone', null, o);\n\n          that._trigger('chunkalways', null, o);\n\n          if (ub < fs) {\n            // File upload not yet complete,\n            // continue with the next chunk:\n            upload();\n          } else {\n            dfd.resolveWith(o.context, [result, textStatus, jqXHR]);\n          }\n        }).fail(function (jqXHR, textStatus, errorThrown) {\n          o.jqXHR = jqXHR;\n          o.textStatus = textStatus;\n          o.errorThrown = errorThrown;\n\n          that._trigger('chunkfail', null, o);\n\n          that._trigger('chunkalways', null, o);\n\n          dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);\n        }).always(function () {\n          that._deinitProgressListener(o);\n        });\n      };\n\n      this._enhancePromise(promise);\n\n      promise.abort = function () {\n        return jqXHR.abort();\n      };\n\n      upload();\n      return promise;\n    },\n    _beforeSend: function (e, data) {\n      if (this._active === 0) {\n        // the start callback is triggered when an upload starts\n        // and no other uploads are currently running,\n        // equivalent to the global ajaxStart event:\n        this._trigger('start'); // Set timer for global bitrate progress calculation:\n\n\n        this._bitrateTimer = new this._BitrateTimer(); // Reset the global progress values:\n\n        this._progress.loaded = this._progress.total = 0;\n        this._progress.bitrate = 0;\n      } // Make sure the container objects for the .response() and\n      // .progress() methods on the data object are available\n      // and reset to their initial state:\n\n\n      this._initResponseObject(data);\n\n      this._initProgressObject(data);\n\n      data._progress.loaded = data.loaded = data.uploadedBytes || 0;\n      data._progress.total = data.total = this._getTotal(data.files) || 1;\n      data._progress.bitrate = data.bitrate = 0;\n      this._active += 1; // Initialize the global progress values:\n\n      this._progress.loaded += data.loaded;\n      this._progress.total += data.total;\n    },\n    _onDone: function (result, textStatus, jqXHR, options) {\n      var total = options._progress.total,\n          response = options._response;\n\n      if (options._progress.loaded < total) {\n        // Create a progress event if no final progress event\n        // with loaded equaling total has been triggered:\n        this._onProgress($.Event('progress', {\n          lengthComputable: true,\n          loaded: total,\n          total: total\n        }), options);\n      }\n\n      response.result = options.result = result;\n      response.textStatus = options.textStatus = textStatus;\n      response.jqXHR = options.jqXHR = jqXHR;\n\n      this._trigger('done', null, options);\n    },\n    _onFail: function (jqXHR, textStatus, errorThrown, options) {\n      var response = options._response;\n\n      if (options.recalculateProgress) {\n        // Remove the failed (error or abort) file upload from\n        // the global progress calculation:\n        this._progress.loaded -= options._progress.loaded;\n        this._progress.total -= options._progress.total;\n      }\n\n      response.jqXHR = options.jqXHR = jqXHR;\n      response.textStatus = options.textStatus = textStatus;\n      response.errorThrown = options.errorThrown = errorThrown;\n\n      this._trigger('fail', null, options);\n    },\n    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\n      // jqXHRorResult, textStatus and jqXHRorError are added to the\n      // options object via done and fail callbacks\n      this._trigger('always', null, options);\n    },\n    _onSend: function (e, data) {\n      if (!data.submit) {\n        this._addConvenienceMethods(e, data);\n      }\n\n      var that = this,\n          jqXHR,\n          aborted,\n          slot,\n          pipe,\n          options = that._getAJAXSettings(data),\n          send = function () {\n        that._sending += 1; // Set timer for bitrate progress calculation:\n\n        options._bitrateTimer = new that._BitrateTimer();\n        jqXHR = jqXHR || ((aborted || that._trigger('send', $.Event('send', {\n          delegatedEvent: e\n        }), options) === false) && that._getXHRPromise(false, options.context, aborted) || that._chunkedUpload(options) || $.ajax(options)).done(function (result, textStatus, jqXHR) {\n          that._onDone(result, textStatus, jqXHR, options);\n        }).fail(function (jqXHR, textStatus, errorThrown) {\n          that._onFail(jqXHR, textStatus, errorThrown, options);\n        }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\n          that._deinitProgressListener(options);\n\n          that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options);\n\n          that._sending -= 1;\n          that._active -= 1;\n\n          if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) {\n            // Start the next queued upload,\n            // that has not been aborted:\n            var nextSlot = that._slots.shift();\n\n            while (nextSlot) {\n              if (that._getDeferredState(nextSlot) === 'pending') {\n                nextSlot.resolve();\n                break;\n              }\n\n              nextSlot = that._slots.shift();\n            }\n          }\n\n          if (that._active === 0) {\n            // The stop callback is triggered when all uploads have\n            // been completed, equivalent to the global ajaxStop event:\n            that._trigger('stop');\n          }\n        });\n        return jqXHR;\n      };\n\n      this._beforeSend(e, options);\n\n      if (this.options.sequentialUploads || this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending) {\n        if (this.options.limitConcurrentUploads > 1) {\n          slot = $.Deferred();\n\n          this._slots.push(slot);\n\n          pipe = slot.then(send);\n        } else {\n          this._sequence = this._sequence.then(send, send);\n          pipe = this._sequence;\n        } // Return the piped Promise object, enhanced with an abort method,\n        // which is delegated to the jqXHR object of the current upload,\n        // and jqXHR callbacks mapped to the equivalent Promise methods:\n\n\n        pipe.abort = function () {\n          aborted = [undefined, 'abort', 'abort'];\n\n          if (!jqXHR) {\n            if (slot) {\n              slot.rejectWith(options.context, aborted);\n            }\n\n            return send();\n          }\n\n          return jqXHR.abort();\n        };\n\n        return this._enhancePromise(pipe);\n      }\n\n      return send();\n    },\n    _onAdd: function (e, data) {\n      var that = this,\n          result = true,\n          options = $.extend({}, this.options, data),\n          files = data.files,\n          filesLength = files.length,\n          limit = options.limitMultiFileUploads,\n          limitSize = options.limitMultiFileUploadSize,\n          overhead = options.limitMultiFileUploadSizeOverhead,\n          batchSize = 0,\n          paramName = this._getParamName(options),\n          paramNameSet,\n          paramNameSlice,\n          fileSet,\n          i,\n          j = 0;\n\n      if (!filesLength) {\n        return false;\n      }\n\n      if (limitSize && files[0].size === undefined) {\n        limitSize = undefined;\n      }\n\n      if (!(options.singleFileUploads || limit || limitSize) || !this._isXHRUpload(options)) {\n        fileSet = [files];\n        paramNameSet = [paramName];\n      } else if (!(options.singleFileUploads || limitSize) && limit) {\n        fileSet = [];\n        paramNameSet = [];\n\n        for (i = 0; i < filesLength; i += limit) {\n          fileSet.push(files.slice(i, i + limit));\n          paramNameSlice = paramName.slice(i, i + limit);\n\n          if (!paramNameSlice.length) {\n            paramNameSlice = paramName;\n          }\n\n          paramNameSet.push(paramNameSlice);\n        }\n      } else if (!options.singleFileUploads && limitSize) {\n        fileSet = [];\n        paramNameSet = [];\n\n        for (i = 0; i < filesLength; i = i + 1) {\n          batchSize += files[i].size + overhead;\n\n          if (i + 1 === filesLength || batchSize + files[i + 1].size + overhead > limitSize || limit && i + 1 - j >= limit) {\n            fileSet.push(files.slice(j, i + 1));\n            paramNameSlice = paramName.slice(j, i + 1);\n\n            if (!paramNameSlice.length) {\n              paramNameSlice = paramName;\n            }\n\n            paramNameSet.push(paramNameSlice);\n            j = i + 1;\n            batchSize = 0;\n          }\n        }\n      } else {\n        paramNameSet = paramName;\n      }\n\n      data.originalFiles = files;\n      $.each(fileSet || files, function (index, element) {\n        var newData = $.extend({}, data);\n        newData.files = fileSet ? element : [element];\n        newData.paramName = paramNameSet[index];\n\n        that._initResponseObject(newData);\n\n        that._initProgressObject(newData);\n\n        that._addConvenienceMethods(e, newData);\n\n        result = that._trigger('add', $.Event('add', {\n          delegatedEvent: e\n        }), newData);\n        return result;\n      });\n      return result;\n    },\n    _replaceFileInput: function (data) {\n      var input = data.fileInput,\n          inputClone = input.clone(true),\n          restoreFocus = input.is(document.activeElement); // Add a reference for the new cloned file input to the data argument:\n\n      data.fileInputClone = inputClone;\n      $('<form></form>').append(inputClone)[0].reset(); // Detaching allows to insert the fileInput on another form\n      // without loosing the file input value:\n\n      input.after(inputClone).detach(); // If the fileInput had focus before it was detached,\n      // restore focus to the inputClone.\n\n      if (restoreFocus) {\n        inputClone.focus();\n      } // Avoid memory leaks with the detached file input:\n\n\n      $.cleanData(input.unbind('remove')); // Replace the original file input element in the fileInput\n      // elements set with the clone, which has been copied including\n      // event handlers:\n\n      this.options.fileInput = this.options.fileInput.map(function (i, el) {\n        if (el === input[0]) {\n          return inputClone[0];\n        }\n\n        return el;\n      }); // If the widget has been initialized on the file input itself,\n      // override this.element with the file input clone:\n\n      if (input[0] === this.element[0]) {\n        this.element = inputClone;\n      }\n    },\n    _handleFileTreeEntry: function (entry, path) {\n      var that = this,\n          dfd = $.Deferred(),\n          entries = [],\n          dirReader,\n          errorHandler = function (e) {\n        if (e && !e.entry) {\n          e.entry = entry;\n        } // Since $.when returns immediately if one\n        // Deferred is rejected, we use resolve instead.\n        // This allows valid files and invalid items\n        // to be returned together in one set:\n\n\n        dfd.resolve([e]);\n      },\n          successHandler = function (entries) {\n        that._handleFileTreeEntries(entries, path + entry.name + '/').done(function (files) {\n          dfd.resolve(files);\n        }).fail(errorHandler);\n      },\n          readEntries = function () {\n        dirReader.readEntries(function (results) {\n          if (!results.length) {\n            successHandler(entries);\n          } else {\n            entries = entries.concat(results);\n            readEntries();\n          }\n        }, errorHandler);\n      };\n\n      path = path || '';\n\n      if (entry.isFile) {\n        if (entry._file) {\n          // Workaround for Chrome bug #149735\n          entry._file.relativePath = path;\n          dfd.resolve(entry._file);\n        } else {\n          entry.file(function (file) {\n            file.relativePath = path;\n            dfd.resolve(file);\n          }, errorHandler);\n        }\n      } else if (entry.isDirectory) {\n        dirReader = entry.createReader();\n        readEntries();\n      } else {\n        // Return an empty list for file system items\n        // other than files or directories:\n        dfd.resolve([]);\n      }\n\n      return dfd.promise();\n    },\n    _handleFileTreeEntries: function (entries, path) {\n      var that = this;\n      return $.when.apply($, $.map(entries, function (entry) {\n        return that._handleFileTreeEntry(entry, path);\n      })).then(function () {\n        return Array.prototype.concat.apply([], arguments);\n      });\n    },\n    _getDroppedFiles: function (dataTransfer) {\n      dataTransfer = dataTransfer || {};\n      var items = dataTransfer.items;\n\n      if (items && items.length && (items[0].webkitGetAsEntry || items[0].getAsEntry)) {\n        return this._handleFileTreeEntries($.map(items, function (item) {\n          var entry;\n\n          if (item.webkitGetAsEntry) {\n            entry = item.webkitGetAsEntry();\n\n            if (entry) {\n              // Workaround for Chrome bug #149735:\n              entry._file = item.getAsFile();\n            }\n\n            return entry;\n          }\n\n          return item.getAsEntry();\n        }));\n      }\n\n      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();\n    },\n    _getSingleFileInputFiles: function (fileInput) {\n      fileInput = $(fileInput);\n      var entries = fileInput.prop('webkitEntries') || fileInput.prop('entries'),\n          files,\n          value;\n\n      if (entries && entries.length) {\n        return this._handleFileTreeEntries(entries);\n      }\n\n      files = $.makeArray(fileInput.prop('files'));\n\n      if (!files.length) {\n        value = fileInput.prop('value');\n\n        if (!value) {\n          return $.Deferred().resolve([]).promise();\n        } // If the files property is not available, the browser does not\n        // support the File API and we add a pseudo File object with\n        // the input value as name with path information removed:\n\n\n        files = [{\n          name: value.replace(/^.*\\\\/, '')\n        }];\n      } else if (files[0].name === undefined && files[0].fileName) {\n        // File normalization for Safari 4 and Firefox 3:\n        $.each(files, function (index, file) {\n          file.name = file.fileName;\n          file.size = file.fileSize;\n        });\n      }\n\n      return $.Deferred().resolve(files).promise();\n    },\n    _getFileInputFiles: function (fileInput) {\n      if (!(fileInput instanceof $) || fileInput.length === 1) {\n        return this._getSingleFileInputFiles(fileInput);\n      }\n\n      return $.when.apply($, $.map(fileInput, this._getSingleFileInputFiles)).then(function () {\n        return Array.prototype.concat.apply([], arguments);\n      });\n    },\n    _onChange: function (e) {\n      var that = this,\n          data = {\n        fileInput: $(e.target),\n        form: $(e.target.form)\n      };\n\n      this._getFileInputFiles(data.fileInput).always(function (files) {\n        data.files = files;\n\n        if (that.options.replaceFileInput) {\n          that._replaceFileInput(data);\n        }\n\n        if (that._trigger('change', $.Event('change', {\n          delegatedEvent: e\n        }), data) !== false) {\n          that._onAdd(e, data);\n        }\n      });\n    },\n    _onPaste: function (e) {\n      var items = e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.items,\n          data = {\n        files: []\n      };\n\n      if (items && items.length) {\n        $.each(items, function (index, item) {\n          var file = item.getAsFile && item.getAsFile();\n\n          if (file) {\n            data.files.push(file);\n          }\n        });\n\n        if (this._trigger('paste', $.Event('paste', {\n          delegatedEvent: e\n        }), data) !== false) {\n          this._onAdd(e, data);\n        }\n      }\n    },\n    _onDrop: function (e) {\n      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\n      var that = this,\n          dataTransfer = e.dataTransfer,\n          data = {};\n\n      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n        e.preventDefault();\n\n        this._getDroppedFiles(dataTransfer).always(function (files) {\n          data.files = files;\n\n          if (that._trigger('drop', $.Event('drop', {\n            delegatedEvent: e\n          }), data) !== false) {\n            that._onAdd(e, data);\n          }\n        });\n      }\n    },\n    _onDragOver: getDragHandler('dragover'),\n    _onDragEnter: getDragHandler('dragenter'),\n    _onDragLeave: getDragHandler('dragleave'),\n    _initEventHandlers: function () {\n      if (this._isXHRUpload(this.options)) {\n        this._on(this.options.dropZone, {\n          dragover: this._onDragOver,\n          drop: this._onDrop,\n          // event.preventDefault() on dragenter is required for IE10+:\n          dragenter: this._onDragEnter,\n          // dragleave is not required, but added for completeness:\n          dragleave: this._onDragLeave\n        });\n\n        this._on(this.options.pasteZone, {\n          paste: this._onPaste\n        });\n      }\n\n      if ($.support.fileInput) {\n        this._on(this.options.fileInput, {\n          change: this._onChange\n        });\n      }\n    },\n    _destroyEventHandlers: function () {\n      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\n\n      this._off(this.options.pasteZone, 'paste');\n\n      this._off(this.options.fileInput, 'change');\n    },\n    _destroy: function () {\n      this._destroyEventHandlers();\n    },\n    _setOption: function (key, value) {\n      var reinit = $.inArray(key, this._specialOptions) !== -1;\n\n      if (reinit) {\n        this._destroyEventHandlers();\n      }\n\n      this._super(key, value);\n\n      if (reinit) {\n        this._initSpecialOptions();\n\n        this._initEventHandlers();\n      }\n    },\n    _initSpecialOptions: function () {\n      var options = this.options;\n\n      if (options.fileInput === undefined) {\n        options.fileInput = this.element.is('input[type=\"file\"]') ? this.element : this.element.find('input[type=\"file\"]');\n      } else if (!(options.fileInput instanceof $)) {\n        options.fileInput = $(options.fileInput);\n      }\n\n      if (!(options.dropZone instanceof $)) {\n        options.dropZone = $(options.dropZone);\n      }\n\n      if (!(options.pasteZone instanceof $)) {\n        options.pasteZone = $(options.pasteZone);\n      }\n    },\n    _getRegExp: function (str) {\n      var parts = str.split('/'),\n          modifiers = parts.pop();\n      parts.shift();\n      return new RegExp(parts.join('/'), modifiers);\n    },\n    _isRegExpOption: function (key, value) {\n      return key !== 'url' && $.type(value) === 'string' && /^\\/.*\\/[igm]{0,3}$/.test(value);\n    },\n    _initDataAttributes: function () {\n      var that = this,\n          options = this.options,\n          data = this.element.data(); // Initialize options set via HTML5 data-attributes:\n\n      $.each(this.element[0].attributes, function (index, attr) {\n        var key = attr.name.toLowerCase(),\n            value;\n\n        if (/^data-/.test(key)) {\n          // Convert hyphen-ated key to camelCase:\n          key = key.slice(5).replace(/-[a-z]/g, function (str) {\n            return str.charAt(1).toUpperCase();\n          });\n          value = data[key];\n\n          if (that._isRegExpOption(key, value)) {\n            value = that._getRegExp(value);\n          }\n\n          options[key] = value;\n        }\n      });\n    },\n    _create: function () {\n      this._initDataAttributes();\n\n      this._initSpecialOptions();\n\n      this._slots = [];\n      this._sequence = this._getXHRPromise(true);\n      this._sending = this._active = 0;\n\n      this._initProgressObject(this);\n\n      this._initEventHandlers();\n    },\n    // This method is exposed to the widget API and allows to query\n    // the number of active uploads:\n    active: function () {\n      return this._active;\n    },\n    // This method is exposed to the widget API and allows to query\n    // the widget upload progress.\n    // It returns an object with loaded, total and bitrate properties\n    // for the running uploads:\n    progress: function () {\n      return this._progress;\n    },\n    // This method is exposed to the widget API and allows adding files\n    // using the fileupload API. The data parameter accepts an object which\n    // must have a files property and can contain additional options:\n    // .fileupload('add', {files: filesList});\n    add: function (data) {\n      var that = this;\n\n      if (!data || this.options.disabled) {\n        return;\n      }\n\n      if (data.fileInput && !data.files) {\n        this._getFileInputFiles(data.fileInput).always(function (files) {\n          data.files = files;\n\n          that._onAdd(null, data);\n        });\n      } else {\n        data.files = $.makeArray(data.files);\n\n        this._onAdd(null, data);\n      }\n    },\n    // This method is exposed to the widget API and allows sending files\n    // using the fileupload API. The data parameter accepts an object which\n    // must have a files or fileInput property and can contain additional options:\n    // .fileupload('send', {files: filesList});\n    // The method returns a Promise object for the file upload call.\n    send: function (data) {\n      if (data && !this.options.disabled) {\n        if (data.fileInput && !data.files) {\n          var that = this,\n              dfd = $.Deferred(),\n              promise = dfd.promise(),\n              jqXHR,\n              aborted;\n\n          promise.abort = function () {\n            aborted = true;\n\n            if (jqXHR) {\n              return jqXHR.abort();\n            }\n\n            dfd.reject(null, 'abort', 'abort');\n            return promise;\n          };\n\n          this._getFileInputFiles(data.fileInput).always(function (files) {\n            if (aborted) {\n              return;\n            }\n\n            if (!files.length) {\n              dfd.reject();\n              return;\n            }\n\n            data.files = files;\n            jqXHR = that._onSend(null, data);\n            jqXHR.then(function (result, textStatus, jqXHR) {\n              dfd.resolve(result, textStatus, jqXHR);\n            }, function (jqXHR, textStatus, errorThrown) {\n              dfd.reject(jqXHR, textStatus, errorThrown);\n            });\n          });\n\n          return this._enhancePromise(promise);\n        }\n\n        data.files = $.makeArray(data.files);\n\n        if (data.files.length) {\n          return this._onSend(null, data);\n        }\n      }\n\n      return this._getXHRPromise(false, data && data.context);\n    }\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/blueimp-file-upload/js/jquery.fileupload.js?");

/***/ }),

/***/ "KmIb":
/*!************************************************************************!*\
  !*** ./node_modules/blueimp-file-upload/js/vendor/jquery.ui.widget.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery UI - v1.12.1+CommonJS - 2018-02-10\n * http://jqueryui.com\n * Includes: widget.js\n * Copyright jQuery Foundation and other contributors; Licensed MIT */\n(function (factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"EVdn\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  $.ui = $.ui || {};\n  var version = $.ui.version = \"1.12.1\";\n  /*!\n   * jQuery UI Widget 1.12.1\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   */\n  //>>label: Widget\n  //>>group: Core\n  //>>description: Provides a factory for creating stateful widgets with a common API.\n  //>>docs: http://api.jqueryui.com/jQuery.widget/\n  //>>demos: http://jqueryui.com/widget/\n\n  var widgetUuid = 0;\n  var widgetSlice = Array.prototype.slice;\n\n  $.cleanData = function (orig) {\n    return function (elems) {\n      var events, elem, i;\n\n      for (i = 0; (elem = elems[i]) != null; i++) {\n        try {\n          // Only trigger remove when necessary to save time\n          events = $._data(elem, \"events\");\n\n          if (events && events.remove) {\n            $(elem).triggerHandler(\"remove\");\n          } // Http://bugs.jquery.com/ticket/8235\n\n        } catch (e) {}\n      }\n\n      orig(elems);\n    };\n  }($.cleanData);\n\n  $.widget = function (name, base, prototype) {\n    var existingConstructor, constructor, basePrototype; // ProxiedPrototype allows the provided prototype to remain unmodified\n    // so that it can be used as a mixin for multiple widgets (#8876)\n\n    var proxiedPrototype = {};\n    var namespace = name.split(\".\")[0];\n    name = name.split(\".\")[1];\n    var fullName = namespace + \"-\" + name;\n\n    if (!prototype) {\n      prototype = base;\n      base = $.Widget;\n    }\n\n    if ($.isArray(prototype)) {\n      prototype = $.extend.apply(null, [{}].concat(prototype));\n    } // Create selector for plugin\n\n\n    $.expr[\":\"][fullName.toLowerCase()] = function (elem) {\n      return !!$.data(elem, fullName);\n    };\n\n    $[namespace] = $[namespace] || {};\n    existingConstructor = $[namespace][name];\n\n    constructor = $[namespace][name] = function (options, element) {\n      // Allow instantiation without \"new\" keyword\n      if (!this._createWidget) {\n        return new constructor(options, element);\n      } // Allow instantiation without initializing for simple inheritance\n      // must use \"new\" keyword (the code above always passes args)\n\n\n      if (arguments.length) {\n        this._createWidget(options, element);\n      }\n    }; // Extend with the existing constructor to carry over any static properties\n\n\n    $.extend(constructor, existingConstructor, {\n      version: prototype.version,\n      // Copy the object used to create the prototype in case we need to\n      // redefine the widget later\n      _proto: $.extend({}, prototype),\n      // Track widgets that inherit from this widget in case this widget is\n      // redefined after a widget inherits from it\n      _childConstructors: []\n    });\n    basePrototype = new base(); // We need to make the options hash a property directly on the new instance\n    // otherwise we'll modify the options hash on the prototype that we're\n    // inheriting from\n\n    basePrototype.options = $.widget.extend({}, basePrototype.options);\n    $.each(prototype, function (prop, value) {\n      if (!$.isFunction(value)) {\n        proxiedPrototype[prop] = value;\n        return;\n      }\n\n      proxiedPrototype[prop] = function () {\n        function _super() {\n          return base.prototype[prop].apply(this, arguments);\n        }\n\n        function _superApply(args) {\n          return base.prototype[prop].apply(this, args);\n        }\n\n        return function () {\n          var __super = this._super;\n          var __superApply = this._superApply;\n          var returnValue;\n          this._super = _super;\n          this._superApply = _superApply;\n          returnValue = value.apply(this, arguments);\n          this._super = __super;\n          this._superApply = __superApply;\n          return returnValue;\n        };\n      }();\n    });\n    constructor.prototype = $.widget.extend(basePrototype, {\n      // TODO: remove support for widgetEventPrefix\n      // always use the name + a colon as the prefix, e.g., draggable:start\n      // don't prefix for widgets that aren't DOM-based\n      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name\n    }, proxiedPrototype, {\n      constructor: constructor,\n      namespace: namespace,\n      widgetName: name,\n      widgetFullName: fullName\n    }); // If this widget is being redefined then we need to find all widgets that\n    // are inheriting from it and redefine all of them so that they inherit from\n    // the new version of this widget. We're essentially trying to replace one\n    // level in the prototype chain.\n\n    if (existingConstructor) {\n      $.each(existingConstructor._childConstructors, function (i, child) {\n        var childPrototype = child.prototype; // Redefine the child widget using the same prototype that was\n        // originally used, but inherit from the new version of the base\n\n        $.widget(childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto);\n      }); // Remove the list of existing child constructors from the old constructor\n      // so the old child constructors can be garbage collected\n\n      delete existingConstructor._childConstructors;\n    } else {\n      base._childConstructors.push(constructor);\n    }\n\n    $.widget.bridge(name, constructor);\n    return constructor;\n  };\n\n  $.widget.extend = function (target) {\n    var input = widgetSlice.call(arguments, 1);\n    var inputIndex = 0;\n    var inputLength = input.length;\n    var key;\n    var value;\n\n    for (; inputIndex < inputLength; inputIndex++) {\n      for (key in input[inputIndex]) {\n        value = input[inputIndex][key];\n\n        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {\n          // Clone objects\n          if ($.isPlainObject(value)) {\n            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects\n            $.widget.extend({}, value); // Copy everything else by reference\n          } else {\n            target[key] = value;\n          }\n        }\n      }\n    }\n\n    return target;\n  };\n\n  $.widget.bridge = function (name, object) {\n    var fullName = object.prototype.widgetFullName || name;\n\n    $.fn[name] = function (options) {\n      var isMethodCall = typeof options === \"string\";\n      var args = widgetSlice.call(arguments, 1);\n      var returnValue = this;\n\n      if (isMethodCall) {\n        // If this is an empty collection, we need to have the instance method\n        // return undefined instead of the jQuery instance\n        if (!this.length && options === \"instance\") {\n          returnValue = undefined;\n        } else {\n          this.each(function () {\n            var methodValue;\n            var instance = $.data(this, fullName);\n\n            if (options === \"instance\") {\n              returnValue = instance;\n              return false;\n            }\n\n            if (!instance) {\n              return $.error(\"cannot call methods on \" + name + \" prior to initialization; \" + \"attempted to call method '\" + options + \"'\");\n            }\n\n            if (!$.isFunction(instance[options]) || options.charAt(0) === \"_\") {\n              return $.error(\"no such method '\" + options + \"' for \" + name + \" widget instance\");\n            }\n\n            methodValue = instance[options].apply(instance, args);\n\n            if (methodValue !== instance && methodValue !== undefined) {\n              returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;\n              return false;\n            }\n          });\n        }\n      } else {\n        // Allow multiple hashes to be passed on init\n        if (args.length) {\n          options = $.widget.extend.apply(null, [options].concat(args));\n        }\n\n        this.each(function () {\n          var instance = $.data(this, fullName);\n\n          if (instance) {\n            instance.option(options || {});\n\n            if (instance._init) {\n              instance._init();\n            }\n          } else {\n            $.data(this, fullName, new object(options, this));\n          }\n        });\n      }\n\n      return returnValue;\n    };\n  };\n\n  $.Widget = function ()\n  /* options, element */\n  {};\n\n  $.Widget._childConstructors = [];\n  $.Widget.prototype = {\n    widgetName: \"widget\",\n    widgetEventPrefix: \"\",\n    defaultElement: \"<div>\",\n    options: {\n      classes: {},\n      disabled: false,\n      // Callbacks\n      create: null\n    },\n    _createWidget: function (options, element) {\n      element = $(element || this.defaultElement || this)[0];\n      this.element = $(element);\n      this.uuid = widgetUuid++;\n      this.eventNamespace = \".\" + this.widgetName + this.uuid;\n      this.bindings = $();\n      this.hoverable = $();\n      this.focusable = $();\n      this.classesElementLookup = {};\n\n      if (element !== this) {\n        $.data(element, this.widgetFullName, this);\n\n        this._on(true, this.element, {\n          remove: function (event) {\n            if (event.target === element) {\n              this.destroy();\n            }\n          }\n        });\n\n        this.document = $(element.style ? // Element within the document\n        element.ownerDocument : // Element is window or document\n        element.document || element);\n        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);\n      }\n\n      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);\n\n      this._create();\n\n      if (this.options.disabled) {\n        this._setOptionDisabled(this.options.disabled);\n      }\n\n      this._trigger(\"create\", null, this._getCreateEventData());\n\n      this._init();\n    },\n    _getCreateOptions: function () {\n      return {};\n    },\n    _getCreateEventData: $.noop,\n    _create: $.noop,\n    _init: $.noop,\n    destroy: function () {\n      var that = this;\n\n      this._destroy();\n\n      $.each(this.classesElementLookup, function (key, value) {\n        that._removeClass(value, key);\n      }); // We can probably remove the unbind calls in 2.0\n      // all event bindings should go through this._on()\n\n      this.element.off(this.eventNamespace).removeData(this.widgetFullName);\n      this.widget().off(this.eventNamespace).removeAttr(\"aria-disabled\"); // Clean up events and states\n\n      this.bindings.off(this.eventNamespace);\n    },\n    _destroy: $.noop,\n    widget: function () {\n      return this.element;\n    },\n    option: function (key, value) {\n      var options = key;\n      var parts;\n      var curOption;\n      var i;\n\n      if (arguments.length === 0) {\n        // Don't return a reference to the internal hash\n        return $.widget.extend({}, this.options);\n      }\n\n      if (typeof key === \"string\") {\n        // Handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n        options = {};\n        parts = key.split(\".\");\n        key = parts.shift();\n\n        if (parts.length) {\n          curOption = options[key] = $.widget.extend({}, this.options[key]);\n\n          for (i = 0; i < parts.length - 1; i++) {\n            curOption[parts[i]] = curOption[parts[i]] || {};\n            curOption = curOption[parts[i]];\n          }\n\n          key = parts.pop();\n\n          if (arguments.length === 1) {\n            return curOption[key] === undefined ? null : curOption[key];\n          }\n\n          curOption[key] = value;\n        } else {\n          if (arguments.length === 1) {\n            return this.options[key] === undefined ? null : this.options[key];\n          }\n\n          options[key] = value;\n        }\n      }\n\n      this._setOptions(options);\n\n      return this;\n    },\n    _setOptions: function (options) {\n      var key;\n\n      for (key in options) {\n        this._setOption(key, options[key]);\n      }\n\n      return this;\n    },\n    _setOption: function (key, value) {\n      if (key === \"classes\") {\n        this._setOptionClasses(value);\n      }\n\n      this.options[key] = value;\n\n      if (key === \"disabled\") {\n        this._setOptionDisabled(value);\n      }\n\n      return this;\n    },\n    _setOptionClasses: function (value) {\n      var classKey, elements, currentElements;\n\n      for (classKey in value) {\n        currentElements = this.classesElementLookup[classKey];\n\n        if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {\n          continue;\n        } // We are doing this to create a new jQuery object because the _removeClass() call\n        // on the next line is going to destroy the reference to the current elements being\n        // tracked. We need to save a copy of this collection so that we can add the new classes\n        // below.\n\n\n        elements = $(currentElements.get());\n\n        this._removeClass(currentElements, classKey); // We don't use _addClass() here, because that uses this.options.classes\n        // for generating the string of classes. We want to use the value passed in from\n        // _setOption(), this is the new value of the classes option which was passed to\n        // _setOption(). We pass this value directly to _classes().\n\n\n        elements.addClass(this._classes({\n          element: elements,\n          keys: classKey,\n          classes: value,\n          add: true\n        }));\n      }\n    },\n    _setOptionDisabled: function (value) {\n      this._toggleClass(this.widget(), this.widgetFullName + \"-disabled\", null, !!value); // If the widget is becoming disabled, then nothing is interactive\n\n\n      if (value) {\n        this._removeClass(this.hoverable, null, \"ui-state-hover\");\n\n        this._removeClass(this.focusable, null, \"ui-state-focus\");\n      }\n    },\n    enable: function () {\n      return this._setOptions({\n        disabled: false\n      });\n    },\n    disable: function () {\n      return this._setOptions({\n        disabled: true\n      });\n    },\n    _classes: function (options) {\n      var full = [];\n      var that = this;\n      options = $.extend({\n        element: this.element,\n        classes: this.options.classes || {}\n      }, options);\n\n      function processClassString(classes, checkOption) {\n        var current, i;\n\n        for (i = 0; i < classes.length; i++) {\n          current = that.classesElementLookup[classes[i]] || $();\n\n          if (options.add) {\n            current = $($.unique(current.get().concat(options.element.get())));\n          } else {\n            current = $(current.not(options.element).get());\n          }\n\n          that.classesElementLookup[classes[i]] = current;\n          full.push(classes[i]);\n\n          if (checkOption && options.classes[classes[i]]) {\n            full.push(options.classes[classes[i]]);\n          }\n        }\n      }\n\n      this._on(options.element, {\n        \"remove\": \"_untrackClassesElement\"\n      });\n\n      if (options.keys) {\n        processClassString(options.keys.match(/\\S+/g) || [], true);\n      }\n\n      if (options.extra) {\n        processClassString(options.extra.match(/\\S+/g) || []);\n      }\n\n      return full.join(\" \");\n    },\n    _untrackClassesElement: function (event) {\n      var that = this;\n      $.each(that.classesElementLookup, function (key, value) {\n        if ($.inArray(event.target, value) !== -1) {\n          that.classesElementLookup[key] = $(value.not(event.target).get());\n        }\n      });\n    },\n    _removeClass: function (element, keys, extra) {\n      return this._toggleClass(element, keys, extra, false);\n    },\n    _addClass: function (element, keys, extra) {\n      return this._toggleClass(element, keys, extra, true);\n    },\n    _toggleClass: function (element, keys, extra, add) {\n      add = typeof add === \"boolean\" ? add : extra;\n      var shift = typeof element === \"string\" || element === null,\n          options = {\n        extra: shift ? keys : extra,\n        keys: shift ? element : keys,\n        element: shift ? this.element : element,\n        add: add\n      };\n      options.element.toggleClass(this._classes(options), add);\n      return this;\n    },\n    _on: function (suppressDisabledCheck, element, handlers) {\n      var delegateElement;\n      var instance = this; // No suppressDisabledCheck flag, shuffle arguments\n\n      if (typeof suppressDisabledCheck !== \"boolean\") {\n        handlers = element;\n        element = suppressDisabledCheck;\n        suppressDisabledCheck = false;\n      } // No element argument, shuffle and use this.element\n\n\n      if (!handlers) {\n        handlers = element;\n        element = this.element;\n        delegateElement = this.widget();\n      } else {\n        element = delegateElement = $(element);\n        this.bindings = this.bindings.add(element);\n      }\n\n      $.each(handlers, function (event, handler) {\n        function handlerProxy() {\n          // Allow widgets to customize the disabled handling\n          // - disabled as an array instead of boolean\n          // - disabled class as method for disabling individual parts\n          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass(\"ui-state-disabled\"))) {\n            return;\n          }\n\n          return (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n        } // Copy the guid so direct unbinding works\n\n\n        if (typeof handler !== \"string\") {\n          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;\n        }\n\n        var match = event.match(/^([\\w:-]*)\\s*(.*)$/);\n        var eventName = match[1] + instance.eventNamespace;\n        var selector = match[2];\n\n        if (selector) {\n          delegateElement.on(eventName, selector, handlerProxy);\n        } else {\n          element.on(eventName, handlerProxy);\n        }\n      });\n    },\n    _off: function (element, eventName) {\n      eventName = (eventName || \"\").split(\" \").join(this.eventNamespace + \" \") + this.eventNamespace;\n      element.off(eventName).off(eventName); // Clear the stack to avoid memory leaks (#10056)\n\n      this.bindings = $(this.bindings.not(element).get());\n      this.focusable = $(this.focusable.not(element).get());\n      this.hoverable = $(this.hoverable.not(element).get());\n    },\n    _delay: function (handler, delay) {\n      function handlerProxy() {\n        return (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n      }\n\n      var instance = this;\n      return setTimeout(handlerProxy, delay || 0);\n    },\n    _hoverable: function (element) {\n      this.hoverable = this.hoverable.add(element);\n\n      this._on(element, {\n        mouseenter: function (event) {\n          this._addClass($(event.currentTarget), null, \"ui-state-hover\");\n        },\n        mouseleave: function (event) {\n          this._removeClass($(event.currentTarget), null, \"ui-state-hover\");\n        }\n      });\n    },\n    _focusable: function (element) {\n      this.focusable = this.focusable.add(element);\n\n      this._on(element, {\n        focusin: function (event) {\n          this._addClass($(event.currentTarget), null, \"ui-state-focus\");\n        },\n        focusout: function (event) {\n          this._removeClass($(event.currentTarget), null, \"ui-state-focus\");\n        }\n      });\n    },\n    _trigger: function (type, event, data) {\n      var prop, orig;\n      var callback = this.options[type];\n      data = data || {};\n      event = $.Event(event);\n      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); // The original event may come from any element\n      // so we need to reset the target on the new event\n\n      event.target = this.element[0]; // Copy original event properties over to the new event\n\n      orig = event.originalEvent;\n\n      if (orig) {\n        for (prop in orig) {\n          if (!(prop in event)) {\n            event[prop] = orig[prop];\n          }\n        }\n      }\n\n      this.element.trigger(event, data);\n      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());\n    }\n  };\n  $.each({\n    show: \"fadeIn\",\n    hide: \"fadeOut\"\n  }, function (method, defaultEffect) {\n    $.Widget.prototype[\"_\" + method] = function (element, options, callback) {\n      if (typeof options === \"string\") {\n        options = {\n          effect: options\n        };\n      }\n\n      var hasOptions;\n      var effectName = !options ? method : options === true || typeof options === \"number\" ? defaultEffect : options.effect || defaultEffect;\n      options = options || {};\n\n      if (typeof options === \"number\") {\n        options = {\n          duration: options\n        };\n      }\n\n      hasOptions = !$.isEmptyObject(options);\n      options.complete = callback;\n\n      if (options.delay) {\n        element.delay(options.delay);\n      }\n\n      if (hasOptions && $.effects && $.effects.effect[effectName]) {\n        element[method](options);\n      } else if (effectName !== method && element[effectName]) {\n        element[effectName](options.duration, options.easing, callback);\n      } else {\n        element.queue(function (next) {\n          $(this)[method]();\n\n          if (callback) {\n            callback.call(element[0]);\n          }\n\n          next();\n        });\n      }\n    };\n  });\n  var widget = $.widget;\n});\n\n//# sourceURL=webpack:///./node_modules/blueimp-file-upload/js/vendor/jquery.ui.widget.js?");

/***/ }),

/***/ "zXS5":
/*!************************************************************************!*\
  !*** ./node_modules/blueimp-file-upload/js/jquery.iframe-transport.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * jQuery Iframe Transport Plugin\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, require, window, document, JSON */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"EVdn\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  'use strict'; // Helper variable to create unique names for the transport iframes:\n\n  var counter = 0,\n      jsonAPI = $,\n      jsonParse = 'parseJSON';\n\n  if ('JSON' in window && 'parse' in JSON) {\n    jsonAPI = JSON;\n    jsonParse = 'parse';\n  } // The iframe transport accepts four additional options:\n  // options.fileInput: a jQuery collection of file input fields\n  // options.paramName: the parameter name for the file form data,\n  //  overrides the name property of the file input field(s),\n  //  can be a string or an array of strings.\n  // options.formData: an array of objects with name and value properties,\n  //  equivalent to the return data of .serializeArray(), e.g.:\n  //  [{name: 'a', value: 1}, {name: 'b', value: 2}]\n  // options.initialIframeSrc: the URL of the initial iframe src,\n  //  by default set to \"javascript:false;\"\n\n\n  $.ajaxTransport('iframe', function (options) {\n    if (options.async) {\n      // javascript:false as initial iframe src\n      // prevents warning popups on HTTPS in IE6:\n\n      /*jshint scripturl: true */\n      var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',\n\n      /*jshint scripturl: false */\n      form,\n          iframe,\n          addParamChar;\n      return {\n        send: function (_, completeCallback) {\n          form = $('<form style=\"display:none;\"></form>');\n          form.attr('accept-charset', options.formAcceptCharset);\n          addParamChar = /\\?/.test(options.url) ? '&' : '?'; // XDomainRequest only supports GET and POST:\n\n          if (options.type === 'DELETE') {\n            options.url = options.url + addParamChar + '_method=DELETE';\n            options.type = 'POST';\n          } else if (options.type === 'PUT') {\n            options.url = options.url + addParamChar + '_method=PUT';\n            options.type = 'POST';\n          } else if (options.type === 'PATCH') {\n            options.url = options.url + addParamChar + '_method=PATCH';\n            options.type = 'POST';\n          } // IE versions below IE8 cannot set the name property of\n          // elements that have already been added to the DOM,\n          // so we set the name along with the iframe HTML markup:\n\n\n          counter += 1;\n          iframe = $('<iframe src=\"' + initialIframeSrc + '\" name=\"iframe-transport-' + counter + '\"></iframe>').bind('load', function () {\n            var fileInputClones,\n                paramNames = $.isArray(options.paramName) ? options.paramName : [options.paramName];\n            iframe.unbind('load').bind('load', function () {\n              var response; // Wrap in a try/catch block to catch exceptions thrown\n              // when trying to access cross-domain iframe contents:\n\n              try {\n                response = iframe.contents(); // Google Chrome and Firefox do not throw an\n                // exception when calling iframe.contents() on\n                // cross-domain requests, so we unify the response:\n\n                if (!response.length || !response[0].firstChild) {\n                  throw new Error();\n                }\n              } catch (e) {\n                response = undefined;\n              } // The complete callback returns the\n              // iframe content document as response object:\n\n\n              completeCallback(200, 'success', {\n                'iframe': response\n              }); // Fix for IE endless progress bar activity bug\n              // (happens on form submits to iframe targets):\n\n              $('<iframe src=\"' + initialIframeSrc + '\"></iframe>').appendTo(form);\n              window.setTimeout(function () {\n                // Removing the form in a setTimeout call\n                // allows Chrome's developer tools to display\n                // the response result\n                form.remove();\n              }, 0);\n            });\n            form.prop('target', iframe.prop('name')).prop('action', options.url).prop('method', options.type);\n\n            if (options.formData) {\n              $.each(options.formData, function (index, field) {\n                $('<input type=\"hidden\"/>').prop('name', field.name).val(field.value).appendTo(form);\n              });\n            }\n\n            if (options.fileInput && options.fileInput.length && options.type === 'POST') {\n              fileInputClones = options.fileInput.clone(); // Insert a clone for each file input field:\n\n              options.fileInput.after(function (index) {\n                return fileInputClones[index];\n              });\n\n              if (options.paramName) {\n                options.fileInput.each(function (index) {\n                  $(this).prop('name', paramNames[index] || options.paramName);\n                });\n              } // Appending the file input fields to the hidden form\n              // removes them from their original location:\n\n\n              form.append(options.fileInput).prop('enctype', 'multipart/form-data') // enctype must be set as encoding for IE:\n              .prop('encoding', 'multipart/form-data'); // Remove the HTML5 form attribute from the input(s):\n\n              options.fileInput.removeAttr('form');\n            }\n\n            form.submit(); // Insert the file input fields at their original location\n            // by replacing the clones with the originals:\n\n            if (fileInputClones && fileInputClones.length) {\n              options.fileInput.each(function (index, input) {\n                var clone = $(fileInputClones[index]); // Restore the original name and form properties:\n\n                $(input).prop('name', clone.prop('name')).attr('form', clone.attr('form'));\n                clone.replaceWith(input);\n              });\n            }\n          });\n          form.append(iframe).appendTo(document.body);\n        },\n        abort: function () {\n          if (iframe) {\n            // javascript:false as iframe src aborts the request\n            // and prevents warning popups on HTTPS in IE6.\n            // concat is used to avoid the \"Script URL\" JSLint error:\n            iframe.unbind('load').prop('src', initialIframeSrc);\n          }\n\n          if (form) {\n            form.remove();\n          }\n        }\n      };\n    }\n  }); // The iframe transport returns the iframe content document as response.\n  // The following adds converters from iframe to text, json, html, xml\n  // and script.\n  // Please note that the Content-Type for JSON responses has to be text/plain\n  // or text/html, if the browser doesn't include application/json in the\n  // Accept header, else IE will show a download dialog.\n  // The Content-Type for XML responses on the other hand has to be always\n  // application/xml or text/xml, so IE properly parses the XML response.\n  // See also\n  // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation\n\n  $.ajaxSetup({\n    converters: {\n      'iframe text': function (iframe) {\n        return iframe && $(iframe[0].body).text();\n      },\n      'iframe json': function (iframe) {\n        return iframe && jsonAPI[jsonParse]($(iframe[0].body).text());\n      },\n      'iframe html': function (iframe) {\n        return iframe && $(iframe[0].body).html();\n      },\n      'iframe xml': function (iframe) {\n        var xmlDoc = iframe && iframe[0];\n        return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc : $.parseXML(xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml || $(xmlDoc.body).html());\n      },\n      'iframe script': function (iframe) {\n        return iframe && $.globalEval($(iframe[0].body).text());\n      }\n    }\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/blueimp-file-upload/js/jquery.iframe-transport.js?");

/***/ })

}]);