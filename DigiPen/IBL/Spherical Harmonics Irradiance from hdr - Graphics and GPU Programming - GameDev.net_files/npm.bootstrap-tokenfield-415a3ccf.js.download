(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.bootstrap-tokenfield"],{

/***/ "Bn07":
/*!************************************************************************!*\
  !*** ./node_modules/bootstrap-tokenfield/dist/bootstrap-tokenfield.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * bootstrap-tokenfield\n * https://github.com/sliptree/bootstrap-tokenfield\n * Copyright 2013-2014 Sliptree and other contributors; Licensed MIT\n */\n(function (factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"EVdn\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($, window) {\n  \"use strict\"; // jshint ;_;\n\n  /* TOKENFIELD PUBLIC CLASS DEFINITION\n   * ============================== */\n\n  var Tokenfield = function (element, options) {\n    var _self = this;\n\n    this.$element = $(element);\n    this.textDirection = this.$element.css('direction'); // Extend options\n\n    this.options = $.extend(true, {}, $.fn.tokenfield.defaults, {\n      tokens: this.$element.val()\n    }, this.$element.data(), options); // Setup delimiters and trigger keys\n\n    this._delimiters = typeof this.options.delimiter === 'string' ? [this.options.delimiter] : this.options.delimiter;\n    this._triggerKeys = $.map(this._delimiters, function (delimiter) {\n      return delimiter.charCodeAt(0);\n    });\n    this._firstDelimiter = this._delimiters[0]; // Check for whitespace, dash and special characters\n\n    var whitespace = $.inArray(' ', this._delimiters),\n        dash = $.inArray('-', this._delimiters);\n    if (whitespace >= 0) this._delimiters[whitespace] = '\\\\s';\n\n    if (dash >= 0) {\n      delete this._delimiters[dash];\n\n      this._delimiters.unshift('-');\n    }\n\n    var specialCharacters = ['\\\\', '$', '[', '{', '^', '.', '|', '?', '*', '+', '(', ')'];\n    $.each(this._delimiters, function (index, char) {\n      var pos = $.inArray(char, specialCharacters);\n      if (pos >= 0) _self._delimiters[index] = '\\\\' + char;\n    }); // Store original input width\n\n    var elRules = window && typeof window.getMatchedCSSRules === 'function' ? window.getMatchedCSSRules(element) : null,\n        elStyleWidth = element.style.width,\n        elCSSWidth,\n        elWidth = this.$element.width();\n\n    if (elRules) {\n      $.each(elRules, function (i, rule) {\n        if (rule.style.width) {\n          elCSSWidth = rule.style.width;\n        }\n      });\n    } // Move original input out of the way\n\n\n    var hidingPosition = $('body').css('direction') === 'rtl' ? 'right' : 'left',\n        originalStyles = {\n      position: this.$element.css('position')\n    };\n    originalStyles[hidingPosition] = this.$element.css(hidingPosition);\n    this.$element.data('original-styles', originalStyles).data('original-tabindex', this.$element.prop('tabindex')).css('position', 'absolute').css(hidingPosition, '-10000px').prop('tabindex', -1); // Create a wrapper\n\n    this.$wrapper = $('<div class=\"tokenfield form-control\" />');\n    if (this.$element.hasClass('input-lg')) this.$wrapper.addClass('input-lg');\n    if (this.$element.hasClass('input-sm')) this.$wrapper.addClass('input-sm');\n    if (this.textDirection === 'rtl') this.$wrapper.addClass('rtl'); // Create a new input\n\n    var id = this.$element.prop('id') || new Date().getTime() + '' + Math.floor((1 + Math.random()) * 100);\n    this.$input = $('<input type=\"text\" class=\"token-input\" autocomplete=\"off\" />').appendTo(this.$wrapper).prop('placeholder', this.$element.prop('placeholder')).prop('id', id + '-tokenfield').prop('tabindex', this.$element.data('original-tabindex')); // Re-route original input label to new input\n\n    var $label = $('label[for=\"' + this.$element.prop('id') + '\"]');\n\n    if ($label.length) {\n      $label.prop('for', this.$input.prop('id'));\n    } // Set up a copy helper to handle copy & paste\n\n\n    this.$copyHelper = $('<input type=\"text\" />').css('position', 'absolute').css(hidingPosition, '-10000px').prop('tabindex', -1).prependTo(this.$wrapper); // Set wrapper width\n\n    if (elStyleWidth) {\n      this.$wrapper.css('width', elStyleWidth);\n    } else if (elCSSWidth) {\n      this.$wrapper.css('width', elCSSWidth);\n    } // If input is inside inline-form with no width set, set fixed width\n    else if (this.$element.parents('.form-inline').length) {\n        this.$wrapper.width(elWidth);\n      } // Set tokenfield disabled, if original or fieldset input is disabled\n\n\n    if (this.$element.prop('disabled') || this.$element.parents('fieldset[disabled]').length) {\n      this.disable();\n    } // Set tokenfield readonly, if original input is readonly\n\n\n    if (this.$element.prop('readonly')) {\n      this.readonly();\n    } // Set up mirror for input auto-sizing\n\n\n    this.$mirror = $('<span style=\"position:absolute; top:-999px; left:0; white-space:pre;\"/>');\n    this.$input.css('min-width', this.options.minWidth + 'px');\n    $.each(['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'letterSpacing', 'textTransform', 'wordSpacing', 'textIndent'], function (i, val) {\n      _self.$mirror[0].style[val] = _self.$input.css(val);\n    });\n    this.$mirror.appendTo('body'); // Insert tokenfield to HTML\n\n    this.$wrapper.insertBefore(this.$element);\n    this.$element.prependTo(this.$wrapper); // Calculate inner input width\n\n    this.update(); // Create initial tokens, if any\n\n    this.setTokens(this.options.tokens, false, false); // Start listening to events\n\n    this.listen(); // Initialize autocomplete, if necessary\n\n    if (!$.isEmptyObject(this.options.autocomplete)) {\n      var side = this.textDirection === 'rtl' ? 'right' : 'left',\n          autocompleteOptions = $.extend({\n        minLength: this.options.showAutocompleteOnFocus ? 0 : null,\n        position: {\n          my: side + \" top\",\n          at: side + \" bottom\",\n          of: this.$wrapper\n        }\n      }, this.options.autocomplete);\n      this.$input.autocomplete(autocompleteOptions);\n    } // Initialize typeahead, if necessary\n\n\n    if (!$.isEmptyObject(this.options.typeahead)) {\n      var typeaheadOptions = this.options.typeahead,\n          defaults = {\n        minLength: this.options.showAutocompleteOnFocus ? 0 : null\n      },\n          args = $.isArray(typeaheadOptions) ? typeaheadOptions : [typeaheadOptions, typeaheadOptions];\n      args[0] = $.extend({}, defaults, args[0]);\n      this.$input.typeahead.apply(this.$input, args);\n      this.typeahead = true;\n    }\n\n    this.$element.trigger('tokenfield:initialize');\n  };\n\n  Tokenfield.prototype = {\n    constructor: Tokenfield,\n    createToken: function (attrs, triggerChange) {\n      var _self = this;\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          value: attrs,\n          label: attrs\n        };\n      }\n\n      if (typeof triggerChange === 'undefined') {\n        triggerChange = true;\n      } // Normalize label and value\n\n\n      attrs.value = $.trim(attrs.value);\n      attrs.label = attrs.label && attrs.label.length ? $.trim(attrs.label) : attrs.value; // Bail out if has no value or label, or label is too short\n\n      if (!attrs.value.length || !attrs.label.length || attrs.label.length <= this.options.minLength) return; // Bail out if maximum number of tokens is reached\n\n      if (this.options.limit && this.getTokens().length >= this.options.limit) return; // Allow changing token data before creating it\n\n      var createEvent = $.Event('tokenfield:createtoken', {\n        attrs: attrs\n      });\n      this.$element.trigger(createEvent); // Bail out if there if attributes are empty or event was defaultPrevented\n\n      if (!createEvent.attrs || createEvent.isDefaultPrevented()) return;\n      var $token = $('<div class=\"token\" />').attr('data-value', attrs.value).append('<span class=\"token-label\" />').append('<a href=\"#\" class=\"close\" tabindex=\"-1\">&times;</a>'); // Insert token into HTML\n\n      if (this.$input.hasClass('tt-input')) {\n        // If the input has typeahead enabled, insert token before it's parent\n        this.$input.parent().before($token);\n      } else {\n        this.$input.before($token);\n      } // Temporarily set input width to minimum\n\n\n      this.$input.css('width', this.options.minWidth + 'px');\n      var $tokenLabel = $token.find('.token-label'),\n          $closeButton = $token.find('.close'); // Determine maximum possible token label width\n\n      if (!this.maxTokenWidth) {\n        this.maxTokenWidth = this.$wrapper.width() - $closeButton.outerWidth() - parseInt($closeButton.css('margin-left'), 10) - parseInt($closeButton.css('margin-right'), 10) - parseInt($token.css('border-left-width'), 10) - parseInt($token.css('border-right-width'), 10) - parseInt($token.css('padding-left'), 10) - parseInt($token.css('padding-right'), 10);\n        parseInt($tokenLabel.css('border-left-width'), 10) - parseInt($tokenLabel.css('border-right-width'), 10) - parseInt($tokenLabel.css('padding-left'), 10) - parseInt($tokenLabel.css('padding-right'), 10);\n        parseInt($tokenLabel.css('margin-left'), 10) - parseInt($tokenLabel.css('margin-right'), 10);\n      }\n\n      $tokenLabel.text(attrs.label).css('max-width', this.maxTokenWidth); // Listen to events on token\n\n      $token.on('mousedown', function (e) {\n        if (_self._disabled || _self._readonly) return false;\n        _self.preventDeactivation = true;\n      }).on('click', function (e) {\n        if (_self._disabled || _self._readonly) return false;\n        _self.preventDeactivation = false;\n\n        if (e.ctrlKey || e.metaKey) {\n          e.preventDefault();\n          return _self.toggle($token);\n        }\n\n        _self.activate($token, e.shiftKey, e.shiftKey);\n      }).on('dblclick', function (e) {\n        if (_self._disabled || _self._readonly || !_self.options.allowEditing) return false;\n\n        _self.edit($token);\n      });\n      $closeButton.on('click', $.proxy(this.remove, this)); // Trigger createdtoken event on the original field\n      // indicating that the token is now in the DOM\n\n      this.$element.trigger($.Event('tokenfield:createdtoken', {\n        attrs: attrs,\n        relatedTarget: $token.get(0)\n      })); // Trigger change event on the original field\n\n      if (triggerChange) {\n        this.$element.val(this.getTokensList()).trigger($.Event('change', {\n          initiator: 'tokenfield'\n        }));\n      } // Update tokenfield dimensions\n\n\n      this.update(); // Return original element\n\n      return this.$element.get(0);\n    },\n    setTokens: function (tokens, add, triggerChange) {\n      if (!tokens) return;\n      if (!add) this.$wrapper.find('.token').remove();\n\n      if (typeof triggerChange === 'undefined') {\n        triggerChange = true;\n      }\n\n      if (typeof tokens === 'string') {\n        if (this._delimiters.length) {\n          // Split based on delimiters\n          tokens = tokens.split(new RegExp('[' + this._delimiters.join('') + ']'));\n        } else {\n          tokens = [tokens];\n        }\n      }\n\n      var _self = this;\n\n      $.each(tokens, function (i, attrs) {\n        _self.createToken(attrs, triggerChange);\n      });\n      return this.$element.get(0);\n    },\n    getTokenData: function ($token) {\n      var data = $token.map(function () {\n        var $token = $(this);\n        return {\n          value: $token.attr('data-value'),\n          label: $token.find('.token-label').text()\n        };\n      }).get();\n\n      if (data.length == 1) {\n        data = data[0];\n      }\n\n      return data;\n    },\n    getTokens: function (active) {\n      var self = this,\n          tokens = [],\n          activeClass = active ? '.active' : ''; // get active tokens only\n\n      this.$wrapper.find('.token' + activeClass).each(function () {\n        tokens.push(self.getTokenData($(this)));\n      });\n      return tokens;\n    },\n    getTokensList: function (delimiter, beautify, active) {\n      delimiter = delimiter || this._firstDelimiter;\n      beautify = typeof beautify !== 'undefined' && beautify !== null ? beautify : this.options.beautify;\n      var separator = delimiter + (beautify && delimiter !== ' ' ? ' ' : '');\n      return $.map(this.getTokens(active), function (token) {\n        return token.value;\n      }).join(separator);\n    },\n    getInput: function () {\n      return this.$input.val();\n    },\n    listen: function () {\n      var _self = this;\n\n      this.$element.on('change', $.proxy(this.change, this));\n      this.$wrapper.on('mousedown', $.proxy(this.focusInput, this));\n      this.$input.on('focus', $.proxy(this.focus, this)).on('blur', $.proxy(this.blur, this)).on('paste', $.proxy(this.paste, this)).on('keydown', $.proxy(this.keydown, this)).on('keypress', $.proxy(this.keypress, this)).on('keyup', $.proxy(this.keyup, this));\n      this.$copyHelper.on('focus', $.proxy(this.focus, this)).on('blur', $.proxy(this.blur, this)).on('keydown', $.proxy(this.keydown, this)).on('keyup', $.proxy(this.keyup, this)); // Secondary listeners for input width calculation\n\n      this.$input.on('keypress', $.proxy(this.update, this)).on('keyup', $.proxy(this.update, this));\n      this.$input.on('autocompletecreate', function () {\n        // Set minimum autocomplete menu width\n        var $_menuElement = $(this).data('ui-autocomplete').menu.element;\n        var minWidth = _self.$wrapper.outerWidth() - parseInt($_menuElement.css('border-left-width'), 10) - parseInt($_menuElement.css('border-right-width'), 10);\n        $_menuElement.css('min-width', minWidth + 'px');\n      }).on('autocompleteselect', function (e, ui) {\n        if (_self.createToken(ui.item)) {\n          _self.$input.val('');\n\n          if (_self.$input.data('edit')) {\n            _self.unedit(true);\n          }\n        }\n\n        return false;\n      }).on('typeahead:selected typeahead:autocompleted', function (e, datum, dataset) {\n        // Create token\n        if (_self.createToken(datum)) {\n          _self.$input.typeahead('val', '');\n\n          if (_self.$input.data('edit')) {\n            _self.unedit(true);\n          }\n        }\n      }); // Listen to window resize\n\n      $(window).on('resize', $.proxy(this.update, this));\n    },\n    keydown: function (e) {\n      if (!this.focused) return;\n\n      var _self = this;\n\n      switch (e.keyCode) {\n        case 8:\n          // backspace\n          if (!this.$input.is(document.activeElement)) break;\n          this.lastInputValue = this.$input.val();\n          break;\n\n        case 37:\n          // left arrow\n          leftRight(this.textDirection === 'rtl' ? 'next' : 'prev');\n          break;\n\n        case 38:\n          // up arrow\n          upDown('prev');\n          break;\n\n        case 39:\n          // right arrow\n          leftRight(this.textDirection === 'rtl' ? 'prev' : 'next');\n          break;\n\n        case 40:\n          // down arrow\n          upDown('next');\n          break;\n\n        case 65:\n          // a (to handle ctrl + a)\n          if (this.$input.val().length > 0 || !(e.ctrlKey || e.metaKey)) break;\n          this.activateAll();\n          e.preventDefault();\n          break;\n\n        case 9: // tab\n\n        case 13:\n          // enter     \n          // We will handle creating tokens from autocomplete in autocomplete events\n          if (this.$input.data('ui-autocomplete') && this.$input.data('ui-autocomplete').menu.element.find(\"li:has(a.ui-state-focus)\").length) break; // We will handle creating tokens from typeahead in typeahead events\n\n          if (this.$input.hasClass('tt-input') && this.$wrapper.find('.tt-cursor').length) break;\n          if (this.$input.hasClass('tt-input') && this.$wrapper.find('.tt-hint').val().length) break; // Create token\n\n          if (this.$input.is(document.activeElement) && this.$input.val().length || this.$input.data('edit')) {\n            return this.createTokensFromInput(e, this.$input.data('edit'));\n          } // Edit token\n\n\n          if (e.keyCode === 13) {\n            if (!this.$copyHelper.is(document.activeElement) || this.$wrapper.find('.token.active').length !== 1) break;\n            if (!_self.options.allowEditing) break;\n            this.edit(this.$wrapper.find('.token.active'));\n          }\n\n      }\n\n      function leftRight(direction) {\n        if (_self.$input.is(document.activeElement)) {\n          if (_self.$input.val().length > 0) return;\n          direction += 'All';\n          var $token = _self.$input.hasClass('tt-input') ? _self.$input.parent()[direction]('.token:first') : _self.$input[direction]('.token:first');\n          if (!$token.length) return;\n          _self.preventInputFocus = true;\n          _self.preventDeactivation = true;\n\n          _self.activate($token);\n\n          e.preventDefault();\n        } else {\n          _self[direction](e.shiftKey);\n\n          e.preventDefault();\n        }\n      }\n\n      function upDown(direction) {\n        if (!e.shiftKey) return;\n\n        if (_self.$input.is(document.activeElement)) {\n          if (_self.$input.val().length > 0) return;\n          var $token = _self.$input.hasClass('tt-input') ? _self.$input.parent()[direction + 'All']('.token:first') : _self.$input[direction + 'All']('.token:first');\n          if (!$token.length) return;\n\n          _self.activate($token);\n        }\n\n        var opposite = direction === 'prev' ? 'next' : 'prev',\n            position = direction === 'prev' ? 'first' : 'last';\n\n        _self.firstActiveToken[opposite + 'All']('.token').each(function () {\n          _self.deactivate($(this));\n        });\n\n        _self.activate(_self.$wrapper.find('.token:' + position), true, true);\n\n        e.preventDefault();\n      }\n\n      this.lastKeyDown = e.keyCode;\n    },\n    keypress: function (e) {\n      this.lastKeyPressCode = e.keyCode;\n      this.lastKeyPressCharCode = e.charCode; // Comma\n\n      if ($.inArray(e.charCode, this._triggerKeys) !== -1 && this.$input.is(document.activeElement)) {\n        if (this.$input.val()) {\n          this.createTokensFromInput(e);\n        }\n\n        return false;\n      }\n    },\n    keyup: function (e) {\n      this.preventInputFocus = false;\n      if (!this.focused) return;\n\n      switch (e.keyCode) {\n        case 8:\n          // backspace\n          if (this.$input.is(document.activeElement)) {\n            if (this.$input.val().length || this.lastInputValue.length && this.lastKeyDown === 8) break;\n            this.preventDeactivation = true;\n            var $prevToken = this.$input.hasClass('tt-input') ? this.$input.parent().prevAll('.token:first') : this.$input.prevAll('.token:first');\n            if (!$prevToken.length) break;\n            this.activate($prevToken);\n          } else {\n            this.remove(e);\n          }\n\n          break;\n\n        case 46:\n          // delete\n          this.remove(e, 'next');\n          break;\n      }\n\n      this.lastKeyUp = e.keyCode;\n    },\n    focus: function (e) {\n      this.focused = true;\n      this.$wrapper.addClass('focus');\n\n      if (this.$input.is(document.activeElement)) {\n        this.$wrapper.find('.active').removeClass('active');\n        this.$firstActiveToken = null;\n\n        if (this.options.showAutocompleteOnFocus) {\n          this.search();\n        }\n      }\n    },\n    blur: function (e) {\n      this.focused = false;\n      this.$wrapper.removeClass('focus');\n\n      if (!this.preventDeactivation && !this.$element.is(document.activeElement)) {\n        this.$wrapper.find('.active').removeClass('active');\n        this.$firstActiveToken = null;\n      }\n\n      if (!this.preventCreateTokens && (this.$input.data('edit') && !this.$input.is(document.activeElement) || this.options.createTokensOnBlur)) {\n        this.createTokensFromInput(e);\n      }\n\n      this.preventDeactivation = false;\n      this.preventCreateTokens = false;\n    },\n    paste: function (e) {\n      var _self = this; // Add tokens to existing ones\n\n\n      setTimeout(function () {\n        _self.createTokensFromInput(e);\n      }, 1);\n    },\n    change: function (e) {\n      if (e.initiator === 'tokenfield') return; // Prevent loops\n\n      this.setTokens(this.$element.val());\n    },\n    createTokensFromInput: function (e, focus) {\n      if (this.$input.val().length < this.options.minLength) return; // No input, simply return\n\n      var tokensBefore = this.getTokensList();\n      this.setTokens(this.$input.val(), true);\n      if (tokensBefore == this.getTokensList() && this.$input.val().length) return false; // No tokens were added, do nothing (prevent form submit)\n\n      if (this.$input.hasClass('tt-input')) {\n        // Typeahead acts weird when simply setting input value to empty,\n        // so we set the query to empty instead\n        this.$input.typeahead('val', '');\n      } else {\n        this.$input.val('');\n      }\n\n      if (this.$input.data('edit')) {\n        this.unedit(focus);\n      }\n\n      return false; // Prevent form being submitted\n    },\n    next: function (add) {\n      if (add) {\n        var $firstActiveToken = this.$wrapper.find('.active:first'),\n            deactivate = $firstActiveToken && this.$firstActiveToken ? $firstActiveToken.index() < this.$firstActiveToken.index() : false;\n        if (deactivate) return this.deactivate($firstActiveToken);\n      }\n\n      var $lastActiveToken = this.$wrapper.find('.active:last'),\n          $nextToken = $lastActiveToken.nextAll('.token:first');\n\n      if (!$nextToken.length) {\n        this.$input.focus();\n        return;\n      }\n\n      this.activate($nextToken, add);\n    },\n    prev: function (add) {\n      if (add) {\n        var $lastActiveToken = this.$wrapper.find('.active:last'),\n            deactivate = $lastActiveToken && this.$firstActiveToken ? $lastActiveToken.index() > this.$firstActiveToken.index() : false;\n        if (deactivate) return this.deactivate($lastActiveToken);\n      }\n\n      var $firstActiveToken = this.$wrapper.find('.active:first'),\n          $prevToken = $firstActiveToken.prevAll('.token:first');\n\n      if (!$prevToken.length) {\n        $prevToken = this.$wrapper.find('.token:first');\n      }\n\n      if (!$prevToken.length && !add) {\n        this.$input.focus();\n        return;\n      }\n\n      this.activate($prevToken, add);\n    },\n    activate: function ($token, add, multi, remember) {\n      if (!$token) return;\n      if (typeof remember === 'undefined') var remember = true;\n      if (multi) var add = true;\n      this.$copyHelper.focus();\n\n      if (!add) {\n        this.$wrapper.find('.active').removeClass('active');\n\n        if (remember) {\n          this.$firstActiveToken = $token;\n        } else {\n          delete this.$firstActiveToken;\n        }\n      }\n\n      if (multi && this.$firstActiveToken) {\n        // Determine first active token and the current tokens indicies\n        // Account for the 1 hidden textarea by subtracting 1 from both\n        var i = this.$firstActiveToken.index() - 2,\n            a = $token.index() - 2,\n            _self = this;\n\n        this.$wrapper.find('.token').slice(Math.min(i, a) + 1, Math.max(i, a)).each(function () {\n          _self.activate($(this), true);\n        });\n      }\n\n      $token.addClass('active');\n      this.$copyHelper.val(this.getTokensList(null, null, true)).select();\n    },\n    activateAll: function () {\n      var _self = this;\n\n      this.$wrapper.find('.token').each(function (i) {\n        _self.activate($(this), i !== 0, false, false);\n      });\n    },\n    deactivate: function ($token) {\n      if (!$token) return;\n      $token.removeClass('active');\n      this.$copyHelper.val(this.getTokensList(null, null, true)).select();\n    },\n    toggle: function ($token) {\n      if (!$token) return;\n      $token.toggleClass('active');\n      this.$copyHelper.val(this.getTokensList(null, null, true)).select();\n    },\n    edit: function ($token) {\n      if (!$token) return;\n      var attrs = {\n        value: $token.data('value'),\n        label: $token.find('.token-label').text()\n      }; // Allow changing input value before editing\n\n      var options = {\n        attrs: attrs,\n        relatedTarget: $token.get(0)\n      };\n      var editEvent = $.Event('tokenfield:edittoken', options);\n      this.$element.trigger(editEvent); // Edit event can be cancelled if default is prevented\n\n      if (editEvent.isDefaultPrevented()) return;\n      $token.find('.token-label').text(attrs.value);\n      var tokenWidth = $token.outerWidth();\n      var $_input = this.$input.hasClass('tt-input') ? this.$input.parent() : this.$input;\n      $token.replaceWith($_input);\n      this.preventCreateTokens = true;\n      this.$input.val(attrs.value).select().data('edit', true).width(tokenWidth);\n      this.update(); // Indicate that token in snow being edited, and is replaced with an input field in the DOM\n\n      this.$element.trigger($.Event('tokenfield:editedtoken', options));\n    },\n    unedit: function (focus) {\n      var $_input = this.$input.hasClass('tt-input') ? this.$input.parent() : this.$input;\n      $_input.appendTo(this.$wrapper);\n      this.$input.data('edit', false);\n      this.$mirror.text('');\n      this.update(); // Because moving the input element around in DOM \n      // will cause it to lose focus, we provide an option\n      // to re-focus the input after appending it to the wrapper\n\n      if (focus) {\n        var _self = this;\n\n        setTimeout(function () {\n          _self.$input.focus();\n        }, 1);\n      }\n    },\n    remove: function (e, direction) {\n      if (this.$input.is(document.activeElement) || this._disabled || this._readonly) return;\n      var $token = e.type === 'click' ? $(e.target).closest('.token') : this.$wrapper.find('.token.active');\n\n      if (e.type !== 'click') {\n        if (!direction) var direction = 'prev';\n        this[direction](); // Was it the first token?\n\n        if (direction === 'prev') var firstToken = $token.first().prevAll('.token:first').length === 0;\n      } // Prepare events and their options\n\n\n      var options = {\n        attrs: this.getTokenData($token),\n        relatedTarget: $token.get(0)\n      },\n          removeEvent = $.Event('tokenfield:removetoken', options);\n      this.$element.trigger(removeEvent); // Remove event can be intercepted and cancelled\n\n      if (removeEvent.isDefaultPrevented()) return;\n      var removedEvent = $.Event('tokenfield:removedtoken', options),\n          changeEvent = $.Event('change', {\n        initiator: 'tokenfield'\n      }); // Remove token from DOM\n\n      $token.remove(); // Trigger events\n\n      this.$element.val(this.getTokensList()).trigger(removedEvent).trigger(changeEvent); // Focus, when necessary:\n      // When there are no more tokens, or if this was the first token\n      // and it was removed with backspace or it was clicked on\n\n      if (!this.$wrapper.find('.token').length || e.type === 'click' || firstToken) this.$input.focus(); // Adjust input width\n\n      this.$input.css('width', this.options.minWidth + 'px');\n      this.update(); // Cancel original event handlers\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    /**\n     * Update tokenfield dimensions\n     */\n    ,\n    update: function (e) {\n      var value = this.$input.val(),\n          inputPaddingLeft = parseInt(this.$input.css('padding-left'), 10),\n          inputPaddingRight = parseInt(this.$input.css('padding-right'), 10),\n          inputPadding = inputPaddingLeft + inputPaddingRight;\n\n      if (this.$input.data('edit')) {\n        if (!value) {\n          value = this.$input.prop(\"placeholder\");\n        }\n\n        if (value === this.$mirror.text()) return;\n        this.$mirror.text(value);\n        var mirrorWidth = this.$mirror.width() + 10;\n\n        if (mirrorWidth > this.$wrapper.width()) {\n          return this.$input.width(this.$wrapper.width());\n        }\n\n        this.$input.width(mirrorWidth);\n      } else {\n        this.$input.css('width', this.options.minWidth + 'px');\n\n        if (this.textDirection === 'rtl') {\n          return this.$input.width(this.$input.offset().left + this.$input.outerWidth() - this.$wrapper.offset().left - parseInt(this.$wrapper.css('padding-left'), 10) - inputPadding - 1);\n        }\n\n        this.$input.width(this.$wrapper.offset().left + this.$wrapper.width() + parseInt(this.$wrapper.css('padding-left'), 10) - this.$input.offset().left - inputPadding);\n      }\n    },\n    focusInput: function (e) {\n      if ($(e.target).closest('.token').length || $(e.target).closest('.token-input').length || $(e.target).closest('.tt-dropdown-menu').length) return; // Focus only after the current call stack has cleared,\n      // otherwise has no effect.\n      // Reason: mousedown is too early - input will lose focus\n      // after mousedown. However, since the input may be moved\n      // in DOM, there may be no click or mouseup event triggered.\n\n      var _self = this;\n\n      setTimeout(function () {\n        _self.$input.focus();\n      }, 0);\n    },\n    search: function () {\n      if (this.$input.data('ui-autocomplete')) {\n        this.$input.autocomplete('search');\n      }\n    },\n    disable: function () {\n      this.setProperty('disabled', true);\n    },\n    enable: function () {\n      this.setProperty('disabled', false);\n    },\n    readonly: function () {\n      this.setProperty('readonly', true);\n    },\n    writeable: function () {\n      this.setProperty('readonly', false);\n    },\n    setProperty: function (property, value) {\n      this['_' + property] = value;\n      this.$input.prop(property, value);\n      this.$element.prop(property, value);\n      this.$wrapper[value ? 'addClass' : 'removeClass'](property);\n    },\n    destroy: function () {\n      // Set field value\n      this.$element.val(this.getTokensList()); // Restore styles and properties\n\n      this.$element.css(this.$element.data('original-styles'));\n      this.$element.prop('tabindex', this.$element.data('original-tabindex')); // Re-route tokenfield labele to original input\n\n      var $label = $('label[for=\"' + this.$input.prop('id') + '\"]');\n\n      if ($label.length) {\n        $label.prop('for', this.$element.prop('id'));\n      } // Move original element outside of tokenfield wrapper\n\n\n      this.$element.insertBefore(this.$wrapper); // Remove tokenfield-related data\n\n      this.$element.removeData('original-styles').removeData('original-tabindex').removeData('bs.tokenfield'); // Remove tokenfield from DOM\n\n      this.$wrapper.remove();\n      var $_element = this.$element;\n      delete this;\n      return $_element;\n    }\n  };\n  /* TOKENFIELD PLUGIN DEFINITION\n   * ======================== */\n\n  var old = $.fn.tokenfield;\n\n  $.fn.tokenfield = function (option, param) {\n    var value,\n        args = [];\n    Array.prototype.push.apply(args, arguments);\n    var elements = this.each(function () {\n      var $this = $(this),\n          data = $this.data('bs.tokenfield'),\n          options = typeof option == 'object' && option;\n\n      if (typeof option === 'string' && data && data[option]) {\n        args.shift();\n        value = data[option].apply(data, args);\n      } else {\n        if (!data && typeof option !== 'string' && !param) $this.data('bs.tokenfield', data = new Tokenfield(this, options));\n      }\n    });\n    return typeof value !== 'undefined' ? value : elements;\n  };\n\n  $.fn.tokenfield.defaults = {\n    minWidth: 60,\n    minLength: 0,\n    allowEditing: true,\n    limit: 0,\n    autocomplete: {},\n    typeahead: {},\n    showAutocompleteOnFocus: false,\n    createTokensOnBlur: false,\n    delimiter: ',',\n    beautify: true\n  };\n  $.fn.tokenfield.Constructor = Tokenfield;\n  /* TOKENFIELD NO CONFLICT\n   * ================== */\n\n  $.fn.tokenfield.noConflict = function () {\n    $.fn.tokenfield = old;\n    return this;\n  };\n\n  return Tokenfield;\n});\n\n//# sourceURL=webpack:///./node_modules/bootstrap-tokenfield/dist/bootstrap-tokenfield.js?");

/***/ })

}]);