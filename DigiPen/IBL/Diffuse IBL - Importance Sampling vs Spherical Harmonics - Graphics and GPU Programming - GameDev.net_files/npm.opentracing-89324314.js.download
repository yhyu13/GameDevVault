(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.opentracing"],{

/***/ "CFsD":
/*!***************************************************!*\
  !*** ./node_modules/opentracing/lib/functions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Constants = __webpack_require__(/*! ./constants */ \"wAB+\");\n\nvar reference_1 = __webpack_require__(/*! ./reference */ \"ZjTw\");\n\nvar span_1 = __webpack_require__(/*! ./span */ \"ndN9\");\n/**\n * Return a new REFERENCE_CHILD_OF reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n */\n\n\nfunction childOf(spanContext) {\n  // Allow the user to pass a Span instead of a SpanContext\n  if (spanContext instanceof span_1.default) {\n    spanContext = spanContext.context();\n  }\n\n  return new reference_1.default(Constants.REFERENCE_CHILD_OF, spanContext);\n}\n\nexports.childOf = childOf;\n/**\n * Return a new REFERENCE_FOLLOWS_FROM reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n */\n\nfunction followsFrom(spanContext) {\n  // Allow the user to pass a Span instead of a SpanContext\n  if (spanContext instanceof span_1.default) {\n    spanContext = spanContext.context();\n  }\n\n  return new reference_1.default(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n}\n\nexports.followsFrom = followsFrom;\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/functions.js?");

/***/ }),

/***/ "Dsv1":
/*!************************************************!*\
  !*** ./node_modules/opentracing/lib/tracer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Functions = __webpack_require__(/*! ./functions */ \"CFsD\");\n\nvar Noop = __webpack_require__(/*! ./noop */ \"OgHD\");\n\nvar span_1 = __webpack_require__(/*! ./span */ \"ndN9\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\n\n\nvar Tracer =\n/** @class */\nfunction () {\n  function Tracer() {} // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * For example:\n   *\n   *     // Start a new (parentless) root Span:\n   *     var parent = Tracer.startSpan('DoWork');\n   *\n   *     // Start a new (child) Span:\n   *     var child = Tracer.startSpan('load-from-db', {\n   *         childOf: parent.context(),\n   *     });\n   *\n   *     // Start a new async (FollowsFrom) Span:\n   *     var child = Tracer.startSpan('async-cache-write', {\n   *         references: [\n   *             opentracing.followsFrom(parent.context())\n   *         ],\n   *     });\n   *\n   * @param {string} name - the name of the operation (REQUIRED).\n   * @param {SpanOptions} [options] - options for the newly created span.\n   * @return {Span} - a new Span object.\n   */\n\n\n  Tracer.prototype.startSpan = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    } // Convert options.childOf to fields.references as needed.\n\n\n    if (options.childOf) {\n      // Convert from a Span or a SpanContext into a Reference.\n      var childOf = Functions.childOf(options.childOf);\n\n      if (options.references) {\n        options.references.push(childOf);\n      } else {\n        options.references = [childOf];\n      }\n\n      delete options.childOf;\n    }\n\n    return this._startSpan(name, options);\n  };\n  /**\n   * Injects the given SpanContext instance for cross-process propagation\n   * within `carrier`. The expected type of `carrier` depends on the value of\n   * `format.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     var clientSpan = ...;\n   *     ...\n   *     // Inject clientSpan into a text carrier.\n   *     var headersCarrier = {};\n   *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     // Incorporate the textCarrier into the outbound HTTP request header\n   *     // map.\n   *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n   *     // ... send the httpReq\n   *\n   * @param  {SpanContext} spanContext - the SpanContext to inject into the\n   *         carrier object. As a convenience, a Span instance may be passed\n   *         in instead (in which case its .context() is used for the\n   *         inject()).\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - see the documentation for the chosen `format`\n   *         for a description of the carrier object.\n   */\n\n\n  Tracer.prototype.inject = function (spanContext, format, carrier) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof span_1.default) {\n      spanContext = spanContext.context();\n    }\n\n    return this._inject(spanContext, format, carrier);\n  };\n  /**\n   * Returns a SpanContext instance extracted from `carrier` in the given\n   * `format`.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     // Use the inbound HTTP request's headers as a text map carrier.\n   *     var headersCarrier = inboundHTTPReq.headers;\n   *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n   *\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - the type of the carrier object is determined by\n   *         the format.\n   * @return {SpanContext}\n   *         The extracted SpanContext, or null if no such SpanContext could\n   *         be found in `carrier`\n   */\n\n\n  Tracer.prototype.extract = function (format, carrier) {\n    return this._extract(format, carrier);\n  }; // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // NOTE: the input to this method is *always* an associative array. The\n  // public-facing startSpan() method normalizes the arguments so that\n  // all N implementations do not need to worry about variations in the call\n  // signature.\n  //\n  // The default behavior returns a no-op span.\n\n\n  Tracer.prototype._startSpan = function (name, fields) {\n    return Noop.span;\n  }; // The default behavior is a no-op.\n\n\n  Tracer.prototype._inject = function (spanContext, format, carrier) {}; // The default behavior is to return a no-op SpanContext.\n\n\n  Tracer.prototype._extract = function (format, carrier) {\n    return Noop.spanContext;\n  };\n\n  return Tracer;\n}();\n\nexports.Tracer = Tracer;\nexports.default = Tracer;\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/tracer.js?");

/***/ }),

/***/ "OgHD":
/*!**********************************************!*\
  !*** ./node_modules/opentracing/lib/noop.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar span_1 = __webpack_require__(/*! ./span */ \"ndN9\");\n\nvar span_context_1 = __webpack_require__(/*! ./span_context */ \"XZyw\");\n\nvar tracer_1 = __webpack_require__(/*! ./tracer */ \"Dsv1\");\n\nexports.tracer = null;\nexports.spanContext = null;\nexports.span = null; // Deferred initialization to avoid a dependency cycle where Tracer depends on\n// Span which depends on the noop tracer.\n\nfunction initialize() {\n  exports.tracer = new tracer_1.default();\n  exports.span = new span_1.default();\n  exports.spanContext = new span_context_1.default();\n}\n\nexports.initialize = initialize;\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/noop.js?");

/***/ }),

/***/ "XZyw":
/*!******************************************************!*\
  !*** ./node_modules/opentracing/lib/span_context.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * SpanContext represents Span state that must propagate to descendant Spans\n * and across process boundaries.\n *\n * SpanContext is logically divided into two pieces: the user-level \"Baggage\"\n * (see setBaggageItem and getBaggageItem) that propagates across Span\n * boundaries and any Tracer-implementation-specific fields that are needed to\n * identify or otherwise contextualize the associated Span instance (e.g., a\n * <trace_id, span_id, sampled> tuple).\n */\n\nvar SpanContext =\n/** @class */\nfunction () {\n  function SpanContext() {} // The SpanContext is entirely implementation dependent\n\n  /**\n   * Returns a string representation of the implementation internal trace ID.\n   *\n   * @returns {string}\n   */\n\n\n  SpanContext.prototype.toTraceId = function () {\n    return '';\n  };\n  /**\n   * Returns a string representation of the implementation internal span ID.\n   *\n   * @returns {string}\n   */\n\n\n  SpanContext.prototype.toSpanId = function () {\n    return '';\n  };\n\n  return SpanContext;\n}();\n\nexports.SpanContext = SpanContext;\nexports.default = SpanContext;\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/span_context.js?");

/***/ }),

/***/ "ZjTw":
/*!***************************************************!*\
  !*** ./node_modules/opentracing/lib/reference.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar span_1 = __webpack_require__(/*! ./span */ \"ndN9\");\n/**\n * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or\n * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.\n *\n * See the exported childOf() and followsFrom() functions at the package level.\n */\n\n\nvar Reference =\n/** @class */\nfunction () {\n  /**\n   * Initialize a new Reference instance.\n   *\n   * @param {string} type - the Reference type constant (e.g.,\n   *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).\n   * @param {SpanContext} referencedContext - the SpanContext being referred\n   *        to. As a convenience, a Span instance may be passed in instead\n   *        (in which case its .context() is used here).\n   */\n  function Reference(type, referencedContext) {\n    this._type = type;\n    this._referencedContext = referencedContext instanceof span_1.default ? referencedContext.context() : referencedContext;\n  }\n  /**\n   * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or\n   *         REFERENCE_FOLLOWS_FROM).\n   */\n\n\n  Reference.prototype.type = function () {\n    return this._type;\n  };\n  /**\n   * @return {SpanContext} The SpanContext being referred to (e.g., the\n   *         parent in a REFERENCE_CHILD_OF Reference).\n   */\n\n\n  Reference.prototype.referencedContext = function () {\n    return this._referencedContext;\n  };\n\n  return Reference;\n}();\n\nexports.default = Reference;\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/reference.js?");

/***/ }),

/***/ "ndN9":
/*!**********************************************!*\
  !*** ./node_modules/opentracing/lib/span.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar noop = __webpack_require__(/*! ./noop */ \"OgHD\");\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\n\n\nvar Span =\n/** @class */\nfunction () {\n  function Span() {} // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n\n  /**\n   * Returns the SpanContext object associated with this Span.\n   *\n   * @return {SpanContext}\n   */\n\n\n  Span.prototype.context = function () {\n    return this._context();\n  };\n  /**\n   * Returns the Tracer object used to create this Span.\n   *\n   * @return {Tracer}\n   */\n\n\n  Span.prototype.tracer = function () {\n    return this._tracer();\n  };\n  /**\n   * Sets the string name for the logical operation this span represents.\n   *\n   * @param {string} name\n   */\n\n\n  Span.prototype.setOperationName = function (name) {\n    this._setOperationName(name);\n\n    return this;\n  };\n  /**\n   * Sets a key:value pair on this Span that also propagates to future\n   * children of the associated Span.\n   *\n   * setBaggageItem() enables powerful functionality given a full-stack\n   * opentracing integration (e.g., arbitrary application data from a web\n   * client can make it, transparently, all the way into the depths of a\n   * storage system), and with it some powerful costs: use this feature with\n   * care.\n   *\n   * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n   * *future* causal descendants of the associated Span.\n   *\n   * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n   * value is copied into every local *and remote* child of the associated\n   * Span, and that can add up to a lot of network and cpu overhead.\n   *\n   * @param {string} key\n   * @param {string} value\n   */\n\n\n  Span.prototype.setBaggageItem = function (key, value) {\n    this._setBaggageItem(key, value);\n\n    return this;\n  };\n  /**\n   * Returns the value for a baggage item given its key.\n   *\n   * @param  {string} key\n   *         The key for the given trace attribute.\n   * @return {string}\n   *         String value for the given key, or undefined if the key does not\n   *         correspond to a set trace attribute.\n   */\n\n\n  Span.prototype.getBaggageItem = function (key) {\n    return this._getBaggageItem(key);\n  };\n  /**\n   * Adds a single tag to the span.  See `addTags()` for details.\n   *\n   * @param {string} key\n   * @param {any} value\n   */\n\n\n  Span.prototype.setTag = function (key, value) {\n    var _a; // NOTE: the call is normalized to a call to _addTags()\n\n\n    this._addTags((_a = {}, _a[key] = value, _a));\n\n    return this;\n  };\n  /**\n   * Adds the given key value pairs to the set of span tags.\n   *\n   * Multiple calls to addTags() results in the tags being the superset of\n   * all calls.\n   *\n   * The behavior of setting the same key multiple times on the same span\n   * is undefined.\n   *\n   * The supported type of the values is implementation-dependent.\n   * Implementations are expected to safely handle all types of values but\n   * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n   * with cyclic references, function objects).\n   *\n   * @return {[type]} [description]\n   */\n\n\n  Span.prototype.addTags = function (keyValueMap) {\n    this._addTags(keyValueMap);\n\n    return this;\n  };\n  /**\n   * Add a log record to this Span, optionally at a user-provided timestamp.\n   *\n   * For example:\n   *\n   *     span.log({\n   *         size: rpc.size(),  // numeric value\n   *         URI: rpc.URI(),  // string value\n   *         payload: rpc.payload(),  // Object value\n   *         \"keys can be arbitrary strings\": rpc.foo(),\n   *     });\n   *\n   *     span.log({\n   *         \"error.description\": someError.description(),\n   *     }, someError.timestampMillis());\n   *\n   * @param {object} keyValuePairs\n   *        An object mapping string keys to arbitrary value types. All\n   *        Tracer implementations should support bool, string, and numeric\n   *        value types, and some may also support Object values.\n   * @param {number} timestamp\n   *        An optional parameter specifying the timestamp in milliseconds\n   *        since the Unix epoch. Fractional values are allowed so that\n   *        timestamps with sub-millisecond accuracy can be represented. If\n   *        not specified, the implementation is expected to use its notion\n   *        of the current time of the call.\n   */\n\n\n  Span.prototype.log = function (keyValuePairs, timestamp) {\n    this._log(keyValuePairs, timestamp);\n\n    return this;\n  };\n  /**\n   * DEPRECATED\n   */\n\n\n  Span.prototype.logEvent = function (eventName, payload) {\n    return this._log({\n      event: eventName,\n      payload: payload\n    });\n  };\n  /**\n   * Sets the end timestamp and finalizes Span state.\n   *\n   * With the exception of calls to Span.context() (which are always allowed),\n   * finish() must be the last call made to any span instance, and to do\n   * otherwise leads to undefined behavior.\n   *\n   * @param  {number} finishTime\n   *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n   *         values are supported for timestamps with sub-millisecond accuracy.\n   *         If not specified, the current time (as defined by the\n   *         implementation) will be used.\n   */\n\n\n  Span.prototype.finish = function (finishTime) {\n    this._finish(finishTime); // Do not return `this`. The Span generally should not be used after it\n    // is finished so chaining is not desired in this context.\n\n  }; // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // By default returns a no-op SpanContext.\n\n\n  Span.prototype._context = function () {\n    return noop.spanContext;\n  }; // By default returns a no-op tracer.\n  //\n  // The base class could store the tracer that created it, but it does not\n  // in order to ensure the no-op span implementation has zero members,\n  // which allows V8 to aggressively optimize calls to such objects.\n\n\n  Span.prototype._tracer = function () {\n    return noop.tracer;\n  }; // By default does nothing\n\n\n  Span.prototype._setOperationName = function (name) {}; // By default does nothing\n\n\n  Span.prototype._setBaggageItem = function (key, value) {}; // By default does nothing\n\n\n  Span.prototype._getBaggageItem = function (key) {\n    return undefined;\n  }; // By default does nothing\n  //\n  // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n  // will always be an associative array.\n\n\n  Span.prototype._addTags = function (keyValuePairs) {}; // By default does nothing\n\n\n  Span.prototype._log = function (keyValuePairs, timestamp) {}; // By default does nothing\n  //\n  // finishTime is expected to be either a number or undefined.\n\n\n  Span.prototype._finish = function (finishTime) {};\n\n  return Span;\n}();\n\nexports.Span = Span;\nexports.default = Span;\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/span.js?");

/***/ }),

/***/ "wAB+":
/*!***************************************************!*\
  !*** ./node_modules/opentracing/lib/constants.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * The FORMAT_BINARY format represents SpanContexts in an opaque binary\n * carrier.\n *\n * Tracer.inject() will set the buffer field to an Array-like (Array,\n * ArrayBuffer, or TypedBuffer) object containing the injected binary data.\n * Any valid Object can be used as long as the buffer field of the object\n * can be set.\n *\n * Tracer.extract() will look for `carrier.buffer`, and that field is\n * expected to be an Array-like object (Array, ArrayBuffer, or\n * TypedBuffer).\n */\n\nexports.FORMAT_BINARY = 'binary';\n/**\n * The FORMAT_TEXT_MAP format represents SpanContexts using a\n * string->string map (backed by a Javascript Object) as a carrier.\n *\n * NOTE: Unlike FORMAT_HTTP_HEADERS, FORMAT_TEXT_MAP places no restrictions\n * on the characters used in either the keys or the values of the map\n * entries.\n *\n * The FORMAT_TEXT_MAP carrier map may contain unrelated data (e.g.,\n * arbitrary gRPC metadata); as such, the Tracer implementation should use\n * a prefix or other convention to distinguish Tracer-specific key:value\n * pairs.\n */\n\nexports.FORMAT_TEXT_MAP = 'text_map';\n/**\n * The FORMAT_HTTP_HEADERS format represents SpanContexts using a\n * character-restricted string->string map (backed by a Javascript Object)\n * as a carrier.\n *\n * Keys and values in the FORMAT_HTTP_HEADERS carrier must be suitable for\n * use as HTTP headers (without modification or further escaping). That is,\n * the keys have a greatly restricted character set, casing for the keys\n * may not be preserved by various intermediaries, and the values should be\n * URL-escaped.\n *\n * The FORMAT_HTTP_HEADERS carrier map may contain unrelated data (e.g.,\n * arbitrary HTTP headers); as such, the Tracer implementation should use a\n * prefix or other convention to distinguish Tracer-specific key:value\n * pairs.\n */\n\nexports.FORMAT_HTTP_HEADERS = 'http_headers';\n/**\n * A Span may be the \"child of\" a parent Span. In a “child of” reference,\n * the parent Span depends on the child Span in some capacity.\n *\n * See more about reference types at https://github.com/opentracing/specification\n */\n\nexports.REFERENCE_CHILD_OF = 'child_of';\n/**\n * Some parent Spans do not depend in any way on the result of their child\n * Spans. In these cases, we say merely that the child Span “follows from”\n * the parent Span in a causal sense.\n *\n * See more about reference types at https://github.com/opentracing/specification\n */\n\nexports.REFERENCE_FOLLOWS_FROM = 'follows_from';\n\n//# sourceURL=webpack:///./node_modules/opentracing/lib/constants.js?");

/***/ })

}]);