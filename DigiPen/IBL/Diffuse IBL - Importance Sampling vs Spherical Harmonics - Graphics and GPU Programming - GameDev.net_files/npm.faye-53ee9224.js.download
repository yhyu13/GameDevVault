(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.faye"],{

/***/ "/eTV":
/*!*********************************************************!*\
  !*** ./node_modules/faye/src/transport/event_source.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    copyObject = __webpack_require__(/*! ../util/copy_object */ \"LaPb\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    Deferrable = __webpack_require__(/*! ../mixins/deferrable */ \"sBHE\"),\n    Transport = __webpack_require__(/*! ./transport */ \"X4bz\"),\n    XHR = __webpack_require__(/*! ./xhr */ \"LmlN\");\n\nvar EventSource = extend(Class(Transport, {\n  initialize: function (dispatcher, endpoint) {\n    Transport.prototype.initialize.call(this, dispatcher, endpoint);\n    if (!global.EventSource) return this.setDeferredStatus('failed');\n    this._xhr = new XHR(dispatcher, endpoint);\n    endpoint = copyObject(endpoint);\n    endpoint.pathname += '/' + dispatcher.clientId;\n    var socket = new global.EventSource(URI.stringify(endpoint)),\n        self = this;\n\n    socket.onopen = function () {\n      self._everConnected = true;\n      self.setDeferredStatus('succeeded');\n    };\n\n    socket.onerror = function () {\n      if (self._everConnected) {\n        self._handleError([]);\n      } else {\n        self.setDeferredStatus('failed');\n        socket.close();\n      }\n    };\n\n    socket.onmessage = function (event) {\n      var replies;\n\n      try {\n        replies = JSON.parse(event.data);\n      } catch (error) {}\n\n      if (replies) self._receive(replies);else self._handleError([]);\n    };\n\n    this._socket = socket;\n  },\n  close: function () {\n    if (!this._socket) return;\n    this._socket.onopen = this._socket.onerror = this._socket.onmessage = null;\n\n    this._socket.close();\n\n    delete this._socket;\n  },\n  isUsable: function (callback, context) {\n    this.callback(function () {\n      callback.call(context, true);\n    });\n    this.errback(function () {\n      callback.call(context, false);\n    });\n  },\n  encode: function (messages) {\n    return this._xhr.encode(messages);\n  },\n  request: function (messages) {\n    return this._xhr.request(messages);\n  }\n}), {\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    var id = dispatcher.clientId;\n    if (!id) return callback.call(context, false);\n    XHR.isUsable(dispatcher, endpoint, function (usable) {\n      if (!usable) return callback.call(context, false);\n      this.create(dispatcher, endpoint).isUsable(callback, context);\n    }, this);\n  },\n  create: function (dispatcher, endpoint) {\n    var sockets = dispatcher.transports.eventsource = dispatcher.transports.eventsource || {},\n        id = dispatcher.clientId;\n    var url = copyObject(endpoint);\n    url.pathname += '/' + (id || '');\n    url = URI.stringify(url);\n    sockets[url] = sockets[url] || new this(dispatcher, endpoint);\n    return sockets[url];\n  }\n});\nextend(EventSource.prototype, Deferrable);\nmodule.exports = EventSource;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/event_source.js?");

/***/ }),

/***/ "0mcS":
/*!**************************************************!*\
  !*** ./node_modules/faye/src/mixins/timeouts.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nmodule.exports = {\n  addTimeout: function (name, delay, callback, context) {\n    this._timeouts = this._timeouts || {};\n    if (this._timeouts.hasOwnProperty(name)) return;\n    var self = this;\n    this._timeouts[name] = global.setTimeout(function () {\n      delete self._timeouts[name];\n      callback.call(context);\n    }, 1000 * delay);\n  },\n  removeTimeout: function (name) {\n    this._timeouts = this._timeouts || {};\n    var timeout = this._timeouts[name];\n    if (!timeout) return;\n    global.clearTimeout(timeout);\n    delete this._timeouts[name];\n  },\n  removeAllTimeouts: function () {\n    this._timeouts = this._timeouts || {};\n\n    for (var name in this._timeouts) this.removeTimeout(name);\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/mixins/timeouts.js?");

/***/ }),

/***/ "0spm":
/*!*********************************************!*\
  !*** ./node_modules/faye/src/util/array.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  commonElement: function (lista, listb) {\n    for (var i = 0, n = lista.length; i < n; i++) {\n      if (this.indexOf(listb, lista[i]) !== -1) return lista[i];\n    }\n\n    return null;\n  },\n  indexOf: function (list, needle) {\n    if (list.indexOf) return list.indexOf(needle);\n\n    for (var i = 0, n = list.length; i < n; i++) {\n      if (list[i] === needle) return i;\n    }\n\n    return -1;\n  },\n  map: function (object, callback, context) {\n    if (object.map) return object.map(callback, context);\n    var result = [];\n\n    if (object instanceof Array) {\n      for (var i = 0, n = object.length; i < n; i++) {\n        result.push(callback.call(context || null, object[i], i));\n      }\n    } else {\n      for (var key in object) {\n        if (!object.hasOwnProperty(key)) continue;\n        result.push(callback.call(context || null, key, object[key]));\n      }\n    }\n\n    return result;\n  },\n  filter: function (array, callback, context) {\n    if (array.filter) return array.filter(callback, context);\n    var result = [];\n\n    for (var i = 0, n = array.length; i < n; i++) {\n      if (callback.call(context || null, array[i], i)) result.push(array[i]);\n    }\n\n    return result;\n  },\n  asyncEach: function (list, iterator, callback, context) {\n    var n = list.length,\n        i = -1,\n        calls = 0,\n        looping = false;\n\n    var iterate = function () {\n      calls -= 1;\n      i += 1;\n      if (i === n) return callback && callback.call(context);\n      iterator(list[i], resume);\n    };\n\n    var loop = function () {\n      if (looping) return;\n      looping = true;\n\n      while (calls > 0) iterate();\n\n      looping = false;\n    };\n\n    var resume = function () {\n      calls += 1;\n      loop();\n    };\n\n    resume();\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/array.js?");

/***/ }),

/***/ "1xLH":
/*!***********************************************!*\
  !*** ./node_modules/faye/src/util/promise.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar asap = __webpack_require__(/*! asap */ \"IEa/\");\n\nvar PENDING = 0,\n    FULFILLED = 1,\n    REJECTED = 2;\n\nvar RETURN = function (x) {\n  return x;\n},\n    THROW = function (x) {\n  throw x;\n};\n\nvar Promise = function (task) {\n  this._state = PENDING;\n  this._onFulfilled = [];\n  this._onRejected = [];\n  if (typeof task !== 'function') return;\n  var self = this;\n  task(function (value) {\n    resolve(self, value);\n  }, function (reason) {\n    reject(self, reason);\n  });\n};\n\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  var next = new Promise();\n  registerOnFulfilled(this, onFulfilled, next);\n  registerOnRejected(this, onRejected, next);\n  return next;\n};\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\nvar registerOnFulfilled = function (promise, onFulfilled, next) {\n  if (typeof onFulfilled !== 'function') onFulfilled = RETURN;\n\n  var handler = function (value) {\n    invoke(onFulfilled, value, next);\n  };\n\n  if (promise._state === PENDING) {\n    promise._onFulfilled.push(handler);\n  } else if (promise._state === FULFILLED) {\n    handler(promise._value);\n  }\n};\n\nvar registerOnRejected = function (promise, onRejected, next) {\n  if (typeof onRejected !== 'function') onRejected = THROW;\n\n  var handler = function (reason) {\n    invoke(onRejected, reason, next);\n  };\n\n  if (promise._state === PENDING) {\n    promise._onRejected.push(handler);\n  } else if (promise._state === REJECTED) {\n    handler(promise._reason);\n  }\n};\n\nvar invoke = function (fn, value, next) {\n  asap(function () {\n    _invoke(fn, value, next);\n  });\n};\n\nvar _invoke = function (fn, value, next) {\n  var outcome;\n\n  try {\n    outcome = fn(value);\n  } catch (error) {\n    return reject(next, error);\n  }\n\n  if (outcome === next) {\n    reject(next, new TypeError('Recursive promise chain detected'));\n  } else {\n    resolve(next, outcome);\n  }\n};\n\nvar resolve = function (promise, value) {\n  var called = false,\n      type,\n      then;\n\n  try {\n    type = typeof value;\n    then = value !== null && (type === 'function' || type === 'object') && value.then;\n    if (typeof then !== 'function') return fulfill(promise, value);\n    then.call(value, function (v) {\n      if (!(called ^ (called = true))) return;\n      resolve(promise, v);\n    }, function (r) {\n      if (!(called ^ (called = true))) return;\n      reject(promise, r);\n    });\n  } catch (error) {\n    if (!(called ^ (called = true))) return;\n    reject(promise, error);\n  }\n};\n\nvar fulfill = function (promise, value) {\n  if (promise._state !== PENDING) return;\n  promise._state = FULFILLED;\n  promise._value = value;\n  promise._onRejected = [];\n  var onFulfilled = promise._onFulfilled,\n      fn;\n\n  while (fn = onFulfilled.shift()) fn(value);\n};\n\nvar reject = function (promise, reason) {\n  if (promise._state !== PENDING) return;\n  promise._state = REJECTED;\n  promise._reason = reason;\n  promise._onFulfilled = [];\n  var onRejected = promise._onRejected,\n      fn;\n\n  while (fn = onRejected.shift()) fn(reason);\n};\n\nPromise.resolve = function (value) {\n  return new Promise(function (resolve, reject) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function (reason) {\n  return new Promise(function (resolve, reject) {\n    reject(reason);\n  });\n};\n\nPromise.all = function (promises) {\n  return new Promise(function (resolve, reject) {\n    var list = [],\n        n = promises.length,\n        i;\n    if (n === 0) return resolve(list);\n\n    for (i = 0; i < n; i++) (function (promise, i) {\n      Promise.resolve(promise).then(function (value) {\n        list[i] = value;\n        if (--n === 0) resolve(list);\n      }, reject);\n    })(promises[i], i);\n  });\n};\n\nPromise.race = function (promises) {\n  return new Promise(function (resolve, reject) {\n    for (var i = 0, n = promises.length; i < n; i++) Promise.resolve(promises[i]).then(resolve, reject);\n  });\n};\n\nPromise.deferred = Promise.pending = function () {\n  var tuple = {};\n  tuple.promise = new Promise(function (resolve, reject) {\n    tuple.resolve = resolve;\n    tuple.reject = reject;\n  });\n  return tuple;\n};\n\nmodule.exports = Promise;\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/promise.js?");

/***/ }),

/***/ "57ya":
/*!*******************************************************!*\
  !*** ./node_modules/faye/src/protocol/publication.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    Deferrable = __webpack_require__(/*! ../mixins/deferrable */ \"sBHE\");\n\nmodule.exports = Class(Deferrable);\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/publication.js?");

/***/ }),

/***/ "6CFe":
/*!*************************************************!*\
  !*** ./node_modules/faye/src/transport/cors.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    Set = __webpack_require__(/*! ../util/set */ \"OByb\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    toJSON = __webpack_require__(/*! ../util/to_json */ \"aF77\"),\n    Transport = __webpack_require__(/*! ./transport */ \"X4bz\");\n\nvar CORS = extend(Class(Transport, {\n  encode: function (messages) {\n    return 'message=' + encodeURIComponent(toJSON(messages));\n  },\n  request: function (messages) {\n    var xhrClass = global.XDomainRequest ? XDomainRequest : XMLHttpRequest,\n        xhr = new xhrClass(),\n        id = ++CORS._id,\n        headers = this._dispatcher.headers,\n        self = this,\n        key;\n    xhr.open('POST', URI.stringify(this.endpoint), true);\n\n    if (xhr.setRequestHeader) {\n      xhr.setRequestHeader('Pragma', 'no-cache');\n\n      for (key in headers) {\n        if (!headers.hasOwnProperty(key)) continue;\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    var cleanUp = function () {\n      if (!xhr) return false;\n\n      CORS._pending.remove(id);\n\n      xhr.onload = xhr.onerror = xhr.ontimeout = xhr.onprogress = null;\n      xhr = null;\n    };\n\n    xhr.onload = function () {\n      var replies;\n\n      try {\n        replies = JSON.parse(xhr.responseText);\n      } catch (error) {}\n\n      cleanUp();\n      if (replies) self._receive(replies);else self._handleError(messages);\n    };\n\n    xhr.onerror = xhr.ontimeout = function () {\n      cleanUp();\n\n      self._handleError(messages);\n    };\n\n    xhr.onprogress = function () {};\n\n    if (xhrClass === global.XDomainRequest) CORS._pending.add({\n      id: id,\n      xhr: xhr\n    });\n    xhr.send(this.encode(messages));\n    return xhr;\n  }\n}), {\n  _id: 0,\n  _pending: new Set(),\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    if (URI.isSameOrigin(endpoint)) return callback.call(context, false);\n    if (global.XDomainRequest) return callback.call(context, endpoint.protocol === location.protocol);\n\n    if (global.XMLHttpRequest) {\n      var xhr = new XMLHttpRequest();\n      return callback.call(context, xhr.withCredentials !== undefined);\n    }\n\n    return callback.call(context, false);\n  }\n});\nmodule.exports = CORS;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/cors.js?");

/***/ }),

/***/ "6onv":
/*!********************************************************!*\
  !*** ./node_modules/faye/src/protocol/subscription.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    Deferrable = __webpack_require__(/*! ../mixins/deferrable */ \"sBHE\");\n\nvar Subscription = Class({\n  initialize: function (client, channels, callback, context) {\n    this._client = client;\n    this._channels = channels;\n    this._callback = callback;\n    this._context = context;\n    this._cancelled = false;\n  },\n  withChannel: function (callback, context) {\n    this._withChannel = [callback, context];\n    return this;\n  },\n  apply: function (context, args) {\n    var message = args[0];\n    if (this._callback) this._callback.call(this._context, message.data);\n    if (this._withChannel) this._withChannel[0].call(this._withChannel[1], message.channel, message.data);\n  },\n  cancel: function () {\n    if (this._cancelled) return;\n\n    this._client.unsubscribe(this._channels, this);\n\n    this._cancelled = true;\n  },\n  unsubscribe: function () {\n    this.cancel();\n  }\n});\nextend(Subscription.prototype, Deferrable);\nmodule.exports = Subscription;\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/subscription.js?");

/***/ }),

/***/ "7Y8a":
/*!******************************************************!*\
  !*** ./node_modules/faye/src/protocol/dispatcher.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    cookies = __webpack_require__(/*! ../util/cookies */ \"cYuL\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    Logging = __webpack_require__(/*! ../mixins/logging */ \"pp5c\"),\n    Publisher = __webpack_require__(/*! ../mixins/publisher */ \"Y764\"),\n    Transport = __webpack_require__(/*! ../transport */ \"hyK+\"),\n    Scheduler = __webpack_require__(/*! ./scheduler */ \"SuKS\");\n\nvar Dispatcher = Class({\n  className: 'Dispatcher',\n  MAX_REQUEST_SIZE: 2048,\n  DEFAULT_RETRY: 5,\n  UP: 1,\n  DOWN: 2,\n  initialize: function (client, endpoint, options) {\n    this._client = client;\n    this.endpoint = URI.parse(endpoint);\n    this._alternates = options.endpoints || {};\n    this.cookies = cookies.CookieJar && new cookies.CookieJar();\n    this._disabled = [];\n    this._envelopes = {};\n    this.headers = {};\n    this.retry = options.retry || this.DEFAULT_RETRY;\n    this._scheduler = options.scheduler || Scheduler;\n    this._state = 0;\n    this.transports = {};\n    this.wsExtensions = [];\n    this.proxy = options.proxy || {};\n    if (typeof this._proxy === 'string') this._proxy = {\n      origin: this._proxy\n    };\n    var exts = options.websocketExtensions;\n\n    if (exts) {\n      exts = [].concat(exts);\n\n      for (var i = 0, n = exts.length; i < n; i++) this.addWebsocketExtension(exts[i]);\n    }\n\n    this.tls = options.tls || {};\n    this.tls.ca = this.tls.ca || options.ca;\n\n    for (var type in this._alternates) this._alternates[type] = URI.parse(this._alternates[type]);\n\n    this.maxRequestSize = this.MAX_REQUEST_SIZE;\n  },\n  endpointFor: function (connectionType) {\n    return this._alternates[connectionType] || this.endpoint;\n  },\n  addWebsocketExtension: function (extension) {\n    this.wsExtensions.push(extension);\n  },\n  disable: function (feature) {\n    this._disabled.push(feature);\n  },\n  setHeader: function (name, value) {\n    this.headers[name] = value;\n  },\n  close: function () {\n    var transport = this._transport;\n    delete this._transport;\n    if (transport) transport.close();\n  },\n  getConnectionTypes: function () {\n    return Transport.getConnectionTypes();\n  },\n  selectTransport: function (transportTypes) {\n    Transport.get(this, transportTypes, this._disabled, function (transport) {\n      this.debug('Selected ? transport for ?', transport.connectionType, URI.stringify(transport.endpoint));\n      if (transport === this._transport) return;\n      if (this._transport) this._transport.close();\n      this._transport = transport;\n      this.connectionType = transport.connectionType;\n    }, this);\n  },\n  sendMessage: function (message, timeout, options) {\n    options = options || {};\n    var id = message.id,\n        attempts = options.attempts,\n        deadline = options.deadline && new Date().getTime() + options.deadline * 1000,\n        envelope = this._envelopes[id],\n        scheduler;\n\n    if (!envelope) {\n      scheduler = new this._scheduler(message, {\n        timeout: timeout,\n        interval: this.retry,\n        attempts: attempts,\n        deadline: deadline\n      });\n      envelope = this._envelopes[id] = {\n        message: message,\n        scheduler: scheduler\n      };\n    }\n\n    this._sendEnvelope(envelope);\n  },\n  _sendEnvelope: function (envelope) {\n    if (!this._transport) return;\n    if (envelope.request || envelope.timer) return;\n    var message = envelope.message,\n        scheduler = envelope.scheduler,\n        self = this;\n\n    if (!scheduler.isDeliverable()) {\n      scheduler.abort();\n      delete this._envelopes[message.id];\n      return;\n    }\n\n    envelope.timer = global.setTimeout(function () {\n      self.handleError(message);\n    }, scheduler.getTimeout() * 1000);\n    scheduler.send();\n    envelope.request = this._transport.sendMessage(message);\n  },\n  handleResponse: function (reply) {\n    var envelope = this._envelopes[reply.id];\n\n    if (reply.successful !== undefined && envelope) {\n      envelope.scheduler.succeed();\n      delete this._envelopes[reply.id];\n      global.clearTimeout(envelope.timer);\n    }\n\n    this.trigger('message', reply);\n    if (this._state === this.UP) return;\n    this._state = this.UP;\n\n    this._client.trigger('transport:up');\n  },\n  handleError: function (message, immediate) {\n    var envelope = this._envelopes[message.id],\n        request = envelope && envelope.request,\n        self = this;\n    if (!request) return;\n    request.then(function (req) {\n      if (req && req.abort) req.abort();\n    });\n    var scheduler = envelope.scheduler;\n    scheduler.fail();\n    global.clearTimeout(envelope.timer);\n    envelope.request = envelope.timer = null;\n\n    if (immediate) {\n      this._sendEnvelope(envelope);\n    } else {\n      envelope.timer = global.setTimeout(function () {\n        envelope.timer = null;\n\n        self._sendEnvelope(envelope);\n      }, scheduler.getInterval() * 1000);\n    }\n\n    if (this._state === this.DOWN) return;\n    this._state = this.DOWN;\n\n    this._client.trigger('transport:down');\n  }\n});\n\nDispatcher.create = function (client, endpoint, options) {\n  return new Dispatcher(client, endpoint, options);\n};\n\nextend(Dispatcher.prototype, Publisher);\nextend(Dispatcher.prototype, Logging);\nmodule.exports = Dispatcher;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/dispatcher.js?");

/***/ }),

/***/ "Aj/Y":
/*!***************************************************!*\
  !*** ./node_modules/faye/src/protocol/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  CHANNEL_NAME: /^\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+(\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+)*$/,\n  CHANNEL_PATTERN: /^(\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+)*\\/\\*{1,2}$/,\n  ERROR: /^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*(,(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*)$/,\n  VERSION: /^([0-9])+(\\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\\-|\\_))*)*$/\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/grammar.js?");

/***/ }),

/***/ "LaPb":
/*!***************************************************!*\
  !*** ./node_modules/faye/src/util/copy_object.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar copyObject = function (object) {\n  var clone, i, key;\n\n  if (object instanceof Array) {\n    clone = [];\n    i = object.length;\n\n    while (i--) clone[i] = copyObject(object[i]);\n\n    return clone;\n  } else if (typeof object === 'object') {\n    clone = object === null ? null : {};\n\n    for (key in object) clone[key] = copyObject(object[key]);\n\n    return clone;\n  } else {\n    return object;\n  }\n};\n\nmodule.exports = copyObject;\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/copy_object.js?");

/***/ }),

/***/ "LmlN":
/*!************************************************!*\
  !*** ./node_modules/faye/src/transport/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    browser = __webpack_require__(/*! ../util/browser */ \"QK+q\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    toJSON = __webpack_require__(/*! ../util/to_json */ \"aF77\"),\n    Transport = __webpack_require__(/*! ./transport */ \"X4bz\");\n\nvar XHR = extend(Class(Transport, {\n  encode: function (messages) {\n    return toJSON(messages);\n  },\n  request: function (messages) {\n    var href = this.endpoint.href,\n        self = this,\n        xhr; // Prefer XMLHttpRequest over ActiveXObject if they both exist\n\n    if (global.XMLHttpRequest) {\n      xhr = new XMLHttpRequest();\n    } else if (global.ActiveXObject) {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    } else {\n      return this._handleError(messages);\n    }\n\n    xhr.open('POST', href, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.setRequestHeader('Pragma', 'no-cache');\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    var headers = this._dispatcher.headers;\n\n    for (var key in headers) {\n      if (!headers.hasOwnProperty(key)) continue;\n      xhr.setRequestHeader(key, headers[key]);\n    }\n\n    var abort = function () {\n      xhr.abort();\n    };\n\n    if (global.onbeforeunload !== undefined) browser.Event.on(global, 'beforeunload', abort);\n\n    xhr.onreadystatechange = function () {\n      if (!xhr || xhr.readyState !== 4) return;\n      var replies = null,\n          status = xhr.status,\n          text = xhr.responseText,\n          successful = status >= 200 && status < 300 || status === 304 || status === 1223;\n      if (global.onbeforeunload !== undefined) browser.Event.detach(global, 'beforeunload', abort);\n\n      xhr.onreadystatechange = function () {};\n\n      xhr = null;\n      if (!successful) return self._handleError(messages);\n\n      try {\n        replies = JSON.parse(text);\n      } catch (error) {}\n\n      if (replies) self._receive(replies);else self._handleError(messages);\n    };\n\n    xhr.send(this.encode(messages));\n    return xhr;\n  }\n}), {\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    var usable = navigator.product === 'ReactNative' || URI.isSameOrigin(endpoint);\n    callback.call(context, usable);\n  }\n});\nmodule.exports = XHR;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/xhr.js?");

/***/ }),

/***/ "Lysv":
/*!********************************************************!*\
  !*** ./node_modules/faye/src/util/validate_options.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar array = __webpack_require__(/*! ./array */ \"0spm\");\n\nmodule.exports = function (options, validKeys) {\n  for (var key in options) {\n    if (array.indexOf(validKeys, key) < 0) throw new Error('Unrecognized option: ' + key);\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/validate_options.js?");

/***/ }),

/***/ "NG9E":
/*!*********************************************!*\
  !*** ./node_modules/faye/src/util/class.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar extend = __webpack_require__(/*! ./extend */ \"aR6h\");\n\nmodule.exports = function (parent, methods) {\n  if (typeof parent !== 'function') {\n    methods = parent;\n    parent = Object;\n  }\n\n  var klass = function () {\n    if (!this.initialize) return this;\n    return this.initialize.apply(this, arguments) || this;\n  };\n\n  var bridge = function () {};\n\n  bridge.prototype = parent.prototype;\n  klass.prototype = new bridge();\n  extend(klass.prototype, methods);\n  return klass;\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/class.js?");

/***/ }),

/***/ "NqLL":
/*!*******************************************!*\
  !*** ./node_modules/faye/src/util/uri.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  isURI: function (uri) {\n    return uri && uri.protocol && uri.host && uri.path;\n  },\n  isSameOrigin: function (uri) {\n    return uri.protocol === location.protocol && uri.hostname === location.hostname && uri.port === location.port;\n  },\n  parse: function (url) {\n    if (typeof url !== 'string') return url;\n    var uri = {},\n        parts,\n        query,\n        pairs,\n        i,\n        n,\n        data;\n\n    var consume = function (name, pattern) {\n      url = url.replace(pattern, function (match) {\n        uri[name] = match;\n        return '';\n      });\n      uri[name] = uri[name] || '';\n    };\n\n    consume('protocol', /^[a-z]+\\:/i);\n    consume('host', /^\\/\\/[^\\/\\?#]+/);\n    if (!/^\\//.test(url) && !uri.host) url = location.pathname.replace(/[^\\/]*$/, '') + url;\n    consume('pathname', /^[^\\?#]*/);\n    consume('search', /^\\?[^#]*/);\n    consume('hash', /^#.*/);\n    uri.protocol = uri.protocol || location.protocol;\n\n    if (uri.host) {\n      uri.host = uri.host.substr(2);\n      parts = uri.host.split(':');\n      uri.hostname = parts[0];\n      uri.port = parts[1] || '';\n    } else {\n      uri.host = location.host;\n      uri.hostname = location.hostname;\n      uri.port = location.port;\n    }\n\n    uri.pathname = uri.pathname || '/';\n    uri.path = uri.pathname + uri.search;\n    query = uri.search.replace(/^\\?/, '');\n    pairs = query ? query.split('&') : [];\n    data = {};\n\n    for (i = 0, n = pairs.length; i < n; i++) {\n      parts = pairs[i].split('=');\n      data[decodeURIComponent(parts[0] || '')] = decodeURIComponent(parts[1] || '');\n    }\n\n    uri.query = data;\n    uri.href = this.stringify(uri);\n    return uri;\n  },\n  stringify: function (uri) {\n    var string = uri.protocol + '//' + uri.hostname;\n    if (uri.port) string += ':' + uri.port;\n    string += uri.pathname + this.queryString(uri.query) + (uri.hash || '');\n    return string;\n  },\n  queryString: function (query) {\n    var pairs = [];\n\n    for (var key in query) {\n      if (!query.hasOwnProperty(key)) continue;\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));\n    }\n\n    if (pairs.length === 0) return '';\n    return '?' + pairs.join('&');\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/uri.js?");

/***/ }),

/***/ "OByb":
/*!*******************************************!*\
  !*** ./node_modules/faye/src/util/set.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Class = __webpack_require__(/*! ./class */ \"NG9E\");\n\nmodule.exports = Class({\n  initialize: function () {\n    this._index = {};\n  },\n  add: function (item) {\n    var key = item.id !== undefined ? item.id : item;\n    if (this._index.hasOwnProperty(key)) return false;\n    this._index[key] = item;\n    return true;\n  },\n  forEach: function (block, context) {\n    for (var key in this._index) {\n      if (this._index.hasOwnProperty(key)) block.call(context, this._index[key]);\n    }\n  },\n  isEmpty: function () {\n    for (var key in this._index) {\n      if (this._index.hasOwnProperty(key)) return false;\n    }\n\n    return true;\n  },\n  member: function (item) {\n    for (var key in this._index) {\n      if (this._index[key] === item) return true;\n    }\n\n    return false;\n  },\n  remove: function (item) {\n    var key = item.id !== undefined ? item.id : item;\n    var removed = this._index[key];\n    delete this._index[key];\n    return removed;\n  },\n  toArray: function () {\n    var array = [];\n    this.forEach(function (item) {\n      array.push(item);\n    });\n    return array;\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/set.js?");

/***/ }),

/***/ "QK+q":
/*!*****************************************************!*\
  !*** ./node_modules/faye/src/util/browser/event.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Event = {\n  _registry: [],\n  on: function (element, eventName, callback, context) {\n    var wrapped = function () {\n      callback.call(context);\n    };\n\n    if (element.addEventListener) element.addEventListener(eventName, wrapped, false);else element.attachEvent('on' + eventName, wrapped);\n\n    this._registry.push({\n      _element: element,\n      _type: eventName,\n      _callback: callback,\n      _context: context,\n      _handler: wrapped\n    });\n  },\n  detach: function (element, eventName, callback, context) {\n    var i = this._registry.length,\n        register;\n\n    while (i--) {\n      register = this._registry[i];\n      if (element && element !== register._element || eventName && eventName !== register._type || callback && callback !== register._callback || context && context !== register._context) continue;\n      if (register._element.removeEventListener) register._element.removeEventListener(register._type, register._handler, false);else register._element.detachEvent('on' + register._type, register._handler);\n\n      this._registry.splice(i, 1);\n\n      register = null;\n    }\n  }\n};\nif (global.onunload !== undefined) Event.on(global, 'unload', Event.detach, Event);\nmodule.exports = {\n  Event: Event\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/browser/event.js?");

/***/ }),

/***/ "ReXR":
/*!***************************************************!*\
  !*** ./node_modules/faye/src/protocol/channel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    Publisher = __webpack_require__(/*! ../mixins/publisher */ \"Y764\"),\n    Grammar = __webpack_require__(/*! ./grammar */ \"Aj/Y\");\n\nvar Channel = Class({\n  initialize: function (name) {\n    this.id = this.name = name;\n  },\n  push: function (message) {\n    this.trigger('message', message);\n  },\n  isUnused: function () {\n    return this.countListeners('message') === 0;\n  }\n});\nextend(Channel.prototype, Publisher);\nextend(Channel, {\n  HANDSHAKE: '/meta/handshake',\n  CONNECT: '/meta/connect',\n  SUBSCRIBE: '/meta/subscribe',\n  UNSUBSCRIBE: '/meta/unsubscribe',\n  DISCONNECT: '/meta/disconnect',\n  META: 'meta',\n  SERVICE: 'service',\n  expand: function (name) {\n    var segments = this.parse(name),\n        channels = ['/**', name];\n    var copy = segments.slice();\n    copy[copy.length - 1] = '*';\n    channels.push(this.unparse(copy));\n\n    for (var i = 1, n = segments.length; i < n; i++) {\n      copy = segments.slice(0, i);\n      copy.push('**');\n      channels.push(this.unparse(copy));\n    }\n\n    return channels;\n  },\n  isValid: function (name) {\n    return Grammar.CHANNEL_NAME.test(name) || Grammar.CHANNEL_PATTERN.test(name);\n  },\n  parse: function (name) {\n    if (!this.isValid(name)) return null;\n    return name.split('/').slice(1);\n  },\n  unparse: function (segments) {\n    return '/' + segments.join('/');\n  },\n  isMeta: function (name) {\n    var segments = this.parse(name);\n    return segments ? segments[0] === this.META : null;\n  },\n  isService: function (name) {\n    var segments = this.parse(name);\n    return segments ? segments[0] === this.SERVICE : null;\n  },\n  isSubscribable: function (name) {\n    if (!this.isValid(name)) return null;\n    return !this.isMeta(name) && !this.isService(name);\n  },\n  Set: Class({\n    initialize: function () {\n      this._channels = {};\n    },\n    getKeys: function () {\n      var keys = [];\n\n      for (var key in this._channels) keys.push(key);\n\n      return keys;\n    },\n    remove: function (name) {\n      delete this._channels[name];\n    },\n    hasSubscription: function (name) {\n      return this._channels.hasOwnProperty(name);\n    },\n    subscribe: function (names, subscription) {\n      var name;\n\n      for (var i = 0, n = names.length; i < n; i++) {\n        name = names[i];\n        var channel = this._channels[name] = this._channels[name] || new Channel(name);\n        channel.bind('message', subscription);\n      }\n    },\n    unsubscribe: function (name, subscription) {\n      var channel = this._channels[name];\n      if (!channel) return false;\n      channel.unbind('message', subscription);\n\n      if (channel.isUnused()) {\n        this.remove(name);\n        return true;\n      } else {\n        return false;\n      }\n    },\n    distributeMessage: function (message) {\n      var channels = Channel.expand(message.channel);\n\n      for (var i = 0, n = channels.length; i < n; i++) {\n        var channel = this._channels[channels[i]];\n        if (channel) channel.trigger('message', message);\n      }\n    }\n  })\n});\nmodule.exports = Channel;\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/channel.js?");

/***/ }),

/***/ "SuKS":
/*!*****************************************************!*\
  !*** ./node_modules/faye/src/protocol/scheduler.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar extend = __webpack_require__(/*! ../util/extend */ \"aR6h\");\n\nvar Scheduler = function (message, options) {\n  this.message = message;\n  this.options = options;\n  this.attempts = 0;\n};\n\nextend(Scheduler.prototype, {\n  getTimeout: function () {\n    return this.options.timeout;\n  },\n  getInterval: function () {\n    return this.options.interval;\n  },\n  isDeliverable: function () {\n    var attempts = this.options.attempts,\n        made = this.attempts,\n        deadline = this.options.deadline,\n        now = new Date().getTime();\n    if (attempts !== undefined && made >= attempts) return false;\n    if (deadline !== undefined && now > deadline) return false;\n    return true;\n  },\n  send: function () {\n    this.attempts += 1;\n  },\n  succeed: function () {},\n  fail: function () {},\n  abort: function () {}\n});\nmodule.exports = Scheduler;\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/scheduler.js?");

/***/ }),

/***/ "X4bz":
/*!******************************************************!*\
  !*** ./node_modules/faye/src/transport/transport.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    Cookie = __webpack_require__(/*! ../util/cookies */ \"cYuL\").Cookie,\n    Promise = __webpack_require__(/*! ../util/promise */ \"1xLH\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    array = __webpack_require__(/*! ../util/array */ \"0spm\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    Logging = __webpack_require__(/*! ../mixins/logging */ \"pp5c\"),\n    Timeouts = __webpack_require__(/*! ../mixins/timeouts */ \"0mcS\"),\n    Channel = __webpack_require__(/*! ../protocol/channel */ \"ReXR\");\n\nvar Transport = extend(Class({\n  className: 'Transport',\n  DEFAULT_PORTS: {\n    'http:': 80,\n    'https:': 443,\n    'ws:': 80,\n    'wss:': 443\n  },\n  MAX_DELAY: 0,\n  batching: true,\n  initialize: function (dispatcher, endpoint) {\n    this._dispatcher = dispatcher;\n    this.endpoint = endpoint;\n    this._outbox = [];\n    this._proxy = extend({}, this._dispatcher.proxy);\n    if (!this._proxy.origin) this._proxy.origin = this._findProxy();\n  },\n  close: function () {},\n  encode: function (messages) {\n    return '';\n  },\n  sendMessage: function (message) {\n    this.debug('Client ? sending message to ?: ?', this._dispatcher.clientId, URI.stringify(this.endpoint), message);\n    if (!this.batching) return Promise.resolve(this.request([message]));\n\n    this._outbox.push(message);\n\n    this._flushLargeBatch();\n\n    if (message.channel === Channel.HANDSHAKE) return this._publish(0.01);\n    if (message.channel === Channel.CONNECT) this._connectMessage = message;\n    return this._publish(this.MAX_DELAY);\n  },\n  _makePromise: function () {\n    var self = this;\n    this._requestPromise = this._requestPromise || new Promise(function (resolve) {\n      self._resolvePromise = resolve;\n    });\n  },\n  _publish: function (delay) {\n    this._makePromise();\n\n    this.addTimeout('publish', delay, function () {\n      this._flush();\n\n      delete this._requestPromise;\n    }, this);\n    return this._requestPromise;\n  },\n  _flush: function () {\n    this.removeTimeout('publish');\n    if (this._outbox.length > 1 && this._connectMessage) this._connectMessage.advice = {\n      timeout: 0\n    };\n\n    this._resolvePromise(this.request(this._outbox));\n\n    this._connectMessage = null;\n    this._outbox = [];\n  },\n  _flushLargeBatch: function () {\n    var string = this.encode(this._outbox);\n    if (string.length < this._dispatcher.maxRequestSize) return;\n\n    var last = this._outbox.pop();\n\n    this._makePromise();\n\n    this._flush();\n\n    if (last) this._outbox.push(last);\n  },\n  _receive: function (replies) {\n    if (!replies) return;\n    replies = [].concat(replies);\n    this.debug('Client ? received from ? via ?: ?', this._dispatcher.clientId, URI.stringify(this.endpoint), this.connectionType, replies);\n\n    for (var i = 0, n = replies.length; i < n; i++) this._dispatcher.handleResponse(replies[i]);\n  },\n  _handleError: function (messages, immediate) {\n    messages = [].concat(messages);\n    this.debug('Client ? failed to send to ? via ?: ?', this._dispatcher.clientId, URI.stringify(this.endpoint), this.connectionType, messages);\n\n    for (var i = 0, n = messages.length; i < n; i++) this._dispatcher.handleError(messages[i]);\n  },\n  _getCookies: function () {\n    var cookies = this._dispatcher.cookies,\n        url = URI.stringify(this.endpoint);\n    if (!cookies) return '';\n    return array.map(cookies.getCookiesSync(url), function (cookie) {\n      return cookie.cookieString();\n    }).join('; ');\n  },\n  _storeCookies: function (setCookie) {\n    var cookies = this._dispatcher.cookies,\n        url = URI.stringify(this.endpoint),\n        cookie;\n    if (!setCookie || !cookies) return;\n    setCookie = [].concat(setCookie);\n\n    for (var i = 0, n = setCookie.length; i < n; i++) {\n      cookie = Cookie.parse(setCookie[i]);\n      cookies.setCookieSync(cookie, url);\n    }\n  },\n  _findProxy: function () {\n    if (typeof process === 'undefined') return undefined;\n    var protocol = this.endpoint.protocol;\n    if (!protocol) return undefined;\n    var name = protocol.replace(/:$/, '').toLowerCase() + '_proxy',\n        upcase = name.toUpperCase(),\n        env = process.env,\n        keys,\n        proxy;\n\n    if (name === 'http_proxy' && env.REQUEST_METHOD) {\n      keys = Object.keys(env).filter(function (k) {\n        return /^http_proxy$/i.test(k);\n      });\n\n      if (keys.length === 1) {\n        if (keys[0] === name && env[upcase] === undefined) proxy = env[name];\n      } else if (keys.length > 1) {\n        proxy = env[name];\n      }\n\n      proxy = proxy || env['CGI_' + upcase];\n    } else {\n      proxy = env[name] || env[upcase];\n      if (proxy && !env[name]) console.warn('The environment variable ' + upcase + ' is discouraged. Use ' + name + '.');\n    }\n\n    return proxy;\n  }\n}), {\n  get: function (dispatcher, allowed, disabled, callback, context) {\n    var endpoint = dispatcher.endpoint;\n    array.asyncEach(this._transports, function (pair, resume) {\n      var connType = pair[0],\n          klass = pair[1],\n          connEndpoint = dispatcher.endpointFor(connType);\n      if (array.indexOf(disabled, connType) >= 0) return resume();\n\n      if (array.indexOf(allowed, connType) < 0) {\n        klass.isUsable(dispatcher, connEndpoint, function () {});\n        return resume();\n      }\n\n      klass.isUsable(dispatcher, connEndpoint, function (isUsable) {\n        if (!isUsable) return resume();\n        var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);\n        callback.call(context, transport);\n      });\n    }, function () {\n      throw new Error('Could not find a usable connection type for ' + URI.stringify(endpoint));\n    });\n  },\n  register: function (type, klass) {\n    this._transports.push([type, klass]);\n\n    klass.prototype.connectionType = type;\n  },\n  getConnectionTypes: function () {\n    return array.map(this._transports, function (t) {\n      return t[0];\n    });\n  },\n  _transports: []\n});\nextend(Transport.prototype, Logging);\nextend(Transport.prototype, Timeouts);\nmodule.exports = Transport;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"8oxB\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/transport.js?");

/***/ }),

/***/ "Y764":
/*!***************************************************!*\
  !*** ./node_modules/faye/src/mixins/publisher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    EventEmitter = __webpack_require__(/*! ../util/event_emitter */ \"bcrl\");\n\nvar Publisher = {\n  countListeners: function (eventType) {\n    return this.listeners(eventType).length;\n  },\n  bind: function (eventType, listener, context) {\n    var slice = Array.prototype.slice,\n        handler = function () {\n      listener.apply(context, slice.call(arguments));\n    };\n\n    this._listeners = this._listeners || [];\n\n    this._listeners.push([eventType, listener, context, handler]);\n\n    return this.on(eventType, handler);\n  },\n  unbind: function (eventType, listener, context) {\n    this._listeners = this._listeners || [];\n    var n = this._listeners.length,\n        tuple;\n\n    while (n--) {\n      tuple = this._listeners[n];\n      if (tuple[0] !== eventType) continue;\n      if (listener && (tuple[1] !== listener || tuple[2] !== context)) continue;\n\n      this._listeners.splice(n, 1);\n\n      this.removeListener(eventType, tuple[3]);\n    }\n  }\n};\nextend(Publisher, EventEmitter.prototype);\nPublisher.trigger = Publisher.emit;\nmodule.exports = Publisher;\n\n//# sourceURL=webpack:///./node_modules/faye/src/mixins/publisher.js?");

/***/ }),

/***/ "aF77":
/*!***********************************************!*\
  !*** ./node_modules/faye/src/util/to_json.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // http://assanka.net/content/tech/2009/09/02/json2-js-vs-prototype/\n\nmodule.exports = function (object) {\n  return JSON.stringify(object, function (key, value) {\n    return this[key] instanceof Array ? this[key] : value;\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/to_json.js?");

/***/ }),

/***/ "aR6h":
/*!**********************************************!*\
  !*** ./node_modules/faye/src/util/extend.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (dest, source, overwrite) {\n  if (!source) return dest;\n\n  for (var key in source) {\n    if (!source.hasOwnProperty(key)) continue;\n    if (dest.hasOwnProperty(key) && overwrite === false) continue;\n    if (dest[key] !== source[key]) dest[key] = source[key];\n  }\n\n  return dest;\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/extend.js?");

/***/ }),

/***/ "bMRo":
/*!**************************************************!*\
  !*** ./node_modules/faye/src/transport/jsonp.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    copyObject = __webpack_require__(/*! ../util/copy_object */ \"LaPb\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    toJSON = __webpack_require__(/*! ../util/to_json */ \"aF77\"),\n    Transport = __webpack_require__(/*! ./transport */ \"X4bz\");\n\nvar JSONP = extend(Class(Transport, {\n  encode: function (messages) {\n    var url = copyObject(this.endpoint);\n    url.query.message = toJSON(messages);\n    url.query.jsonp = '__jsonp' + JSONP._cbCount + '__';\n    return URI.stringify(url);\n  },\n  request: function (messages) {\n    var head = document.getElementsByTagName('head')[0],\n        script = document.createElement('script'),\n        callbackName = JSONP.getCallbackName(),\n        endpoint = copyObject(this.endpoint),\n        self = this;\n    endpoint.query.message = toJSON(messages);\n    endpoint.query.jsonp = callbackName;\n\n    var cleanup = function () {\n      if (!global[callbackName]) return false;\n      global[callbackName] = undefined;\n\n      try {\n        delete global[callbackName];\n      } catch (error) {}\n\n      script.parentNode.removeChild(script);\n    };\n\n    global[callbackName] = function (replies) {\n      cleanup();\n\n      self._receive(replies);\n    };\n\n    script.type = 'text/javascript';\n    script.src = URI.stringify(endpoint);\n    head.appendChild(script);\n\n    script.onerror = function () {\n      cleanup();\n\n      self._handleError(messages);\n    };\n\n    return {\n      abort: cleanup\n    };\n  }\n}), {\n  _cbCount: 0,\n  getCallbackName: function () {\n    this._cbCount += 1;\n    return '__jsonp' + this._cbCount + '__';\n  },\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    callback.call(context, true);\n  }\n});\nmodule.exports = JSONP;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/jsonp.js?");

/***/ }),

/***/ "bc3L":
/*!*************************************************!*\
  !*** ./node_modules/faye/src/protocol/error.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    Grammar = __webpack_require__(/*! ./grammar */ \"Aj/Y\");\n\nvar Error = Class({\n  initialize: function (code, params, message) {\n    this.code = code;\n    this.params = Array.prototype.slice.call(params);\n    this.message = message;\n  },\n  toString: function () {\n    return this.code + ':' + this.params.join(',') + ':' + this.message;\n  }\n});\n\nError.parse = function (message) {\n  message = message || '';\n  if (!Grammar.ERROR.test(message)) return new Error(null, [], message);\n  var parts = message.split(':'),\n      code = parseInt(parts[0]),\n      params = parts[1].split(','),\n      message = parts[2];\n  return new Error(code, params, message);\n}; // http://code.google.com/p/cometd/wiki/BayeuxCodes\n\n\nvar errors = {\n  versionMismatch: [300, 'Version mismatch'],\n  conntypeMismatch: [301, 'Connection types not supported'],\n  extMismatch: [302, 'Extension mismatch'],\n  badRequest: [400, 'Bad request'],\n  clientUnknown: [401, 'Unknown client'],\n  parameterMissing: [402, 'Missing required parameter'],\n  channelForbidden: [403, 'Forbidden channel'],\n  channelUnknown: [404, 'Unknown channel'],\n  channelInvalid: [405, 'Invalid channel'],\n  extUnknown: [406, 'Unknown extension'],\n  publishFailed: [407, 'Failed to publish'],\n  serverError: [500, 'Internal server error']\n};\n\nfor (var name in errors) (function (name) {\n  Error[name] = function () {\n    return new Error(errors[name][0], arguments, errors[name][1]).toString();\n  };\n})(name);\n\nmodule.exports = Error;\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/error.js?");

/***/ }),

/***/ "bcrl":
/*!*****************************************************!*\
  !*** ./node_modules/faye/src/util/event_emitter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\nCopyright Joyent, Inc. and other Node contributors. All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction indexOf(xs, x) {\n  if (xs.indexOf) return xs.indexOf(x);\n\n  for (var i = 0; i < xs.length; i++) {\n    if (x === xs[i]) return i;\n  }\n\n  return -1;\n}\n\nfunction EventEmitter() {}\n\nmodule.exports = EventEmitter;\n\nEventEmitter.prototype.emit = function (type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length) {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n\n    return true;\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}; // EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\n\n\nEventEmitter.prototype.addListener = function (type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {}; // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function (type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function (type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  } // does not use listeners(), so no side effect of creating _events[type]\n\n\n  if (!this._events || !this._events[type]) return this;\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0) delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function (type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  } // does not use listeners(), so no side effect of creating _events[type]\n\n\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function (type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n\n  return this._events[type];\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/event_emitter.js?");

/***/ }),

/***/ "cYuL":
/*!***************************************************************!*\
  !*** ./node_modules/faye/src/util/cookies/browser_cookies.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/cookies/browser_cookies.js?");

/***/ }),

/***/ "dOC/":
/*!*************************************************!*\
  !*** ./node_modules/faye/src/util/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  VERSION: '1.2.4',\n  BAYEUX_VERSION: '1.0',\n  ID_LENGTH: 160,\n  JSONP_CALLBACK: 'jsonpcallback',\n  CONNECTION_TYPES: ['long-polling', 'cross-origin-long-polling', 'callback-polling', 'websocket', 'eventsource', 'in-process'],\n  MANDATORY_CONNECTION_TYPES: ['long-polling', 'callback-polling', 'in-process']\n};\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/constants.js?");

/***/ }),

/***/ "g0p9":
/*!**************************************************!*\
  !*** ./node_modules/faye/src/protocol/client.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar asap = __webpack_require__(/*! asap */ \"IEa/\"),\n    Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    Promise = __webpack_require__(/*! ../util/promise */ \"1xLH\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    array = __webpack_require__(/*! ../util/array */ \"0spm\"),\n    browser = __webpack_require__(/*! ../util/browser */ \"QK+q\"),\n    constants = __webpack_require__(/*! ../util/constants */ \"dOC/\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    validateOptions = __webpack_require__(/*! ../util/validate_options */ \"Lysv\"),\n    Deferrable = __webpack_require__(/*! ../mixins/deferrable */ \"sBHE\"),\n    Logging = __webpack_require__(/*! ../mixins/logging */ \"pp5c\"),\n    Publisher = __webpack_require__(/*! ../mixins/publisher */ \"Y764\"),\n    Channel = __webpack_require__(/*! ./channel */ \"ReXR\"),\n    Dispatcher = __webpack_require__(/*! ./dispatcher */ \"7Y8a\"),\n    Error = __webpack_require__(/*! ./error */ \"bc3L\"),\n    Extensible = __webpack_require__(/*! ./extensible */ \"wbdT\"),\n    Publication = __webpack_require__(/*! ./publication */ \"57ya\"),\n    Subscription = __webpack_require__(/*! ./subscription */ \"6onv\");\n\nvar Client = Class({\n  className: 'Client',\n  UNCONNECTED: 1,\n  CONNECTING: 2,\n  CONNECTED: 3,\n  DISCONNECTED: 4,\n  HANDSHAKE: 'handshake',\n  RETRY: 'retry',\n  NONE: 'none',\n  CONNECTION_TIMEOUT: 60,\n  DEFAULT_ENDPOINT: '/bayeux',\n  INTERVAL: 0,\n  initialize: function (endpoint, options) {\n    this.info('New client created for ?', endpoint);\n    options = options || {};\n    validateOptions(options, ['interval', 'timeout', 'endpoints', 'proxy', 'retry', 'scheduler', 'websocketExtensions', 'tls', 'ca']);\n    this._channels = new Channel.Set();\n    this._dispatcher = Dispatcher.create(this, endpoint || this.DEFAULT_ENDPOINT, options);\n    this._messageId = 0;\n    this._state = this.UNCONNECTED;\n    this._responseCallbacks = {};\n    this._advice = {\n      reconnect: this.RETRY,\n      interval: 1000 * (options.interval || this.INTERVAL),\n      timeout: 1000 * (options.timeout || this.CONNECTION_TIMEOUT)\n    };\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    this._dispatcher.bind('message', this._receiveMessage, this);\n\n    if (browser.Event && global.onbeforeunload !== undefined) browser.Event.on(global, 'beforeunload', function () {\n      if (array.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0) this.disconnect();\n    }, this);\n  },\n  addWebsocketExtension: function (extension) {\n    return this._dispatcher.addWebsocketExtension(extension);\n  },\n  disable: function (feature) {\n    return this._dispatcher.disable(feature);\n  },\n  setHeader: function (name, value) {\n    return this._dispatcher.setHeader(name, value);\n  },\n  // Request\n  // MUST include:  * channel\n  //                * version\n  //                * supportedConnectionTypes\n  // MAY include:   * minimumVersion\n  //                * ext\n  //                * id\n  //\n  // Success Response                             Failed Response\n  // MUST include:  * channel                     MUST include:  * channel\n  //                * version                                    * successful\n  //                * supportedConnectionTypes                   * error\n  //                * clientId                    MAY include:   * supportedConnectionTypes\n  //                * successful                                 * advice\n  // MAY include:   * minimumVersion                             * version\n  //                * advice                                     * minimumVersion\n  //                * ext                                        * ext\n  //                * id                                         * id\n  //                * authSuccessful\n  handshake: function (callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n    var self = this;\n    this.info('Initiating handshake with ?', URI.stringify(this._dispatcher.endpoint));\n\n    this._dispatcher.selectTransport(constants.MANDATORY_CONNECTION_TYPES);\n\n    this._sendMessage({\n      channel: Channel.HANDSHAKE,\n      version: constants.BAYEUX_VERSION,\n      supportedConnectionTypes: this._dispatcher.getConnectionTypes()\n    }, {}, function (response) {\n      if (response.successful) {\n        this._state = this.CONNECTED;\n        this._dispatcher.clientId = response.clientId;\n\n        this._dispatcher.selectTransport(response.supportedConnectionTypes);\n\n        this.info('Handshake successful: ?', this._dispatcher.clientId);\n        this.subscribe(this._channels.getKeys(), true);\n        if (callback) asap(function () {\n          callback.call(context);\n        });\n      } else {\n        this.info('Handshake unsuccessful');\n        global.setTimeout(function () {\n          self.handshake(callback, context);\n        }, this._dispatcher.retry * 1000);\n        this._state = this.UNCONNECTED;\n      }\n    }, this);\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * connectionType                     * clientId\n  // MAY include:   * ext                 MAY include:   * error\n  //                * id                                 * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  connect: function (callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state === this.DISCONNECTED) return;\n    if (this._state === this.UNCONNECTED) return this.handshake(function () {\n      this.connect(callback, context);\n    }, this);\n    this.callback(callback, context);\n    if (this._state !== this.CONNECTED) return;\n    this.info('Calling deferred actions for ?', this._dispatcher.clientId);\n    this.setDeferredStatus('succeeded');\n    this.setDeferredStatus('unknown');\n    if (this._connectRequest) return;\n    this._connectRequest = true;\n    this.info('Initiating connection for ?', this._dispatcher.clientId);\n\n    this._sendMessage({\n      channel: Channel.CONNECT,\n      clientId: this._dispatcher.clientId,\n      connectionType: this._dispatcher.connectionType\n    }, {}, this._cycleConnection, this);\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  // MAY include:   * ext                                * clientId\n  //                * id                  MAY include:   * error\n  //                                                     * ext\n  //                                                     * id\n  disconnect: function () {\n    if (this._state !== this.CONNECTED) return;\n    this._state = this.DISCONNECTED;\n    this.info('Disconnecting ?', this._dispatcher.clientId);\n    var promise = new Publication();\n\n    this._sendMessage({\n      channel: Channel.DISCONNECT,\n      clientId: this._dispatcher.clientId\n    }, {}, function (response) {\n      if (response.successful) {\n        this._dispatcher.close();\n\n        promise.setDeferredStatus('succeeded');\n      } else {\n        promise.setDeferredStatus('failed', Error.parse(response.error));\n      }\n    }, this);\n\n    this.info('Clearing channel listeners for ?', this._dispatcher.clientId);\n    this._channels = new Channel.Set();\n    return promise;\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  subscribe: function (channel, callback, context) {\n    if (channel instanceof Array) return array.map(channel, function (c) {\n      return this.subscribe(c, callback, context);\n    }, this);\n\n    var subscription = new Subscription(this, channel, callback, context),\n        force = callback === true,\n        hasSubscribe = this._channels.hasSubscription(channel);\n\n    if (hasSubscribe && !force) {\n      this._channels.subscribe([channel], subscription);\n\n      subscription.setDeferredStatus('succeeded');\n      return subscription;\n    }\n\n    this.connect(function () {\n      this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);\n      if (!force) this._channels.subscribe([channel], subscription);\n\n      this._sendMessage({\n        channel: Channel.SUBSCRIBE,\n        clientId: this._dispatcher.clientId,\n        subscription: channel\n      }, {}, function (response) {\n        if (!response.successful) {\n          subscription.setDeferredStatus('failed', Error.parse(response.error));\n          return this._channels.unsubscribe(channel, subscription);\n        }\n\n        var channels = [].concat(response.subscription);\n        this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);\n        subscription.setDeferredStatus('succeeded');\n      }, this);\n    }, this);\n    return subscription;\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  unsubscribe: function (channel, subscription) {\n    if (channel instanceof Array) return array.map(channel, function (c) {\n      return this.unsubscribe(c, subscription);\n    }, this);\n\n    var dead = this._channels.unsubscribe(channel, subscription);\n\n    if (!dead) return;\n    this.connect(function () {\n      this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);\n\n      this._sendMessage({\n        channel: Channel.UNSUBSCRIBE,\n        clientId: this._dispatcher.clientId,\n        subscription: channel\n      }, {}, function (response) {\n        if (!response.successful) return;\n        var channels = [].concat(response.subscription);\n        this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);\n      }, this);\n    }, this);\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * data                               * successful\n  // MAY include:   * clientId            MAY include:   * id\n  //                * id                                 * error\n  //                * ext                                * ext\n  publish: function (channel, data, options) {\n    validateOptions(options || {}, ['attempts', 'deadline']);\n    var publication = new Publication();\n    this.connect(function () {\n      this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);\n\n      this._sendMessage({\n        channel: channel,\n        data: data,\n        clientId: this._dispatcher.clientId\n      }, options, function (response) {\n        if (response.successful) publication.setDeferredStatus('succeeded');else publication.setDeferredStatus('failed', Error.parse(response.error));\n      }, this);\n    }, this);\n    return publication;\n  },\n  _sendMessage: function (message, options, callback, context) {\n    message.id = this._generateMessageId();\n    var timeout = this._advice.timeout ? 1.2 * this._advice.timeout / 1000 : 1.2 * this._dispatcher.retry;\n    this.pipeThroughExtensions('outgoing', message, null, function (message) {\n      if (!message) return;\n      if (callback) this._responseCallbacks[message.id] = [callback, context];\n\n      this._dispatcher.sendMessage(message, timeout, options || {});\n    }, this);\n  },\n  _generateMessageId: function () {\n    this._messageId += 1;\n    if (this._messageId >= Math.pow(2, 32)) this._messageId = 0;\n    return this._messageId.toString(36);\n  },\n  _receiveMessage: function (message) {\n    var id = message.id,\n        callback;\n\n    if (message.successful !== undefined) {\n      callback = this._responseCallbacks[id];\n      delete this._responseCallbacks[id];\n    }\n\n    this.pipeThroughExtensions('incoming', message, null, function (message) {\n      if (!message) return;\n      if (message.advice) this._handleAdvice(message.advice);\n\n      this._deliverMessage(message);\n\n      if (callback) callback[0].call(callback[1], message);\n    }, this);\n  },\n  _handleAdvice: function (advice) {\n    extend(this._advice, advice);\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {\n      this._state = this.UNCONNECTED;\n      this._dispatcher.clientId = null;\n\n      this._cycleConnection();\n    }\n  },\n  _deliverMessage: function (message) {\n    if (!message.channel || message.data === undefined) return;\n    this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);\n\n    this._channels.distributeMessage(message);\n  },\n  _cycleConnection: function () {\n    if (this._connectRequest) {\n      this._connectRequest = null;\n      this.info('Closed connection for ?', this._dispatcher.clientId);\n    }\n\n    var self = this;\n    global.setTimeout(function () {\n      self.connect();\n    }, this._advice.interval);\n  }\n});\nextend(Client.prototype, Deferrable);\nextend(Client.prototype, Publisher);\nextend(Client.prototype, Logging);\nextend(Client.prototype, Extensible);\nmodule.exports = Client;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/client.js?");

/***/ }),

/***/ "g22q":
/*!*******************************************************!*\
  !*** ./node_modules/faye/src/transport/web_socket.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Class = __webpack_require__(/*! ../util/class */ \"NG9E\"),\n    Promise = __webpack_require__(/*! ../util/promise */ \"1xLH\"),\n    Set = __webpack_require__(/*! ../util/set */ \"OByb\"),\n    URI = __webpack_require__(/*! ../util/uri */ \"NqLL\"),\n    browser = __webpack_require__(/*! ../util/browser */ \"QK+q\"),\n    copyObject = __webpack_require__(/*! ../util/copy_object */ \"LaPb\"),\n    extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    toJSON = __webpack_require__(/*! ../util/to_json */ \"aF77\"),\n    ws = __webpack_require__(/*! ../util/websocket */ \"wD8O\"),\n    Deferrable = __webpack_require__(/*! ../mixins/deferrable */ \"sBHE\"),\n    Transport = __webpack_require__(/*! ./transport */ \"X4bz\");\n\nvar WebSocket = extend(Class(Transport, {\n  UNCONNECTED: 1,\n  CONNECTING: 2,\n  CONNECTED: 3,\n  batching: false,\n  isUsable: function (callback, context) {\n    this.callback(function () {\n      callback.call(context, true);\n    });\n    this.errback(function () {\n      callback.call(context, false);\n    });\n    this.connect();\n  },\n  request: function (messages) {\n    this._pending = this._pending || new Set();\n\n    for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);\n\n    var self = this;\n    var promise = new Promise(function (resolve, reject) {\n      self.callback(function (socket) {\n        if (!socket || socket.readyState !== 1) return;\n        socket.send(toJSON(messages));\n        resolve(socket);\n      });\n      self.connect();\n    });\n    return {\n      abort: function () {\n        promise.then(function (ws) {\n          ws.close();\n        });\n      }\n    };\n  },\n  connect: function () {\n    if (WebSocket._unloaded) return;\n    this._state = this._state || this.UNCONNECTED;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n\n    var socket = this._createSocket();\n\n    if (!socket) return this.setDeferredStatus('failed');\n    var self = this;\n\n    socket.onopen = function () {\n      if (socket.headers) self._storeCookies(socket.headers['set-cookie']);\n      self._socket = socket;\n      self._state = self.CONNECTED;\n      self._everConnected = true;\n\n      self._ping();\n\n      self.setDeferredStatus('succeeded', socket);\n    };\n\n    var closed = false;\n\n    socket.onclose = socket.onerror = function () {\n      if (closed) return;\n      closed = true;\n      var wasConnected = self._state === self.CONNECTED;\n      socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;\n      delete self._socket;\n      self._state = self.UNCONNECTED;\n      self.removeTimeout('ping');\n      var pending = self._pending ? self._pending.toArray() : [];\n      delete self._pending;\n\n      if (wasConnected || self._everConnected) {\n        self.setDeferredStatus('unknown');\n\n        self._handleError(pending, wasConnected);\n      } else {\n        self.setDeferredStatus('failed');\n      }\n    };\n\n    socket.onmessage = function (event) {\n      var replies;\n\n      try {\n        replies = JSON.parse(event.data);\n      } catch (error) {}\n\n      if (!replies) return;\n      replies = [].concat(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        if (replies[i].successful === undefined) continue;\n\n        self._pending.remove(replies[i]);\n      }\n\n      self._receive(replies);\n    };\n  },\n  close: function () {\n    if (!this._socket) return;\n\n    this._socket.close();\n  },\n  _createSocket: function () {\n    var url = WebSocket.getSocketUrl(this.endpoint),\n        headers = this._dispatcher.headers,\n        extensions = this._dispatcher.wsExtensions,\n        cookie = this._getCookies(),\n        tls = this._dispatcher.tls,\n        options = {\n      extensions: extensions,\n      headers: headers,\n      proxy: this._proxy,\n      tls: tls\n    };\n\n    if (cookie !== '') options.headers['Cookie'] = cookie;\n    return ws.create(url, [], options);\n  },\n  _ping: function () {\n    if (!this._socket || this._socket.readyState !== 1) return;\n\n    this._socket.send('[]');\n\n    this.addTimeout('ping', this._dispatcher.timeout / 2, this._ping, this);\n  }\n}), {\n  PROTOCOLS: {\n    'http:': 'ws:',\n    'https:': 'wss:'\n  },\n  create: function (dispatcher, endpoint) {\n    var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};\n    sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);\n    return sockets[endpoint.href];\n  },\n  getSocketUrl: function (endpoint) {\n    endpoint = copyObject(endpoint);\n    endpoint.protocol = this.PROTOCOLS[endpoint.protocol];\n    return URI.stringify(endpoint);\n  },\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    this.create(dispatcher, endpoint).isUsable(callback, context);\n  }\n});\nextend(WebSocket.prototype, Deferrable);\nif (browser.Event && global.onbeforeunload !== undefined) browser.Event.on(global, 'beforeunload', function () {\n  WebSocket._unloaded = true;\n});\nmodule.exports = WebSocket;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/web_socket.js?");

/***/ }),

/***/ "hyK+":
/*!***************************************************************!*\
  !*** ./node_modules/faye/src/transport/browser_transports.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Transport = __webpack_require__(/*! ./transport */ \"X4bz\");\n\nTransport.register('websocket', __webpack_require__(/*! ./web_socket */ \"g22q\"));\nTransport.register('eventsource', __webpack_require__(/*! ./event_source */ \"/eTV\"));\nTransport.register('long-polling', __webpack_require__(/*! ./xhr */ \"LmlN\"));\nTransport.register('cross-origin-long-polling', __webpack_require__(/*! ./cors */ \"6CFe\"));\nTransport.register('callback-polling', __webpack_require__(/*! ./jsonp */ \"bMRo\"));\nmodule.exports = Transport;\n\n//# sourceURL=webpack:///./node_modules/faye/src/transport/browser_transports.js?");

/***/ }),

/***/ "ju1d":
/*!***********************************************!*\
  !*** ./node_modules/faye/src/faye_browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./util/constants */ \"dOC/\"),\n    Logging = __webpack_require__(/*! ./mixins/logging */ \"pp5c\");\n\nvar Faye = {\n  VERSION: constants.VERSION,\n  Client: __webpack_require__(/*! ./protocol/client */ \"g0p9\"),\n  Scheduler: __webpack_require__(/*! ./protocol/scheduler */ \"SuKS\")\n};\nLogging.wrapper = Faye;\nmodule.exports = Faye;\n\n//# sourceURL=webpack:///./node_modules/faye/src/faye_browser.js?");

/***/ }),

/***/ "pp5c":
/*!*************************************************!*\
  !*** ./node_modules/faye/src/mixins/logging.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toJSON = __webpack_require__(/*! ../util/to_json */ \"aF77\");\n\nvar Logging = {\n  LOG_LEVELS: {\n    fatal: 4,\n    error: 3,\n    warn: 2,\n    info: 1,\n    debug: 0\n  },\n  writeLog: function (messageArgs, level) {\n    var logger = Logging.logger || (Logging.wrapper || Logging).logger;\n    if (!logger) return;\n    var args = Array.prototype.slice.apply(messageArgs),\n        banner = '[Faye',\n        klass = this.className,\n        message = args.shift().replace(/\\?/g, function () {\n      try {\n        return toJSON(args.shift());\n      } catch (error) {\n        return '[Object]';\n      }\n    });\n    if (klass) banner += '.' + klass;\n    banner += '] ';\n    if (typeof logger[level] === 'function') logger[level](banner + message);else if (typeof logger === 'function') logger(banner + message);\n  }\n};\n\nfor (var key in Logging.LOG_LEVELS) (function (level) {\n  Logging[level] = function () {\n    this.writeLog(arguments, level);\n  };\n})(key);\n\nmodule.exports = Logging;\n\n//# sourceURL=webpack:///./node_modules/faye/src/mixins/logging.js?");

/***/ }),

/***/ "sBHE":
/*!****************************************************!*\
  !*** ./node_modules/faye/src/mixins/deferrable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Promise = __webpack_require__(/*! ../util/promise */ \"1xLH\");\n\nmodule.exports = {\n  then: function (callback, errback) {\n    var self = this;\n    if (!this._promise) this._promise = new Promise(function (resolve, reject) {\n      self._resolve = resolve;\n      self._reject = reject;\n    });\n    if (arguments.length === 0) return this._promise;else return this._promise.then(callback, errback);\n  },\n  callback: function (callback, context) {\n    return this.then(function (value) {\n      callback.call(context, value);\n    });\n  },\n  errback: function (callback, context) {\n    return this.then(null, function (reason) {\n      callback.call(context, reason);\n    });\n  },\n  timeout: function (seconds, message) {\n    this.then();\n    var self = this;\n    this._timer = global.setTimeout(function () {\n      self._reject(message);\n    }, seconds * 1000);\n  },\n  setDeferredStatus: function (status, value) {\n    if (this._timer) global.clearTimeout(this._timer);\n    this.then();\n    if (status === 'succeeded') this._resolve(value);else if (status === 'failed') this._reject(value);else delete this._promise;\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/mixins/deferrable.js?");

/***/ }),

/***/ "wD8O":
/*!*******************************************************************!*\
  !*** ./node_modules/faye/src/util/websocket/browser_websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar WS = global.MozWebSocket || global.WebSocket;\nmodule.exports = {\n  create: function (url, protocols, options) {\n    if (typeof WS !== 'function') return null;\n    return new WS(url);\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"yLpj\")))\n\n//# sourceURL=webpack:///./node_modules/faye/src/util/websocket/browser_websocket.js?");

/***/ }),

/***/ "wbdT":
/*!******************************************************!*\
  !*** ./node_modules/faye/src/protocol/extensible.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar extend = __webpack_require__(/*! ../util/extend */ \"aR6h\"),\n    Logging = __webpack_require__(/*! ../mixins/logging */ \"pp5c\");\n\nvar Extensible = {\n  addExtension: function (extension) {\n    this._extensions = this._extensions || [];\n\n    this._extensions.push(extension);\n\n    if (extension.added) extension.added(this);\n  },\n  removeExtension: function (extension) {\n    if (!this._extensions) return;\n    var i = this._extensions.length;\n\n    while (i--) {\n      if (this._extensions[i] !== extension) continue;\n\n      this._extensions.splice(i, 1);\n\n      if (extension.removed) extension.removed(this);\n    }\n  },\n  pipeThroughExtensions: function (stage, message, request, callback, context) {\n    this.debug('Passing through ? extensions: ?', stage, message);\n    if (!this._extensions) return callback.call(context, message);\n\n    var extensions = this._extensions.slice();\n\n    var pipe = function (message) {\n      if (!message) return callback.call(context, message);\n      var extension = extensions.shift();\n      if (!extension) return callback.call(context, message);\n      var fn = extension[stage];\n      if (!fn) return pipe(message);\n      if (fn.length >= 3) extension[stage](message, request, pipe);else extension[stage](message, pipe);\n    };\n\n    pipe(message);\n  }\n};\nextend(Extensible, Logging);\nmodule.exports = Extensible;\n\n//# sourceURL=webpack:///./node_modules/faye/src/protocol/extensible.js?");

/***/ })

}]);