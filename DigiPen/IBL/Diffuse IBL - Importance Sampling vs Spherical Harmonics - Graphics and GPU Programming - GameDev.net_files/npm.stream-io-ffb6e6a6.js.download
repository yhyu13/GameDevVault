(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.stream-io"],{

/***/ "QGad":
/*!**********************************************************************!*\
  !*** ./node_modules/@stream-io/cross-fetch/dist/browser-ponyfill.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var realFetch = this && this.fetch;\n\nvar __root__ = function (root) {\n  function F() {\n    this.fetch = false;\n  }\n\n  F.prototype = root;\n  return new F();\n}(typeof self !== 'undefined' ? self : this);\n\n(function (self) {\n  var irrelevant = function (exports) {\n    var support = {\n      searchParams: 'URLSearchParams' in self,\n      iterable: 'Symbol' in self && 'iterator' in Symbol,\n      blob: 'FileReader' in self && 'Blob' in self && function () {\n        try {\n          new Blob();\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }(),\n      formData: 'FormData' in self,\n      arrayBuffer: 'ArrayBuffer' in self\n    };\n\n    function isDataView(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj);\n    }\n\n    if (support.arrayBuffer) {\n      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n\n      var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n      };\n    }\n\n    function normalizeName(name) {\n      if (typeof name !== 'string') {\n        name = String(name);\n      }\n\n      if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n        throw new TypeError('Invalid character in header field name');\n      }\n\n      return name.toLowerCase();\n    }\n\n    function normalizeValue(value) {\n      if (typeof value !== 'string') {\n        value = String(value);\n      }\n\n      return value;\n    } // Build a destructive iterator for the value list\n\n\n    function iteratorFor(items) {\n      var iterator = {\n        next: function () {\n          var value = items.shift();\n          return {\n            done: value === undefined,\n            value: value\n          };\n        }\n      };\n\n      if (support.iterable) {\n        iterator[Symbol.iterator] = function () {\n          return iterator;\n        };\n      }\n\n      return iterator;\n    }\n\n    function Headers(headers) {\n      this.map = {};\n\n      if (headers instanceof Headers) {\n        headers.forEach(function (value, name) {\n          this.append(name, value);\n        }, this);\n      } else if (Array.isArray(headers)) {\n        headers.forEach(function (header) {\n          this.append(header[0], header[1]);\n        }, this);\n      } else if (headers) {\n        Object.getOwnPropertyNames(headers).forEach(function (name) {\n          this.append(name, headers[name]);\n        }, this);\n      }\n    }\n\n    Headers.prototype.append = function (name, value) {\n      name = normalizeName(name);\n      value = normalizeValue(value);\n      var oldValue = this.map[name];\n      this.map[name] = oldValue ? oldValue + ', ' + value : value;\n    };\n\n    Headers.prototype['delete'] = function (name) {\n      delete this.map[normalizeName(name)];\n    };\n\n    Headers.prototype.get = function (name) {\n      name = normalizeName(name);\n      return this.has(name) ? this.map[name] : null;\n    };\n\n    Headers.prototype.has = function (name) {\n      return this.map.hasOwnProperty(normalizeName(name));\n    };\n\n    Headers.prototype.set = function (name, value) {\n      this.map[normalizeName(name)] = normalizeValue(value);\n    };\n\n    Headers.prototype.forEach = function (callback, thisArg) {\n      for (var name in this.map) {\n        if (this.map.hasOwnProperty(name)) {\n          callback.call(thisArg, this.map[name], name, this);\n        }\n      }\n    };\n\n    Headers.prototype.keys = function () {\n      var items = [];\n      this.forEach(function (value, name) {\n        items.push(name);\n      });\n      return iteratorFor(items);\n    };\n\n    Headers.prototype.values = function () {\n      var items = [];\n      this.forEach(function (value) {\n        items.push(value);\n      });\n      return iteratorFor(items);\n    };\n\n    Headers.prototype.entries = function () {\n      var items = [];\n      this.forEach(function (value, name) {\n        items.push([name, value]);\n      });\n      return iteratorFor(items);\n    };\n\n    if (support.iterable) {\n      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n    }\n\n    function consumed(body) {\n      if (body.bodyUsed) {\n        return Promise.reject(new TypeError('Already read'));\n      }\n\n      body.bodyUsed = true;\n    }\n\n    function fileReaderReady(reader) {\n      return new Promise(function (resolve, reject) {\n        reader.onload = function () {\n          resolve(reader.result);\n        };\n\n        reader.onerror = function () {\n          reject(reader.error);\n        };\n      });\n    }\n\n    function readBlobAsArrayBuffer(blob) {\n      var reader = new FileReader();\n      var promise = fileReaderReady(reader);\n      reader.readAsArrayBuffer(blob);\n      return promise;\n    }\n\n    function readBlobAsText(blob) {\n      var reader = new FileReader();\n      var promise = fileReaderReady(reader);\n      reader.readAsText(blob);\n      return promise;\n    }\n\n    function readArrayBufferAsText(buf) {\n      var view = new Uint8Array(buf);\n      var chars = new Array(view.length);\n\n      for (var i = 0; i < view.length; i++) {\n        chars[i] = String.fromCharCode(view[i]);\n      }\n\n      return chars.join('');\n    }\n\n    function bufferClone(buf) {\n      if (buf.slice) {\n        return buf.slice(0);\n      } else {\n        var view = new Uint8Array(buf.byteLength);\n        view.set(new Uint8Array(buf));\n        return view.buffer;\n      }\n    }\n\n    function Body() {\n      this.bodyUsed = false;\n\n      this._initBody = function (body) {\n        this._bodyInit = body;\n\n        if (!body) {\n          this._bodyText = '';\n        } else if (typeof body === 'string') {\n          this._bodyText = body;\n        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n          this._bodyBlob = body;\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n          this._bodyFormData = body;\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this._bodyText = body.toString();\n        } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n          this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.\n\n          this._bodyInit = new Blob([this._bodyArrayBuffer]);\n        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n          this._bodyArrayBuffer = bufferClone(body);\n        } else {\n          this._bodyText = body = Object.prototype.toString.call(body);\n        }\n\n        if (!this.headers.get('content-type')) {\n          if (typeof body === 'string') {\n            this.headers.set('content-type', 'text/plain;charset=UTF-8');\n          } else if (this._bodyBlob && this._bodyBlob.type) {\n            this.headers.set('content-type', this._bodyBlob.type);\n          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n          }\n        }\n      };\n\n      if (support.blob) {\n        this.blob = function () {\n          var rejected = consumed(this);\n\n          if (rejected) {\n            return rejected;\n          }\n\n          if (this._bodyBlob) {\n            return Promise.resolve(this._bodyBlob);\n          } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n          } else if (this._bodyFormData) {\n            throw new Error('could not read FormData body as blob');\n          } else {\n            return Promise.resolve(new Blob([this._bodyText]));\n          }\n        };\n\n        this.arrayBuffer = function () {\n          if (this._bodyArrayBuffer) {\n            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n          } else {\n            return this.blob().then(readBlobAsArrayBuffer);\n          }\n        };\n      }\n\n      this.text = function () {\n        var rejected = consumed(this);\n\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text');\n        } else {\n          return Promise.resolve(this._bodyText);\n        }\n      };\n\n      if (support.formData) {\n        this.formData = function () {\n          return this.text().then(decode);\n        };\n      }\n\n      this.json = function () {\n        return this.text().then(JSON.parse);\n      };\n\n      return this;\n    } // HTTP methods whose capitalization should be normalized\n\n\n    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n    function normalizeMethod(method) {\n      var upcased = method.toUpperCase();\n      return methods.indexOf(upcased) > -1 ? upcased : method;\n    }\n\n    function Request(input, options) {\n      options = options || {};\n      var body = options.body;\n\n      if (input instanceof Request) {\n        if (input.bodyUsed) {\n          throw new TypeError('Already read');\n        }\n\n        this.url = input.url;\n        this.credentials = input.credentials;\n\n        if (!options.headers) {\n          this.headers = new Headers(input.headers);\n        }\n\n        this.method = input.method;\n        this.mode = input.mode;\n        this.signal = input.signal;\n\n        if (!body && input._bodyInit != null) {\n          body = input._bodyInit;\n          input.bodyUsed = true;\n        }\n      } else {\n        this.url = String(input);\n      }\n\n      this.credentials = options.credentials || this.credentials || 'same-origin';\n\n      if (options.headers || !this.headers) {\n        this.headers = new Headers(options.headers);\n      }\n\n      this.method = normalizeMethod(options.method || this.method || 'GET');\n      this.mode = options.mode || this.mode || null;\n      this.signal = options.signal || this.signal;\n      this.referrer = null;\n\n      if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n        throw new TypeError('Body not allowed for GET or HEAD requests');\n      }\n\n      this._initBody(body);\n    }\n\n    Request.prototype.clone = function () {\n      return new Request(this, {\n        body: this._bodyInit\n      });\n    };\n\n    function decode(body) {\n      var form = new FormData();\n      body.trim().split('&').forEach(function (bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n      return form;\n    }\n\n    function parseHeaders(rawHeaders) {\n      var headers = new Headers(); // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n      // https://tools.ietf.org/html/rfc7230#section-3.2\n\n      var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n      preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\n        var parts = line.split(':');\n        var key = parts.shift().trim();\n\n        if (key) {\n          var value = parts.join(':').trim();\n          headers.append(key, value);\n        }\n      });\n      return headers;\n    }\n\n    Body.call(Request.prototype);\n\n    function Response(bodyInit, options) {\n      if (!options) {\n        options = {};\n      }\n\n      this.type = 'default';\n      this.status = options.status === undefined ? 200 : options.status;\n      this.ok = this.status >= 200 && this.status < 300;\n      this.statusText = 'statusText' in options ? options.statusText : 'OK';\n      this.headers = new Headers(options.headers);\n      this.url = options.url || '';\n\n      this._initBody(bodyInit);\n    }\n\n    Body.call(Response.prototype);\n\n    Response.prototype.clone = function () {\n      return new Response(this._bodyInit, {\n        status: this.status,\n        statusText: this.statusText,\n        headers: new Headers(this.headers),\n        url: this.url\n      });\n    };\n\n    Response.error = function () {\n      var response = new Response(null, {\n        status: 0,\n        statusText: ''\n      });\n      response.type = 'error';\n      return response;\n    };\n\n    var redirectStatuses = [301, 302, 303, 307, 308];\n\n    Response.redirect = function (url, status) {\n      if (redirectStatuses.indexOf(status) === -1) {\n        throw new RangeError('Invalid status code');\n      }\n\n      return new Response(null, {\n        status: status,\n        headers: {\n          location: url\n        }\n      });\n    };\n\n    exports.DOMException = self.DOMException;\n\n    try {\n      new exports.DOMException();\n    } catch (err) {\n      exports.DOMException = function (message, name) {\n        this.message = message;\n        this.name = name;\n        var error = Error(message);\n        this.stack = error.stack;\n      };\n\n      exports.DOMException.prototype = Object.create(Error.prototype);\n      exports.DOMException.prototype.constructor = exports.DOMException;\n    }\n\n    function fetch(input, init) {\n      return new Promise(function (resolve, reject) {\n        var request = new Request(input, init);\n\n        if (request.signal && request.signal.aborted) {\n          return reject(new exports.DOMException('Aborted', 'AbortError'));\n        }\n\n        var xhr = new XMLHttpRequest();\n\n        function abortXhr() {\n          xhr.abort();\n        }\n\n        xhr.onload = function () {\n          var options = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n            headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n          };\n          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n          var body = 'response' in xhr ? xhr.response : xhr.responseText;\n          resolve(new Response(body, options));\n        };\n\n        xhr.onerror = function () {\n          reject(new TypeError('Network request failed'));\n        };\n\n        xhr.ontimeout = function () {\n          reject(new TypeError('Network request failed'));\n        };\n\n        xhr.onabort = function () {\n          reject(new exports.DOMException('Aborted', 'AbortError'));\n        };\n\n        xhr.open(request.method, request.url, true);\n\n        if (request.credentials === 'include') {\n          xhr.withCredentials = true;\n        } else if (request.credentials === 'omit') {\n          xhr.withCredentials = false;\n        }\n\n        if ('responseType' in xhr && support.blob) {\n          xhr.responseType = 'blob';\n        }\n\n        request.headers.forEach(function (value, name) {\n          xhr.setRequestHeader(name, value);\n        });\n\n        if (request.signal) {\n          request.signal.addEventListener('abort', abortXhr);\n\n          xhr.onreadystatechange = function () {\n            // DONE (success or failure)\n            if (xhr.readyState === 4) {\n              request.signal.removeEventListener('abort', abortXhr);\n            }\n          };\n        }\n\n        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n      });\n    }\n\n    fetch.polyfill = true;\n\n    if (!self.fetch) {\n      self.fetch = fetch;\n      self.Headers = Headers;\n      self.Request = Request;\n      self.Response = Response;\n    }\n\n    exports.Headers = Headers;\n    exports.Request = Request;\n    exports.Response = Response;\n    exports.fetch = fetch;\n    return exports;\n  }({});\n})(__root__);\n\ndelete __root__.fetch.polyfill;\nmodule.exports = exports = __root__.fetch;\nexports.fetch = __root__.fetch;\nexports.Headers = __root__.Headers;\nexports.Request = __root__.Request;\nexports.Response = __root__.Response; // Needed for TypeScript consumers without esModuleInterop.\n\nexports.default = __root__.fetch;\n\n//# sourceURL=webpack:///./node_modules/@stream-io/cross-fetch/dist/browser-ponyfill.js?");

/***/ }),

/***/ "jUTl":
/*!**********************************************************!*\
  !*** ./node_modules/@stream-io/xmlhttp-request/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Browser Request\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar XHR = XMLHttpRequest;\nif (!XHR) throw new Error('missing XMLHttpRequest');\nrequest.log = {\n  'trace': noop,\n  'debug': noop,\n  'info': noop,\n  'warn': noop,\n  'error': noop\n};\nvar DEFAULT_TIMEOUT = 3 * 60 * 1000; // 3 minutes\n//\n// PolyFill\n// \n// Production steps of ECMA-262, Edition 5, 15.4.4.18\n// Reference: http://es5.github.io/#x15.4.4.18\n\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function (callback, thisArg) {\n    var T, k;\n\n    if (this === null) {\n      throw new TypeError(' this is null or not defined');\n    } // 1. Let O be the result of calling toObject() passing the\n    // |this| value as the argument.\n\n\n    var O = Object(this); // 2. Let lenValue be the result of calling the Get() internal\n    // method of O with the argument \"length\".\n    // 3. Let len be toUint32(lenValue).\n\n    var len = O.length >>> 0; // 4. If isCallable(callback) is false, throw a TypeError exception. \n    // See: http://es5.github.com/#x9.11\n\n    if (typeof callback !== \"function\") {\n      throw new TypeError(callback + ' is not a function');\n    } // 5. If thisArg was supplied, let T be thisArg; else let\n    // T be undefined.\n\n\n    if (arguments.length > 1) {\n      T = thisArg;\n    } // 6. Let k be 0\n\n\n    k = 0; // 7. Repeat, while k < len\n\n    while (k < len) {\n      var kValue; // a. Let Pk be ToString(k).\n      //    This is implicit for LHS operands of the in operator\n      // b. Let kPresent be the result of calling the HasProperty\n      //    internal method of O with argument Pk.\n      //    This step can be combined with c\n      // c. If kPresent is true, then\n\n      if (k in O) {\n        // i. Let kValue be the result of calling the Get internal\n        // method of O with argument Pk.\n        kValue = O[k]; // ii. Call the Call internal method of callback with T as\n        // the this value and argument list containing kValue, k, and O.\n\n        callback.call(T, kValue, k, O);\n      } // d. Increase k by 1.\n\n\n      k++;\n    } // 8. return undefined\n\n  };\n} //\n// request\n//\n\n\nfunction request(options, callback) {\n  // The entry-point to the API: prep the options object and pass the real work to run_xhr.\n  if (typeof callback !== 'function') throw new Error('Bad callback given: ' + callback);\n  if (!options) throw new Error('No options given');\n  var options_onResponse = options.onResponse; // Save this for later.\n\n  if (typeof options === 'string') options = {\n    'uri': options\n  };else options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.\n\n  options.onResponse = options_onResponse; // And put it back.\n\n  if (options.verbose) request.log = getLogger();\n\n  if (options.url) {\n    options.uri = options.url;\n    delete options.url;\n  }\n\n  if (!options.uri && options.uri !== \"\") throw new Error(\"options.uri is a required argument\");\n  if (typeof options.uri != \"string\") throw new Error(\"options.uri must be a string\");\n  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect'];\n\n  for (var i = 0; i < unsupported_options.length; i++) if (options[unsupported_options[i]]) throw new Error(\"options.\" + unsupported_options[i] + \" is not supported\");\n\n  options.callback = callback;\n  options.method = options.method || 'GET';\n  options.headers = options.headers || {};\n  options.body = options.body || null;\n  options.timeout = options.timeout || request.DEFAULT_TIMEOUT;\n  if (options.headers.host) throw new Error(\"Options.headers.host is not supported\");\n\n  if (options.json) {\n    options.headers.accept = options.headers.accept || 'application/json';\n    if (options.method !== 'GET') options.headers['content-type'] = 'application/json';\n    if (typeof options.json !== 'boolean') options.body = JSON.stringify(options.json);else if (typeof options.body !== 'string' && options.body !== null) options.body = JSON.stringify(options.body);\n  } //BEGIN QS Hack\n\n\n  var serialize = function (obj) {\n    var str = [];\n\n    for (var p in obj) if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(obj[p]));\n    }\n\n    return str.join(\"&\");\n  };\n\n  if (options.qs) {\n    var qs = typeof options.qs == 'string' ? options.qs : serialize(options.qs);\n\n    if (options.uri.indexOf('?') !== -1) {\n      //no get params\n      options.uri = options.uri + '&' + qs;\n    } else {\n      //existing get params\n      options.uri = options.uri + '?' + qs;\n    }\n  } //END QS Hack\n  //BEGIN FORM Hack\n\n\n  var multipart = function (obj) {\n    //todo: support file type (useful?)\n    var result = {};\n    result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);\n    var lines = [];\n\n    for (var p in obj) {\n      if (obj.hasOwnProperty(p)) {\n        lines.push('--' + result.boundry + \"\\n\" + 'Content-Disposition: form-data; name=\"' + p + '\"' + \"\\n\" + \"\\n\" + obj[p] + \"\\n\");\n      }\n    }\n\n    lines.push('--' + result.boundry + '--');\n    result.body = lines.join('');\n    result.length = result.body.length;\n    result.type = 'multipart/form-data; boundary=' + result.boundry;\n    return result;\n  };\n\n  if (options.form) {\n    if (typeof options.form == 'string') throw 'form name unsupported';\n\n    if (options.method === 'POST') {\n      var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();\n      options.headers['content-type'] = encoding;\n\n      switch (encoding) {\n        case 'application/x-www-form-urlencoded':\n          options.body = serialize(options.form).replace(/%20/g, \"+\");\n          break;\n\n        case 'multipart/form-data':\n          var multi = multipart(options.form); //options.headers['content-length'] = multi.length;\n\n          options.body = multi.body;\n          options.headers['content-type'] = multi.type;\n          break;\n\n        default:\n          throw new Error('unsupported encoding:' + encoding);\n      }\n    }\n  } //END FORM Hack\n  // If onResponse is boolean true, call back immediately when the response is known,\n  // not when the full request is complete.\n\n\n  options.onResponse = options.onResponse || noop;\n\n  if (options.onResponse === true) {\n    options.onResponse = callback;\n    options.callback = noop;\n  } // XXX Browsers do not like this.\n  //if(options.body)\n  //  options.headers['content-length'] = options.body.length;\n  // HTTP basic authentication\n\n\n  if (!options.headers.authorization && options.auth) options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);\n  return run_xhr(options);\n}\n\nvar req_seq = 0;\n\nfunction run_xhr(options) {\n  var xhr = new XHR(),\n      timed_out = false,\n      is_cors = is_crossDomain(options.uri),\n      supports_cors = ('withCredentials' in xhr);\n  req_seq += 1;\n  xhr.seq_id = req_seq;\n  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;\n  xhr._id = xhr.id; // I know I will type \"_id\" from habit all the time.\n\n  if (is_cors && !supports_cors) {\n    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);\n    cors_err.cors = 'unsupported';\n    return options.callback(cors_err, xhr);\n  }\n\n  xhr.timeoutTimer = setTimeout(too_late, options.timeout);\n\n  function too_late() {\n    timed_out = true;\n    var er = new Error('ETIMEDOUT');\n    er.code = 'ETIMEDOUT';\n    er.duration = options.timeout;\n    request.log.error('Timeout', {\n      'id': xhr._id,\n      'milliseconds': options.timeout\n    });\n    return options.callback(er, xhr);\n  } // Some states can be skipped over, so remember what is still incomplete.\n\n\n  var did = {\n    'response': false,\n    'loading': false,\n    'end': false\n  };\n  xhr.onreadystatechange = on_state_change;\n  xhr.open(options.method, options.uri, true); // asynchronous\n\n  if (is_cors) xhr.withCredentials = !!options.withCredentials;\n\n  for (var key in options.headers) xhr.setRequestHeader(key, options.headers[key]);\n\n  xhr.send(options.body);\n  return xhr;\n\n  function on_state_change(event) {\n    if (timed_out) return request.log.debug('Ignoring timed out state change', {\n      'state': xhr.readyState,\n      'id': xhr.id\n    });\n    request.log.debug('State change', {\n      'state': xhr.readyState,\n      'id': xhr.id,\n      'timed_out': timed_out\n    });\n\n    if (xhr.readyState === 1) {\n      request.log.debug('Request started', {\n        'id': xhr.id\n      });\n    } else if (xhr.readyState === 2) on_response();else if (xhr.readyState === 3) {\n      on_response();\n      on_loading();\n    } else if (xhr.readyState === 4) {\n      on_response();\n      on_loading();\n      on_end();\n    }\n  }\n\n  function on_response() {\n    if (did.response) return;\n    did.response = true;\n    request.log.debug('Got response', {\n      'id': xhr.id,\n      'status': xhr.status\n    });\n    clearTimeout(xhr.timeoutTimer);\n    xhr.statusCode = xhr.status; // Node request compatibility\n    // Detect failed CORS requests.\n\n    if (is_cors && xhr.statusCode == 0) {\n      var cors_err = new Error('CORS request rejected: ' + options.uri);\n      cors_err.cors = 'rejected'; // Do not process this request further.\n\n      did.loading = true;\n      did.end = true;\n      return options.callback(cors_err, xhr);\n    }\n\n    options.onResponse(null, xhr);\n  }\n\n  function on_loading() {\n    if (did.loading) return;\n    did.loading = true;\n    request.log.debug('Response body loading', {\n      'id': xhr.id\n    }); // TODO: Maybe simulate \"data\" events by watching xhr.responseText\n  }\n\n  function on_end() {\n    if (did.end) return;\n    did.end = true;\n    request.log.debug('Request done', {\n      'id': xhr.id\n    });\n    xhr.body = xhr.responseText;\n\n    if (options.json) {\n      try {\n        xhr.body = JSON.parse(xhr.responseText);\n      } catch (er) {\n        return options.callback(er, xhr);\n      }\n    }\n\n    options.callback(null, xhr, xhr.body);\n  }\n} // request\n\n\nrequest.withCredentials = false;\nrequest.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT; //\n// defaults\n//\n\nrequest.defaults = function (options, requester) {\n  var def = function (method) {\n    var d = function (params, callback) {\n      if (typeof params === 'string') params = {\n        'uri': params\n      };else {\n        params = JSON.parse(JSON.stringify(params));\n      }\n\n      for (var i in options) {\n        if (params[i] === undefined) params[i] = options[i];\n      }\n\n      return method(params, callback);\n    };\n\n    return d;\n  };\n\n  var de = def(request);\n  de.get = def(request.get);\n  de.post = def(request.post);\n  de.put = def(request.put);\n  de.head = def(request.head);\n  return de;\n}; //\n// HTTP method shortcuts\n//\n\n\nvar shortcuts = ['get', 'put', 'post', 'head'];\nshortcuts.forEach(function (shortcut) {\n  var method = shortcut.toUpperCase();\n  var func = shortcut.toLowerCase();\n\n  request[func] = function (opts) {\n    if (typeof opts === 'string') opts = {\n      'method': method,\n      'uri': opts\n    };else {\n      opts = JSON.parse(JSON.stringify(opts));\n      opts.method = method;\n    }\n    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));\n    return request.apply(this, args);\n  };\n}); //\n// CouchDB shortcut\n//\n\nrequest.couch = function (options, callback) {\n  if (typeof options === 'string') options = {\n    'uri': options\n  }; // Just use the request API to do JSON.\n\n  options.json = true;\n  if (options.body) options.json = options.body;\n  delete options.body;\n  callback = callback || noop;\n  var xhr = request(options, couch_handler);\n  return xhr;\n\n  function couch_handler(er, resp, body) {\n    if (er) return callback(er, resp, body);\n\n    if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {\n      // The body is a Couch JSON object indicating the error.\n      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));\n\n      for (var key in body) er[key] = body[key];\n\n      return callback(er, resp, body);\n    }\n\n    return callback(er, resp, body);\n  }\n}; //\n// Utility\n//\n\n\nfunction noop() {}\n\nfunction getLogger() {\n  var logger = {},\n      levels = ['trace', 'debug', 'info', 'warn', 'error'],\n      level,\n      i;\n\n  for (i = 0; i < levels.length; i++) {\n    level = levels[i];\n    logger[level] = noop;\n    if (typeof console !== 'undefined' && console && console[level]) logger[level] = formatted(console, level);\n  }\n\n  return logger;\n}\n\nfunction formatted(obj, method) {\n  return formatted_logger;\n\n  function formatted_logger(str, context) {\n    if (typeof context === 'object') str += ' ' + JSON.stringify(context);\n    return obj[method].call(obj, str);\n  }\n} // Return whether a URL is a cross-domain request.\n\n\nfunction is_crossDomain(url) {\n  // Fix for React Native. CORS does noet exist in that environment\n  if (navigator && navigator.product === 'ReactNative') {\n    return false;\n  }\n\n  var rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/; // jQuery #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n\n  var ajaxLocation;\n\n  try {\n    ajaxLocation = location.href;\n  } catch (e) {\n    // Use the href attribute of an A element since IE will modify it given document.location\n    ajaxLocation = document.createElement(\"a\");\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  }\n\n  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [],\n      parts = rurl.exec(url.toLowerCase());\n  var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443)))); //console.debug('is_crossDomain('+url+') -> ' + result)\n\n  return result;\n} // MIT License from http://phpjs.org/functions/base64_encode:358\n\n\nfunction b64_enc(data) {\n  // Encodes string using MIME base64 algorithm\n  var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  var o1,\n      o2,\n      o3,\n      h1,\n      h2,\n      h3,\n      h4,\n      bits,\n      i = 0,\n      ac = 0,\n      enc = \"\",\n      tmp_arr = [];\n\n  if (!data) {\n    return data;\n  } // assume utf8 data\n  // data = this.utf8_encode(data+'');\n\n\n  do {\n    // pack three octets into four hexets\n    o1 = data.charCodeAt(i++);\n    o2 = data.charCodeAt(i++);\n    o3 = data.charCodeAt(i++);\n    bits = o1 << 16 | o2 << 8 | o3;\n    h1 = bits >> 18 & 0x3f;\n    h2 = bits >> 12 & 0x3f;\n    h3 = bits >> 6 & 0x3f;\n    h4 = bits & 0x3f; // use hexets to index into b64, and append result to encoded string\n\n    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n  } while (i < data.length);\n\n  enc = tmp_arr.join('');\n\n  switch (data.length % 3) {\n    case 1:\n      enc = enc.slice(0, -2) + '==';\n      break;\n\n    case 2:\n      enc = enc.slice(0, -1) + '=';\n      break;\n  }\n\n  return enc;\n}\n\nmodule.exports = request;\n\n//# sourceURL=webpack:///./node_modules/@stream-io/xmlhttp-request/index.js?");

/***/ })

}]);