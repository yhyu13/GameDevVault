<!DOCTYPE html>
<!-- saved from url=(0084)https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#the_physics_of_lens-flares -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Custom Lens-Flare Post-Process in Unreal Engine | Froyok - Fabrice Piquet</title>
<link href="https://gmpg.org/xfn/11" rel="profile">
<link href="https://www.froyok.fr//common/favicon.ico" rel="shortcut icon" sizes="32x32" type="image/x-icon">
<link href="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/style.css" rel="stylesheet" type="text/css">
<link href="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/code.css" rel="stylesheet" type="text/css">
<link as="style" href="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/css" onload="this.rel=&#39;stylesheet&#39;" rel="stylesheet">
<link as="style" href="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/css(1)" onload="this.rel=&#39;stylesheet&#39;" rel="stylesheet">

<meta content="width=device-width, initial-scale=1.0" name="viewport">
<meta content="Froyok" name="Author">
<meta content="Portfolio and Blog about realtime 3D creations and tutorials by Froyok" name="Description">
<meta content="froyok, fabrice, piquet, tutorial, tutorials, breakdown, articles, dev, gamedev, computer graphics, shaders, rendering, unreal, engine, ue4, realtime, adobe" name="Keywords">
<meta content="This article shows how to modify the default Unreal Engine lens-flare post-process, from code to shaders. I always wanted to chang..." property="og:description">
<meta content="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/unfurl.jpg" property="og:image">
<meta content="This article shows how to modify the default Unreal Engine lens-flare post-process, from code to shaders. I always wanted to chang..." name="twitter:description" property="twitter:description">
<meta content="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/unfurl.jpg" name="twitter:image" property="twitter:image">
<meta content="Custom Lens-Flare Post-Process in Unreal Engine | Froyok - Fabrice Piquet" property="og:title">
<meta content="https://www.froyok.fr" property="og:url">
<meta content="Custom Lens-Flare Post-Process in Unreal Engine | Froyok - Fabrice Piquet" name="twitter:title" property="twitter:title">
<meta content="https://www.froyok.fr" name="twitter:domain" property="twitter:domain">
<meta content="summary_large_image" name="twitter:card">
</head>
<body>
<img alt="background" id="header-background-fade-preload" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/gradient_cover.webp" style="z-index: -10; position: absolute">
<a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/" id="page-top"></a>
<div id="header-background-area">
<img alt="unfurl" id="header-background-image-resource" rel="preload" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/unfurl.jpg">
<div id="header-background-gradient"></div>
<div id="header-background-fade"></div>
<div id="main-header">
<img alt="" id="main-logo" rel="preload" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/lena.webp">
<div id="main-header-logo-link">
<a class="logo-link" href="https://twitter.com/froyok" target="_blank">
<img alt="logo" id="logo-link-twitter" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/twitter.svg">
</a>
<a class="logo-link" href="https://discord.gg/TGcKf4ZbNR" target="_blank">
<img alt="logo" id="logo-link-discord" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/discord.svg">
</a>
</div>
<div id="main-header-text">
<a class="header-link-current" href="https://www.froyok.fr/articles.html" id="link-blog">Articles</a>
<a href="https://www.froyok.fr/assets.html" id="link-store">Assets</a>
<a href="https://www.froyok.fr/portfolio.html" id="link-portfolio">Portfolio</a>
<a href="https://www.froyok.fr/about.html" id="link-about">About</a>
</div>
</div>
<div id="page-title"><h1>Custom Lens-Flare Post-Process in Unreal Engine</h1><p>Reworking and improving the native post-process effect.</p></div>
<div id="page-arrow"><img alt="" id="scroll-arrow" rel="preload" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/gradient_arrow.webp"></div>
</div>
<div id="main">
<div id="main-body">
<p class="date">September 15, 2021</p><hr><ul class="table-of-content"><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#what_it_looks_like">What It Looks Like</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#the_physics_of_lens-flares">The Physics of Lens-Flares</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#real_lens-flare_examples">Real Lens-Flare Examples</a></li>
<ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#what_about_anamorphic_lens-flares">What About Anamorphic Lens-Flares ?</a></li>
</ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#examples_from_video_games">Examples from Video Games</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#looking_at_some_games_in_more_details">Looking at Some Games in More Details</a></li>
<ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#the_case_of_cyberpunk_2077">The Case of Cyberpunk 2077</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#the_case_of_batman_arkham_knight">The Case of Batman Arkham Knight</a></li>
</ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#overview_of_the_original_ue4_lens-flare_effect">Overview of the Original UE4 Lens-Flare Effect</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#overview_of_the_ue4_modification">Overview of the UE4 Modification</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_1_setting_up_a_plugin">Step 1: Setting Up a Plugin</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_2_prepping_shaders">Step 2: Prepping Shaders</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_3_data_asset">Step 3: Data Asset</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_4_hacking_the_engine_render_process">Step 4: Hacking the Engine Render Process</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_5_custom_subsystem">Step 5: Custom Subsystem</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_6_utility_functions">Step 6: Utility Functions</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_7_main_render_function">Step 7: Main Render Function</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_8_common_shader">Step 8: Common Shader</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_9_rescale_pass">Step 9: Rescale Pass</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_10_downsample_and_threshold_pass">Step 10: Downsample and Threshold Pass</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_11_blur_function">Step 11: Blur Function</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_12_ghost_pass">Step 12: Ghost Pass</a></li>
<ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#chroma_shift_subpass">Chroma Shift Subpass</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#ghost_subpass">Ghost Subpass</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#halo_subpass">Halo Subpass</a></li>
</ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_13_glare_pass">Step 13: Glare Pass</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_14_final_mixing_pass">Step 14: Final Mixing Pass</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#performance_and_optimization">Performance and Optimization</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#conclusion">Conclusion</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#bonus">Bonus</a></li>
<ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#previewing_rdg_buffers">Previewing RDG Buffers</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#generating_mipmaps_with_rdg_buffers">Generating Mipmaps with RDG Buffers</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#splitting_code_into_multiple_files">Splitting Code Into Multiple Files</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#recompiling_shaders_at_runtime">Recompiling Shaders at Runtime</a></li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#changing_cvar_for_debug_ui">Changing Cvar for Debug UI</a></li>
</ul><li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#bibliography_and_sources">Bibliography and Sources</a></li>
</ul><hr><p>This article shows how to modify the default Unreal Engine lens-flare post-process, from code to shaders. I always wanted to change the default Unreal Engine 4 lens-flares because it never felt good in my opinion. It's a post-process effect that lacks control and looks rather bland.<br>
The fact it is broken too doesn't help (<a href="https://www.froyok.fr/blog/2021-04-fixing-ue4-flares/page.html" rel="nofollow">because of a UI bug</a>) which means anybody trying to use it in a project will have some difficulties getting any artistic control over it.</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4/ue4_default_lens_flare.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_ue4_default_lens_flare.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4/ue4_default_flares.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_ue4_default_flares.jpg"></a><br>
(Isn't it boring ?)</p>
<p>So when a few years ago I stumbled across other games that displayed different kind of flares I started to wonder if it was possible to modify/implement something different. It's only recently that I was able to figure out how, mostly thanks to some updates of the engine that simplified quite a bit its rendering process.</p>
<p>Be aware that the following article is a long technical deep dive and assumes anybody reading it is comfortable with general shaders and C++ programming.</p>
<blockquote>
<p>This article was written based on Unreal Engine version 4.25. Some of the steps involve modifying the engine source code, which should be applicable to version 4.26, 4.27 and the UE5 first early access as well without any issues.</p>
</blockquote>
<hr>
<a id="what_it_looks_like"></a><h2>What It Looks Like</h2>
<p>Before diving into details, I think it's important to look at what the end result looks like:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/overview_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_overview_2.jpg"></a> </p>
<hr>
<p>Here is it in context inside the <strong>Infiltrator Demo</strong> from Epic Games:</p>
<p class="img-centered"></p><div class="iframe-container"><iframe allowfullscreen="true" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/k4XKq2atZwQ.html" type="text/html"></iframe></div><p></p>
<p class="img-centered"><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/overview.webp" rel="nofollow"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_overview.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_3.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_3.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_1.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_4.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_4.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_grid.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_grid.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_corridor_halo.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_corridor_halo.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_sparks.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_sparks.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/screenshot_screenshot_1.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_screenshot_screenshot_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/screenshot_screenshot_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_screenshot_screenshot_2.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/screenshot_screenshot_3.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_screenshot_screenshot_3.jpg"></a></p>
<hr>
<p>Below are comparisons between the original effect and the new one:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/ue4_original.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_ue4_original.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/ue4_custom.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_ue4_custom.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_before.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_before.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/result/infiltrator_after.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_infiltrator_after.jpg"></a></p>
<hr>
<a id="the_physics_of_lens-flares"></a><h2>The Physics of Lens-Flares</h2>
<p>A lens-flare is a composition of several behaviors based on the way light bounces inside the lens of a camera. While initially seen as defects, which is why expensive lenses and even specific protections have been made to get rid of them, flares have become an artistic tool to add details on an image.</p>
<p>Similarly to <a href="https://en.wikipedia.org/wiki/Chromatic_aberration" rel="nofollow">Chromatic Aberration</a>, it can be a used by artists to shape and enhance the look and framing of a subject. In the domain of computer graphics they can help achieve the feeling of a more realistic image.</p>
<hr>
<p>Modern lenses are actually a composite of multiple glasses with different shapes that bend the light rays toward the sensor (which registers/captures the colors). </p>
<p>Because of this complexity, a light ray can scatter when refracted by a glass which leads to visual artifacts. When a refracted ray bounce inside the lens it can scatter again and bounce further until at some point it may hit the sensor but this time it is unfocused (contrary to a direct ray).</p>
<p>This is why multiple shapes can appear on an image from a single light source and create the famous "lens-flare". The coloration also comes from the way some glasses refract rays that have different frequencies, leading sometimes to only certain wavelengths hitting the sensor.</p>
<p class="img-centered"><img alt="Side view of a lens scheme showing light rays" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/lens_scheme.png"><br>
(Side view of a lens, with the diaphragm in the middle and the captor on the far right.)</p>
<p>I recommend taking a look at <a href="https://en.wikipedia.org/wiki/Lens_flare" rel="nofollow">Wikipedia</a> if you want to learn more on this subject.</p>
<p>Lens-flares exist in many shapes, which all depends on the way a lens has been built/designed but also on how the light enter the lens (straight, sideways, etc). Lenses from different constructors won't lead to the same visual results.</p>
<hr>
<p>There are three main categories of effect that can constitute a lens-flare:</p>
<ul>
<li><strong>Ghost</strong>: Circles, rings or dots that appear several times and aligned along a line, coming from the sun or a bright source of light.</li>
<li><strong>Halo</strong>: Bright colors that shift/distort and go around the image.</li>
<li><strong>Glare</strong>: Also called sunburst or starburst. Shape that appears on the light source itself. It can be a line, or something more complex like a star. It usually depends on the camera <a href="https://en.wikipedia.org/wiki/Diaphragm_(optics)" rel="nofollow">aperture/diaphragm</a>.</li>
</ul>
<hr>
<p>It is also interesting to note that the lens-flare look can change when the lens is dirty. For example water droplets can bend the light rays before they enter the lens.</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/explanation/sig2015_flare_example_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_sig2015_flare_example_2.jpg"></a><br>
(Even with our own eyes we can see glare on lights because of our eyelashes)</p>
<hr>
<a id="real_lens-flare_examples"></a><h2>Real Lens-Flare Examples</h2>
<p>Finding good references is not always easy, especially on the Internet as most of time lens-flares are faked in post-production into content. </p>
<p>The examples below were made by my colleague <a href="https://twitter.com/nicolaswir" rel="nofollow">Nicolas</a> with a few different lenses:</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/examples_real/30mm_sigma_f1_4__flare.webm" type="video/webm"></video> <video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/examples_real/30mm_sigma_f1_4__glare.webm" type="video/webm"></video> <video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/examples_real/30mm_sigma_f1_4__diaphragm-transition.webm" type="video/webm"></video><br>
(Lens Sigma, 30mm, f1.4)</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/examples_real/tokina_11_116_f2_8.webm" type="video/webm"></video><br>
(Lens Tokina, 11mm, f2.8)</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/examples_real/85mm_canon_f1_8.webm" type="video/webm"></video><br>
(Lens Canon, 85mm, f1.8)</p>
<hr>
<p>Other examples found on Internet:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_real/glare_aperture.jpg" rel="nofollow" target="_blank"><img alt="Glare related to aperture" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_glare_aperture.jpg"></a><br>
(Effect of the aperture on the size and shape of the effect.)</p>
<p class="img-centered"><img alt="Military flare" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/military_flare_2.gif"> <img alt="Tenet behind the scene plane" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/tenet_flare_plane_01.gif"> <img alt="Photo shoot flare demo1" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/youtube_flare_demo_1.gif"> <img alt="Photo shoot flare demo 3" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/youtube_flare_demo_3.gif"> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_real/google_street_view_1.jpg" rel="nofollow" target="_blank"><img alt="Google Street view in Corsica" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_google_street_view_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_real/flare_city.jpg" rel="nofollow" target="_blank"><img alt="City photography" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_flare_city.jpg"></a> </p>
<hr>
<p>Some lens filters can even exacerbate some part of the lens-flares. For example star-light filters can create long lines on light sources (the number of branches depending on the configuration of the filter):</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_real/star_filter_1.jpg" rel="nofollow" target="_blank"><img alt="star filter" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_star_filter_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_real/star_filter_2.jpg" rel="nofollow" target="_blank"><img alt="star filter" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_star_filter_2.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_real/star_filter_3.jpg" rel="nofollow" target="_blank"><img alt="star filter" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_star_filter_3.jpg"></a></p>
<blockquote>
<p>For more details on star filters and how they work you can take a look at <a href="https://pages.mtu.edu/~shene/DigiCam/User-Guide/filter/filter-star.html" rel="nofollow">this article</a>.</p>
</blockquote>
<a id="what_about_anamorphic_lens-flares"></a><h3>What About Anamorphic Lens-Flares ?</h3>
<p>Anamorphic lenses are a type of lenses that compress/stretch the image on one axis. It was initially used to fit more information on film. The counterpart is that any flare that may be captured will appear deformed when the image is put back to its normal ratio. More details in the dedicated <a href="https://en.wikipedia.org/wiki/Anamorphic_format" rel="nofollow">Wikipedia article</a>.</p>
<p>This is how J. J. Abrams created (and over-used) them in the movie Start Trek for example. Mr. Abrams <a href="https://www.youtube.com/watch?v=vMGJmt-yznI" rel="nofollow">deliberately shot flashlights at the camera</a> to make sure glares and flares would appear on the image. In the Star Trek movie released in 2009 you can see the round shapes of the flares being squished:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_movies/start-trek_2009_flare_4.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_start-trek_2009_flare_4.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_movies/start-trek_2009_flare_6.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_start-trek_2009_flare_6.jpg"></a></p>
<p>I also wanted to mention Lupin, the Netflix show released in 2021, which features some really nice looking flares that I haven't seen elsewhere before:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_movies/lupin_flare_5.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_lupin_flare_5.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_movies/lupin_flare_34.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_lupin_flare_34.jpg"></a> <img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/lupin_2.gif"> <img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/lupin_12.gif"> <img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/lupin_3.gif"> <img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/lupin_10.gif"></p>
<p>It seems they are produced with a technique called <a href="https://www.samhurdphotography.com/the-ring-of-fire/" rel="nofollow">"ring of fire"</a> which is about putting a metallic cylinder in front of the lens to get additional light bounces creating this specific type of granular and colored rings. Lupin was filmed with Anamorphic Lenses too which create these non regular rounded shapes as well.</p>
<hr>
<a id="examples_from_video_games"></a><h2>Examples from Video Games</h2>
<p>So real lens-flares are nice, but they are not easy to replicate as simulating lenses and light rays that go through them can be quite complex. So in real-time applications, especially video games, different methods have been used to achieve a cheaper but still effective result. There are three general categories:</p>
<ul>
<li><strong>Single sprites</strong>: an entity/actor is put in the game to draw a billboard (quad aligned to the screen) with a bright spot in it. This is a very cheap effect that can look great but quickly falls short because it doesn't react really well to the camera and its shape is often constant. Nowadays they are made via particle systems to be rendered efficiently.<br>
<a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/mass-effect-2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_mass-effect-2.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/alan-wake.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_alan-wake.jpg"></a><br>
(Mass Effect 2 - 2010, Alan Wake - 2010)</li>
<li><strong>Chained sprites</strong>: similar to the previous method, but use multiple iterations aligned on a line to offset the sprites. This allows to create a directional effect similar to what can be observed on cameras. It can feel static as well as the images inside the chain rarely change in terms of shape and colors.<br>
<a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/spec-ops-the-line.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_spec-ops-the-line.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/alien_isolation.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_alien_isolation.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/ratchet_clank_rift_apart_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_ratchet_clank_rift_apart_2.jpg"></a><br>
(Spec Ops: The Line - 2012, Alien Isolation - 2014, Ratchet &amp; Clank Rift Apart - 2021)</li>
<li><strong>Post-Process</strong>: This is is usually a shader that reads the scene color and generates a new output from it. Most common effects nowadays includes the creations of ghosts from a threshold value. The Unreal Engine method works in a similar fashion. Main advantage of this method is that its cost is usually fixed and can react to anything on screen so it can be fully dynamic. The games below use a post-process:</li>
</ul>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/example_batman_3.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_example_batman_3.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/example_batman_5.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_example_batman_5.jpg"></a><br>
(Batman Arkham Knight, 2015)</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/no-man-sky_1.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_no-man-sky_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/examples_games/no-man-sky_3.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_no-man-sky_3.jpg"></a><br>
(No Man's Sky, 2016)</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/cyberpunk/cyberpunk2077_flare_1.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_cyberpunk2077_flare_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/cyberpunk/cyberpunk2077_flare_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_cyberpunk2077_flare_2.jpg"></a><br>
(Cyberpunk 2077, 2020)</p>
<hr>
<a id="looking_at_some_games_in_more_details"></a><h2>Looking at Some Games in More Details</h2>
<p>Before diving into my own implementation, I wanted to look at some of the examples mentioned above in more details. They are using a few interesting tricks worth knowing about.</p>
<blockquote>
<p>Every details I mention below are my own interpretations as I could only reverse engineer the behavior of the effect from playing the games and looking at how some things are rendered with graphic debuggers.</p>
</blockquote>
<a id="the_case_of_cyberpunk_2077"></a><h3>The Case of Cyberpunk 2077</h3>
<p>Cyberpunk 2077 post-process effect seems to be very similar to <a href="http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html" rel="nofollow">John Chapman's article</a> in term of behavior, which is is quite straightforward to understand.</p>
<p class="img-centered"><img alt="John Chapman Flares" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/chapman_halo_2.jpg"></p>
<p>In the original implementation (see the article before going further), the effect is made by sampling the source buffer several times to create the ghosts while a radial distortion is used to create the halo around the edge of the screen. Then additional passes add chromatic aberration and blur everything together.</p>
<p>Cyberpunk does everything in one pass inside a buffer at 1/2 the game resolution. It re-uses the downsampled buffer of the bloom as a starting point and samples it several times to draw the ghosts (4 or 5 of them) and the halo, all in one go. This avoid the need to blur anything since the Bloom effect already did it. The chromatic aberration is done by doing 3 samples instead of one with a different directional offset from the center of the screen.</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/cyberpunk/cp2077_flare_demo.webm" type="video/webm"></video></p>
<p>Cyberpunk doesn't use the radial mask contrary to the method it seems to be based on. This mask is normally used to hide the halo effect at the center of the screen. One of the reason to use this mask is to hide some artifacts produced by the UV distortion, which can be seen in the game (the flower petals around the dot):</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/cyberpunk/cp2077_halo_glitch.jpg" rel="nofollow" target="_blank"><img alt="Cyberpunk halo glitch" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_cp2077_halo_glitch.jpg"></a><br>
(Normal in-game capture vs contrasted one)</p>
<a id="the_case_of_batman_arkham_knight"></a><h3>The Case of Batman Arkham Knight</h3>
<p>Another interesting game I mentioned is Batman. The lens-flares in it are a bit different from what I have seen in other games.</p>
<p>Like in Cyberpunk, several ghosts are drawn in one go in a buffer (1/2 the game resolution as well) at several scales to create the light bleeding effect. Here as well it is done by retrieving one of the downsampled buffer of the Bloom generated before. Each ghost is sampled 3 times to create a Chromatic aberration effect. However it shifts the red and green component instead of the red and blue (my guess would be because the game is overall blue since it happens at night).</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/batman/batman_flare_round_lamp_2.webm" type="video/webm"></video></p>
<p>Ghost are not sampled as-is however, a radial distortion effect is applied at their center to make the effect rotate. So pivoting the camera make them turn when the content drawn is at the center of the screen:</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/batman/batman_flare_red_tower.webm" type="video/webm"></video> <video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/batman/batman_flare_spots.webm" type="video/webm"></video></p>
<p>As you may have noticed, there is another effect on lights: a glare is visible on bright light sources. Let's take a look at an example to understand it better.<br>
Below are two lights having their own glare effect (the game final resolution is 1920x1080 here).</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_spots_finale.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_flares_output.jpg"></a></p>
<p>If we take a look in <strong>RenderDoc</strong> at the final buffer (bloom + lens-flare) before it is composited with the rest we can see this that the glare effect is actually part of it too. This means it is a post-process as well and not based on a sprite/particle system !</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_spots_bloombuffer.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_spots_bloombuffer.jpg"></a></p>
<p>In the image above, the left side shows the final buffer result (slightly scaled to compensate HDR values) where the ghosts have been generated. On the right side we can see the several texture as inputs: </p>
<ul>
<li><strong>Scene color</strong> (or what I assume it is): I don't know what is is used for.</li>
<li><strong>Downsampled texture</strong>: this is the buffer that is used to create the ghosts.</li>
<li><strong>Glare texture</strong>: generated before hand and composited together with the bloom.</li>
<li><strong>A colored texture with lot of circles</strong>: used to add some details/dirt on the bloom result.</li>
</ul>
<p>So the glare effect is built before the ghosts. It is made just in the middle of the down then upscale process that generates the bloom result. That glare buffer is 1/4 of the game resolution and looks like this:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_spots_buffer.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_flares_buffer.jpg"></a></p>
<p>Once again you can see the buffer result on the left and its inputs on the right:</p>
<ul>
<li><strong>Downsampled texture</strong>: the starting point to decide where the glare effect should appear.</li>
<li><strong>Cloud texture</strong>: a basic texture with three different noises in each RGB channel (Photoshop cloud filter I presume). While I can't be 100% sure I believe this is used to add rotation and scale variations based on the screen position.</li>
<li><strong>Gradient texture</strong>: this is the texture used to shade/colorize the branches of the glare.</li>
</ul>
<p>Looking at the buffer result isn't enough to understand how it has been generated. Switching views in RenderDoc allows to see this:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_spots_geo.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_flares_geo.jpg"></a><br>
(This specific pass was rendered in 0.04388ms on my GPU)</p>
<p>So glares are actually made from geometry, via a lot of quads with different orientations and sizes to draw the star shape. Like I mentioned previously, this buffer is 1/4 of the game resolution, which translates to a size of 480x270 pixels. This means 129600 pixels in total. This number matters because if we divide it by 4 we get 32400 which is the exact number of vertices drawn in the vertex shader of this pass:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/batman_vertexcount.jpg"><br>
(Batman doesn't run via Vulkan of course, but the Linux translation layer does.)</p>
<p>The primitive type used here is <strong>points</strong> and not triangles, which means each vertex is independent and likely read a block of 2x2 pixels to average the luminosity. If this luminosity goes above a certain threshold, then the next phase which is the geometry shader will generates one or several quads to draw the shape of the glare. Then each quad during the pixel shader phase samples the gradient texture seen above multiplied by the color of input buffer to adapt to the source light color.</p>
<p>The size of the quads depends on the luminosity, for example with this neon light below the quads are very small (but dense given how large the light fills the screen and gets captured by the points).</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_neon_final.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_neon_final.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_neon_glare.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_neon_glare.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_neon_geo.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_neon_geo.jpg"></a><br>
(Render time: 0.06864ms)</p>
<p>Another example:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_bigspots_final.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_bigspots_final.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_bigspots_glare.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_bigspots_glare.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/batman/batman_bigspots_geo.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_batman_bigspots_geo.jpg"></a><br>
(Render time: 0.0698ms)</p>
<p>Here is what it looks like in movement:</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/batman/batman_flare_rotation_movement.webm" type="video/webm"></video><br>
<video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/batman/batman_flare_candle.webm" type="video/webm"></video></p>
<p>While this effect looks good and cheap, <strong>there is a caveat to be aware of</strong>. Because of the way the glare is built, when moving the camera the bright pixels will move and at low resolution this can introduce some kind of flicker. Therefor the size of the quad will pulse. This is visible in Batman when moving slowing:</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/batman/batman_flare_artifact.webm" type="video/webm"></video><br>
(See how the left branch here rotate in a blocky way)</p>
<p>From my observations, it seems bright lights lose in intensity when they are far away which leads to smaller quads and therefore hide the glare and its issue. This could be simply because how the way the buffer is downsampled before hand, or because light actually change in intensity in-game.<br>
I also think the buffer is oversampled when mixed with the ghosts to blur it slightly and reduce the stepping.<br>
And finally, the fact the glare shape change size and orientation based on the screen position is another good way to hide the artifact via the motion. I had to find very specific angles and camera movements to make the issue noticeable enough.</p>
<hr>
<a id="overview_of_the_original_ue4_lens-flare_effect"></a><h2>Overview of the Original UE4 Lens-Flare Effect</h2>
<p>Let's take the time to review how UE4 default lens-flare effect works because it does several interesting things (but some bad stuff too). It can be summarized with this little scheme:</p>
<p class="img-centered"><img alt="UE4 lens flare overview" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/flare_ue4_scheme.jpg"></p>
<p>And here are the steps in details:</p>
<p><strong>1 - Bloom Generation</strong><br>
Bloom is generated just before lens-flares. If the bloom intensity is 0, then neither bloom nor lens-flares will be rendered. If the threshold for the bloom is -1, then no processing is done and one the Scene Color downsamples is used as-is. If there is a threshold specified a different process generates the bloom effect. The result is then fed to the lens-flare rendering code.</p>
<p><strong>2 - Bloom Compositing</strong><br>
An empty render target is created and the bloom is copied into it. The render target has the same size as the bloom, which is half of the viewport resolution (1/2). This size can change depending on the engine scalability settings (aka performance tweaks).</p>
<p><strong>3 - Bokeh Blur</strong><br>
This pass uses the downsampled buffer as input and render a blurry version with the help an shape (the bokeh texture).<br>
The blur itself is generated by drawing <strong>an instanced quad for (almost) each pixel</strong>. It is basically a sprite with the bokeh texture and the color sampled from the input texture. The drawing is discarded by setting the quad size to 0 if the pixel luminosity is below the threshold value. The comparison with the threshold value is binary, which can introduce flickering if the luminosity is unstable (like when the camera moves slightly):</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/threshold_ue4_default_binary.gif"><br>
(Here is the raw output of a small bokeh blur in a corner of the screen)</p>
<p>Adjusting the blur size simply means changing the size of the quad drawn. This is why <strong>a large blur radius cost more</strong> because of how many quads will overlap (overdraw). This is also why a very small blur size leads to... nothing ! Simply because the quad becomes too small and isn't rasterized anymore (smaller than a pixel).</p>
<p>To keep performance reasonable this pass is done in a render target that is a quarter of the viewport (1/4, but again dependent on scalability settings) and only 1 over 2 pixels is actually drawn. This is why when using a very small blur size a checker pattern can appear: </p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4/bokeh_blur_checker.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_bokeh_blur_checker.jpg"></a></p>
<p>Another important point to note is that inside this render target the actual drawing area is half of the buffer. This is to ensure that any quad drawn will not end-up cut at the buffer edges. This means the actual drawing is therefore done at 1/8 of the viewport size.</p>
<p><strong>4 - Flare Accumulation</strong><br>
A loop draws several time additively into the render target with the copy of the bloom a scaled quad with the bokeh blur pass result. The loop is on the code side (CPU) and not in a shader (GPU). </p>
<p>Each iteration of the loop use a color and size inherited from the post-process volume settings. The size is base don the alpha value of the color. With some math magic, the quad is drawn normally the value is greater than 0.5, otherwise it will be drawn upside down (scaled negatively to give the mirrored light effect of the ghost).</p>
<p>Since the size of the flare can be smaller than the viewport, this is why it matters that the borders of the blur pass remain clean and not clipped, or they would be easily visible.</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/ue4/ue4_flare_accumulation.webm" type="video/webm"></video><br>
(In this example I'm using a radial gradient as the bokeh texture)</p>
<blockquote>
<p>I'm still wondering why the drawing is done in several passes rather than a single one. I thought it could be a way to save some bandwidth to avoid redrawing too much the buffer, but since the actual content is scaled down you have to oversize it to compensate. This lead to updating some pixels for nothing. Maybe it is intentional, or maybe it is just legacy code that hasn't been cleaned up.</p>
</blockquote>
<p><strong>5 - Output</strong><br>
Finally, the engine retrieve the render target and composite it into the final frame, before the tone-mapping step. All the passes are done in render targets with floating point precision to work with -and preserve- HDR values.</p>
<p><strong>Wait, there is more...</strong><br>
On top of all of that there is an additional behavior to take into account: <em>sub-region rendering</em>.</p>
<p>When running the editor, the engine allocates a render target which match the viewport size. However when switching to fullscreen or opening a secondary window with a different viewport (like the static mesh viewer) the render target will be resized to accommodate the new resolution. When closing the window or exiting the full screen mode, the engine won't resize (down) the render target.</p>
<p>Instead it will only render a smaller part of it (a region). This avoid the need to reallocate/rebuild a render target all the time while being able to render at the right resolution. Unfortunately this complicate a bit the shaders later...</p>
<hr>
<a id="overview_of_the_ue4_modification"></a><h2>Overview of the UE4 Modification</h2>
<p>Now here is a little overview of how my own lens-flares work. Each image represents a different rendering pass:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/overview_custom.jpg"></p>
<p>The process is divided in a few big steps:</p>
<ol>
<li><strong>Threshold</strong>: instead of using the Bloom/downsampled buffers as the starting point, is it instead the original Scene Color (at half resolution) which allows to compute a custom threshold value independent from the bloom itself.</li>
<li><strong>Ghosts and Halo</strong>: this part handles copying the result of the threshold to produce the classic lens-flare visuals. Ghosts are simply a copy of the threshold result with different scales and the Halo is based on John Chapman article (as seen in Cyberpunk 2077).</li>
<li><strong>Glare</strong>: the glare pass generate a new pattern by drawing custom quads, in a similar vein to the Batman process.</li>
<li><strong>Mixing</strong>: The previous passes are blended together with the bloom and fed back to the engine to be integrated in the rest of the rendering pipeline (and displayed on screen).</li>
</ol>
<hr>
<a id="step_1_setting_up_a_plugin"></a><h2>Step 1: Setting Up a Plugin</h2>
<blockquote>
<p>Something to be aware: this article is divided in steps to make reading and comprehension easier. Those are not steps that can followed to compile code on the way as many parts will be missing until reaching the end.<br>
  I also strongly advise to read all the steps first before trying to copy/paste anything.</p>
</blockquote>
<hr>
<p>Because of the way the Unreal Engine manages external shaders, we are gonna need to setup a custom plugin. </p>
<p>Shader files (not Materials) are usually stored in the engine folder, but it is possible to reference them externally via a module or plugin. It is not possible to reference them directly in your project code because they need to be loaded earlier by the engine.</p>
<p>While a module inside the project folder can work, I found a plugin easier to setup and produce less conflicts/overlaps with a project in general.</p>
<hr>
<p>Hop in the editor and open the plugin manager:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/plugin_menu.png"></p>
<p>Then click on the <strong>New Plugin</strong> button at the bottom of the window:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/plugin_new.png"></p>
<p>Make sure to choose a blank plugin, then name it (in my case I used <strong>CustomPostProcess</strong>):</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/plugin_creation.png" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_plugin_creation.jpg"></a></p>
<p>You can fill in the other information, just make sure that "Is Engine Plugin" is disabled. Then use <strong>Create Plugin</strong> to build the plugin.</p>
<hr>
<p>Open the folder where the plugin has been created (it should be in your project <strong>Plugins</strong> folder). Then locate and open the <strong>Build.cs</strong> file in the Source folder (mine is <strong>CustomPostProcess.Build.cs</strong>) and add the following includes:</p>
<div class="highlight"><pre>    <span class="n">PrivateIncludePaths</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">string</span><span class="p">[]</span>
        <span class="p">{</span>
            <span class="c1">// Needed to include the engine Lens Flare post-process header</span>
            <span class="n">EngineDirectory</span> <span class="o">+</span> <span class="s">"/Source/Runtime/Renderer/Private"</span>
        <span class="p">}</span>
        <span class="p">);</span>

    <span class="n">PublicDependencyModuleNames</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">string</span><span class="p">[]</span>
        <span class="p">{</span>
            <span class="c1">// Needed for RenderGraph, PostProcess, Shaders</span>
            <span class="s">"Core"</span><span class="p">,</span>
            <span class="s">"RHI"</span><span class="p">,</span>
            <span class="s">"Renderer"</span><span class="p">,</span>
            <span class="s">"RenderCore"</span><span class="p">,</span>
            <span class="s">"Projects"</span>
        <span class="p">}</span>
        <span class="p">);</span>
</pre></div>

<hr>
<p>By default there should be a class named like the plugin. Open the class files and edit them with the following:</p>
<p><strong>CustomPostProcess.h</strong></p>
<div class="highlight"><pre><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">"CoreMinimal.h"</span>
<span class="cp">#include</span> <span class="cpf">"Modules/ModuleManager.h"</span>

<span class="k">class</span> <span class="nc">FCustomPostProcessModule</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IModuleInterface</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">StartupModule</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ShutdownModule</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p><strong>CustomPostProcess.cpp</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"CustomPostProcess.h"</span>
<span class="cp">#include</span> <span class="cpf">"Interfaces/IPluginManager.h"</span>

<span class="cp">#define LOCTEXT_NAMESPACE "FCustomPostProcessModule"</span>

<span class="kt">void</span> <span class="n">FCustomPostProcessModule</span><span class="o">::</span><span class="n">StartupModule</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FString</span> <span class="n">BaseDir</span> <span class="o">=</span> <span class="n">IPluginManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">FindPlugin</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"CustomPostProcess"</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">GetBaseDir</span><span class="p">();</span>
    <span class="n">FString</span> <span class="n">PluginShaderDir</span> <span class="o">=</span> <span class="n">FPaths</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span> <span class="n">BaseDir</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Shaders"</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">AddShaderSourceDirectoryMapping</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"/CustomShaders"</span><span class="p">),</span> <span class="n">PluginShaderDir</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FCustomPostProcessModule</span><span class="o">::</span><span class="n">ShutdownModule</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#undef LOCTEXT_NAMESPACE</span>

<span class="n">IMPLEMENT_MODULE</span><span class="p">(</span><span class="n">FCustomPostProcessModule</span><span class="p">,</span> <span class="n">CustomPostProcess</span><span class="p">)</span>
</pre></div>

<p>In <strong>StartupModule()</strong> we retrieve the Plugin location to which we append the Shaders folder we just created. Then by calling <strong>AddShaderSourceDirectoryMapping()</strong> we create a symbolic path for the engine to know where to look for to load our custom shader files.</p>
<hr>
<p>Last part of the setup is to make sure the <strong>.uplugin</strong> file is correctly configured, so open it and make sure the <strong>Modules</strong> property is set as follow:</p>
<div class="highlight"><pre>    <span class="s">"Modules"</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s">"Name"</span><span class="o">:</span> <span class="s">"CustomPostProcess"</span><span class="p">,</span>
            <span class="s">"Type"</span><span class="o">:</span> <span class="s">"Runtime"</span><span class="p">,</span>
            <span class="s">"LoadingPhase"</span><span class="o">:</span> <span class="s">"PostConfigInit"</span>
        <span class="p">}</span>
    <span class="p">]</span>
</pre></div>

<blockquote>
<p>Make sure to adjust all the mentions of <strong>CustomPostProcess</strong> with your own plugin name in the snippets shown above.</p>
</blockquote>
<hr>
<a id="step_2_prepping_shaders"></a><h2>Step 2: Prepping Shaders</h2>
<p>In the plugin root folder add a new folder named <strong>Shaders</strong>, sitting next to the Content and Source ones:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/shader_folder.png"></p>
<p>This is where we are going to store the shader files needed by the rendering passes. Create the following text files (take note of the file extension):</p>
<p><em>.USF</em><br>
- Chroma.usf<br>
- DownsampleThreshold.usf<br>
- DualKawaseBlur.usf<br>
- Ghosts.usf<br>
- Glare.usf<br>
- Mix.usf<br>
- Halo.usf<br>
- Rescale.usf<br>
- ScreenPass.usf</p>
<p><em>.USH</em><br>
- Shared.ush</p>
<hr>
<p>Open <strong>Shared.ush</strong> and paste this into it:</p>
<div class="highlight"><pre><span class="c1">// Not sure if this one is needed, but the engine</span>
<span class="c1">// lens-flare shaders have it too.</span>
<span class="cp">#define SCENE_TEXTURES_DISABLED 1</span>

<span class="cp">#include</span> <span class="cpf">"/Engine/Public/Platform.ush"</span>
<span class="cp">#include</span> <span class="cpf">"/Engine/Private/Common.ush"</span>
<span class="cp">#include</span> <span class="cpf">"/Engine/Private/ScreenPass.ush"</span>
<span class="cp">#include</span> <span class="cpf">"/Engine/Private/PostProcessCommon.ush"</span>

<span class="n">Texture2D</span> <span class="n">InputTexture</span><span class="p">;</span>
<span class="n">SamplerState</span> <span class="n">InputSampler</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">InputViewportSize</span><span class="p">;</span>
</pre></div>

<p>These are common variables and defines that are gonna be used across all the passes. The other files will be covered in the next parts.</p>
<hr>
<a id="step_3_data_asset"></a><h2>Step 3: Data Asset</h2>
<p>Usually to control post-process settings you need to pass by a post-process settings struct which can be seen in post-process volumes or cameras. I edited this struct in the past to add custom settings, like for my <a href="https://www.froyok.fr/blog/2017-05-anamorphique-bloom-with-unreal-engine-4/page.html" rel="nofollow">anamorphic bloom</a>, but it presented several issues:</p>
<ul>
<li>Because those settings are stored in the file <strong>Scene.h</strong> of the engine, it is very slow to compile since it affects many other classes because of it dependencies. So iterating on the settings is slow.</li>
<li>The struct itself impact several files because it is initialized in several ways. This makes things hard to track and since it's not officially documented it's easy to miss changes when migrating to other engine versions. For example I had a bug related to <a href="https://twitter.com/Froyok/status/1209182747908022272" rel="nofollow">uninitialized variables</a> because at some point new ways to init the struct appeared when upgrading the engine.</li>
<li>Parameters of this struct can be blended (when post-process volumes overlap for example), which add another layer of complexity on how to manage the settings.</li>
</ul>
<p>These few points make editing this struct <strong>very annoying</strong>, <strong>time consuming</strong> and <strong>easy to broke</strong>. Hence why I didn't want to go this way this time.</p>
<p>Instead I preferred to focus on another method which would be much more future proof while still being user friendly for artists to edit settings in-engine (and in-editor as well). I went with a combined solution of:</p>
<ul>
<li><strong>Console variables</strong>: these variables are very easy to add and edit on the fly via the console. It's useful to quickly prototype or toggle features in their entirety. </li>
<li><strong>Data asset</strong>: this kind of asset sits in the Content Browser and can display parameters and resource reference inside the detail panel. It's similar to editing a material instance or a Blueprint instance. This asset can be referenced and loaded in code, which allows to edit settings on the fly in-editor and see the code adapt from it.</li>
</ul>
<p>This doesn't offer the flexibility of post-process volumes which could adapt to specific area of a level, but I figured that Bloom and lens-flare wouldn't change much (except maybe for the threshold value in specific context). Therefore updating a few settings can be done manually via code or Blueprint scripting in a level. To my eyes, this is a good trade-of between artist control and code maintenance.</p>
<p>I will cover the console variable later, so for now let's prepare the data asset. To do so, create a new class inheriting <strong>DataAsset</strong>. I named my own <strong>PostProcessLensFlareAsset</strong>:</p>
<p><strong>PostProcessLensFlareAsset.h</strong></p>
<div class="highlight"><pre><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">"CoreMinimal.h"</span>
<span class="cp">#include</span> <span class="cpf">"Engine/DataAsset.h"</span>
<span class="cp">#include</span> <span class="cpf">"PostProcessLensFlareAsset.generated.h"</span>

<span class="c1">// This custom struct is used to more easily</span>
<span class="c1">// setup and organize the settings for the Ghosts</span>
<span class="n">USTRUCT</span><span class="p">(</span><span class="n">BlueprintType</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">FLensFlareGhostSettings</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

    <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">BlueprintReadWrite</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Exedre"</span><span class="p">)</span>
    <span class="n">FLinearColor</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">FLinearColor</span><span class="o">::</span><span class="n">White</span><span class="p">;</span>

    <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">BlueprintReadWrite</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Exedre"</span><span class="p">)</span>
    <span class="kt">float</span> <span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
<span class="p">};</span>


<span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">CUSTOMPOSTPROCESS_API</span> <span class="nl">UPostProcessLensFlareAsset</span> <span class="p">:</span> <span class="k">public</span> <span class="n">UDataAsset</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"General"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"10.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">Intensity</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"General"</span><span class="p">)</span>
        <span class="n">FLinearColor</span> <span class="n">Tint</span> <span class="o">=</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.85f</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"General"</span><span class="p">)</span>
        <span class="n">UTexture2D</span><span class="o">*</span> <span class="n">Gradient</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>


        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Threshold"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"10.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">ThresholdLevel</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Threshold"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.01"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"10.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">ThresholdRange</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>


        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">GhostIntensity</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">GhostChromaShift</span> <span class="o">=</span> <span class="mf">0.015f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost1</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.5</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost2</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.6f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span>  <span class="mf">2.5</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost3</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="o">-</span><span class="mf">5.0</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost4</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="mf">10.0</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost5</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span>  <span class="mf">0.7</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost6</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">0.9f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="o">-</span><span class="mf">0.4</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost7</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="o">-</span><span class="mf">0.2</span> <span class="p">};</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Ghosts"</span><span class="p">)</span>
        <span class="n">FLensFlareGhostSettings</span> <span class="n">Ghost8</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">0.9f</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="o">-</span><span class="mf">0.1</span> <span class="p">};</span>


        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Halo"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">HaloIntensity</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Halo"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">HaloWidth</span> <span class="o">=</span> <span class="mf">0.6f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Halo"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">HaloMask</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Halo"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">HaloCompression</span> <span class="o">=</span> <span class="mf">0.65f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Halo"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"1.0"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">HaloChromaShift</span> <span class="o">=</span> <span class="mf">0.015f</span><span class="p">;</span>


        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Glare"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"10"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">GlareIntensity</span> <span class="o">=</span> <span class="mf">0.02f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Glare"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.01"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"200"</span><span class="p">))</span>
        <span class="kt">float</span> <span class="n">GlareDivider</span> <span class="o">=</span> <span class="mf">60.0f</span><span class="p">;</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Glare"</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">UIMin</span> <span class="o">=</span> <span class="s">"0.0"</span><span class="p">,</span> <span class="n">UIMax</span> <span class="o">=</span> <span class="s">"10.0"</span><span class="p">))</span>
        <span class="n">FVector</span> <span class="n">GlareScale</span> <span class="o">=</span> <span class="n">FVector</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">);</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Glare"</span><span class="p">)</span>
        <span class="n">FLinearColor</span> <span class="n">GlareTint</span> <span class="o">=</span> <span class="n">FLinearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>

        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span><span class="o">=</span><span class="s">"Glare"</span><span class="p">)</span>
        <span class="n">UTexture2D</span><span class="o">*</span> <span class="n">GlareLineMask</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>Not much to say on the Data Asset itself in term of code, it's mostly variables with their default values. Compile the code and launch the editor.</p>
<p>In the editor, right-click in the content browser and look for the Data Asset type:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/data_asset_menu.png"></p>
<p>Then choose the new class that was just created:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/data_asset_class.png"></p>
<p>Save it, then righ-click and choose Copy Reference to get the asset path into your clipboard. Store it somewhere as we will need this asset path reference later in the code.</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/data_asset_path.png"></p>
<blockquote>
<p>I suggest creating the asset in the content folder of the plugin and not the project. That makes it easier to reference the asset and move the plugin in other projects.</p>
</blockquote>
<hr>
<p>The data asset not only defines values, it also references two textures: </p>
<ul>
<li><strong>Gradient</strong>: This is a 1D texture that will be used to colorize the whole post-process. In my case I created a LinearColor curve asset, which I then fed into a <a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/CurveAtlasesInMaterials/" rel="nofollow">curve atlas</a> after. Then I loaded that atlas into the Gradient texture slot of the Data Asset. I find it more convenient to tweak in-editor rather than loading an external texture. Here is what the curve values look like:<br>
<a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/1D_gradient_overview.png" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_1D_gradient_overview.jpg"></a></li>
<li><strong>Line Mask</strong>: This is a 2D texture that will be used to colorize the glare effect. I made my own in <strong>Substance 3D Designer</strong> at a resolution of 64x8 (and compressed it as <strong>UnserInterface2D</strong>). Because in the shader later we will read the texture while ignoring mipmaps, it is important to keep the texture low resolution.<br>
Notice the dark part in the middle of the image, this is because the mask will overlap the bloom and light sources later. So to avoid brighting things up too much, the middle of the image is darkened.<br>
<img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_flare_mask.jpg"></li>
</ul>
<blockquote>
<p>As with the data asset, I recommend saving these resources inside the plugin's content folder.</p>
</blockquote>
<hr>
<a id="step_4_hacking_the_engine_render_process"></a><h2>Step 4: Hacking the Engine Render Process</h2>
<p>A point I didn't really focus on yet is how the post-process pipeline wasn't meant to be heavily customized. That's why it requires to edit the engine code a bit unfortunately.</p>
<p>In terms of implementation, since a few engine versions (4.24 I believe), the post-process system of UE4 migrated to the <a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Rendering/RenderDependencyGraph/index.html" rel="nofollow">Render Dependency Graph (RDG)</a>. RDG is basically a tool that compile each frame the tasks that will be sent to the GPU. This simplify greatly the writing of custom render passes as RDG manages a lot of things for us.</p>
<p>I started by modifying the existing code of the lens-flare post-process, overwriting the engine render pass to build my own. That works, and I learned tons of stuff with it, but like other things it could become complicated to maintain.</p>
<p>Instead we can build a delegate function. Its goal is to offer a hook into the engine rendering process to insert our own code from an external code pass. This makes possible to have our own lens-flare rendering in our project directly and have it called by the engine when it's time to render it. This means changes are minimal and simple on the engine side.</p>
<hr>
<p>To start, open the engine file <strong>Engine/Source/Runtime/Renderer/Private/PostProcess/PostProcessLensFlares.h</strong>.</p>
<p>In this header there is a struct named <strong>FLensFlareInputs</strong> to which we need to add a parameter. This struct is used to send a few settings from the general post-process rendering phase into the rendering pass itself. So we need to add the SceneColor input since we want to make our own threshold pass. I inserted it between the Bloom and Flare inputs:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">FLensFlareInputs</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">uint32</span> <span class="n">LensFlareCountMax</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="c1">// [Required] The bloom convolution texture. If enabled, this will be composited with lens flares. Otherwise,</span>
    <span class="c1">// a transparent black texture is used instead. Either way, the final output texture will use the this texture</span>
    <span class="c1">// descriptor and viewport.</span>
    <span class="n">FScreenPassTexture</span> <span class="n">Bloom</span><span class="p">;</span>

    <span class="c1">// Froyok</span>
    <span class="c1">// Scene color at half resolution</span>
    <span class="n">FScreenPassTexture</span> <span class="n">HalfSceneColor</span><span class="p">;</span>

    <span class="c1">// [Required] The scene color input, before bloom, which is used as the source of lens flares.</span>
    <span class="c1">// This can be a downsampled input based on the desired quality level.</span>
    <span class="n">FScreenPassTexture</span> <span class="n">Flare</span><span class="p">;</span>
<span class="p">[...]</span>
</pre></div>

<p>Next, just below the struct we modified, add a new struct as follow:</p>
<div class="highlight"><pre><span class="c1">// Froyok</span>
<span class="k">struct</span> <span class="n">FLensFlareOutputsData</span>
<span class="p">{</span>
    <span class="n">FRDGTextureRef</span> <span class="n">Texture</span><span class="p">;</span>
    <span class="n">FIntRect</span> <span class="n">Rect</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>This struct will be used to send back data to the post-process rendering pass from our custom code sitting outside of the engine.</p>
<p>Finally at the bottom of the file there should be a second <strong>AddLensFlaresPass()</strong> definition to which we add the Scene Color input as well:</p>
<div class="highlight"><pre><span class="c1">// Helper function which pulls inputs from the post process settings of the view.</span>
<span class="n">FScreenPassTexture</span> <span class="nf">AddLensFlaresPass</span><span class="p">(</span>
    <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span>
    <span class="n">FScreenPassTexture</span> <span class="n">Bloom</span><span class="p">,</span>
    <span class="n">FScreenPassTexture</span> <span class="n">HalfSceneColor</span><span class="p">,</span> <span class="c1">// Froyok</span>
    <span class="k">const</span> <span class="n">FSceneDownsampleChain</span><span class="o">&amp;</span> <span class="n">SceneDownsampleChain</span><span class="p">);</span>
</pre></div>

<p>This function is called by the general Post Process pipeline and used to build the struct we modified above.</p>
<hr>
<p>Before diving into the callback details, let's finish the setup of the Scene Color setting. So let's jump into <strong>Engine/Source/Runtime/Renderer/Private/PostProcess/PostProcessing.cpp</strong>. Look for the <strong>AddLensFlaresPass()</strong> call and add the Scene Color variable:</p>
<div class="highlight"><pre><span class="n">FScreenPassTexture</span> <span class="n">LensFlares</span> <span class="o">=</span> <span class="n">AddLensFlaresPass</span><span class="p">(</span>
    <span class="n">GraphBuilder</span><span class="p">,</span>
    <span class="n">View</span><span class="p">,</span>
    <span class="n">Bloom</span><span class="p">,</span>
    <span class="n">HalfResolutionSceneColor</span><span class="p">,</span> <span class="c1">// Froyok</span>
    <span class="o">*</span><span class="n">PassInputs</span><span class="p">.</span><span class="n">SceneDownsampleChain</span>
<span class="p">);</span>
</pre></div>

<p>If you are curious, you can take the time to look around in the code to see how things work.</p>
<blockquote>
<p>Note: in UE5 the variable name for the scene color is now <strong>DownsampledSceneColor</strong> instead of HalfResolutionSceneColor. Make sure to adjust your code accordingly.<br>
  Also if Temporal Anti-Aliasing is disabled in your project, the half resolution SceneColor will be invalid. So fall back to <strong>SceneColor.Texture</strong> instead.</p>
</blockquote>
<hr>
<p>We can now go over <strong>/Engine/Source/Runtime/Renderer/Private/PostProcess/PostProcessLensFlares.cpp</strong>. Right at the beginning of the file, just after the includes, we can insert the delegate declaration:</p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"PostProcessLensFlares.h"</span>
<span class="cp">#include</span> <span class="cpf">"PostProcessDownsample.h"</span>

<span class="c1">// Froyok</span>
<span class="n">DECLARE_MULTICAST_DELEGATE_FourParams</span><span class="p">(</span> <span class="n">FPP_LensFlares</span><span class="p">,</span> <span class="n">FRDGBuilder</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">FLensFlareInputs</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">FLensFlareOutputsData</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="n">RENDERER_API</span> <span class="n">FPP_LensFlares</span> <span class="n">PP_LensFlares</span><span class="p">;</span>
</pre></div>

<p>Delegates are basically a way to reference a function from another point of code, it even can be done dynamically at runtime. For more information check out the <a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/" rel="nofollow">documentation</a>.</p>
<p>The <strong>DECLARE_MULTICAST_DELEGATE_FourParams</strong> is a macro which specifies we want to define a function call with 4 parameters. I'm not going over the parameters themselves here as we will see them in a next step.</p>
<hr>
<p>To make comparison easier and help debugging things I added a console variable that allows to switch between the old lens-flare and the new ones. So just below the existing cvar (console variable) at the top of the file add another one like this:</p>
<div class="highlight"><pre><span class="p">[...]</span>
<span class="k">const</span> <span class="n">int32</span> <span class="n">GLensFlareQuadsPerInstance</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="n">TAutoConsoleVariable</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">CVarLensFlareQuality</span><span class="p">(</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">"r.LensFlareQuality"</span><span class="p">),</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 0: off but best for performance</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 1: low quality with good performance</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 2: good quality (default)</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 3: very good quality but bad performance"</span><span class="p">),</span>
    <span class="n">ECVF_Scalability</span> <span class="o">|</span> <span class="n">ECVF_RenderThreadSafe</span><span class="p">);</span>

<span class="c1">// Froyok</span>
<span class="c1">// Console var to switch between the lens-flare methods</span>
<span class="n">TAutoConsoleVariable</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">CVarLensFlareMethod</span><span class="p">(</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">"r.LensFlareMethod"</span><span class="p">),</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 0: Original lens-flare method</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 1: Custom lens-flare method"</span><span class="p">),</span>
    <span class="n">ECVF_RenderThreadSafe</span><span class="p">);</span>
<span class="p">[...]</span>
</pre></div>

<hr>
<p>Scroll down in the file near the bottom and look for the <strong>AddLensFlaresPass()</strong> function but that one with the SceneDownsampleChain input, because we need to add the Scene Color input too:</p>
<div class="highlight"><pre><span class="n">FScreenPassTexture</span> <span class="nf">AddLensFlaresPass</span><span class="p">(</span>
    <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span>
    <span class="n">FScreenPassTexture</span> <span class="n">Bloom</span><span class="p">,</span>
    <span class="n">FScreenPassTexture</span> <span class="n">HalfSceneColor</span><span class="p">,</span> <span class="c1">// Froyok</span>
    <span class="k">const</span> <span class="n">FSceneDownsampleChain</span><span class="o">&amp;</span> <span class="n">SceneDownsampleChain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">ELensFlareQuality</span> <span class="n">LensFlareQuality</span> <span class="o">=</span> <span class="n">GetLensFlareQuality</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">FPostProcessSettings</span><span class="o">&amp;</span> <span class="n">Settings</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">FinalPostProcessSettings</span><span class="p">;</span>
<span class="p">[...]</span>
</pre></div>

<p>Next scroll down to where the LensFlareInputs is declared and feed it the Scene Color:</p>
<div class="highlight"><pre><span class="p">[...]</span>
<span class="n">FLensFlareInputs</span> <span class="n">LensFlareInputs</span><span class="p">;</span>
<span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">Bloom</span> <span class="o">=</span> <span class="n">Bloom</span><span class="p">;</span>
<span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">HalfSceneColor</span> <span class="o">=</span> <span class="n">HalfSceneColor</span><span class="p">;</span> <span class="c1">// Froyok</span>
<span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">Flare</span> <span class="o">=</span> <span class="n">SceneDownsampleChain</span><span class="p">.</span><span class="n">GetTexture</span><span class="p">(</span><span class="n">LensFlareDownsampleStageIndex</span><span class="p">);</span>
<span class="p">[...]</span>
</pre></div>

<p>Finally we change the original code from this:</p>
<div class="highlight"><pre><span class="p">[...]</span>
    <span class="c1">// If a bloom output texture isn't available, substitute the half resolution scene color instead, but disable bloom</span>
    <span class="c1">// composition. The pass needs a primary input in order to access the image descriptor and viewport for output.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Bloom</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">Bloom</span> <span class="o">=</span> <span class="n">SceneDownsampleChain</span><span class="p">.</span><span class="n">GetFirstTexture</span><span class="p">();</span>
        <span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">bCompositeWithBloom</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">AddLensFlaresPass</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">View</span><span class="p">,</span> <span class="n">LensFlareInputs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>Into this:</p>
<div class="highlight"><pre>    <span class="c1">// If a bloom output texture isn't available, substitute the half resolution scene color instead, but disable bloom</span>
    <span class="c1">// composition. The pass needs a primary input in order to access the image descriptor and viewport for output.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Bloom</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">Bloom</span> <span class="o">=</span> <span class="n">SceneDownsampleChain</span><span class="p">.</span><span class="n">GetFirstTexture</span><span class="p">();</span>
        <span class="n">LensFlareInputs</span><span class="p">.</span><span class="n">bCompositeWithBloom</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Froyok</span>
    <span class="n">int32</span> <span class="n">UseCustomFlare</span> <span class="o">=</span> <span class="n">CVarLensFlareMethod</span><span class="p">.</span><span class="n">GetValueOnRenderThread</span><span class="p">();</span>

    <span class="n">FLensFlareOutputsData</span> <span class="n">Outputs</span><span class="p">;</span>
    <span class="n">Outputs</span><span class="p">.</span><span class="n">Texture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">Outputs</span><span class="p">.</span><span class="n">Rect</span>    <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">UseCustomFlare</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PP_LensFlares</span><span class="p">.</span><span class="n">Broadcast</span><span class="p">(</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">View</span><span class="p">,</span> <span class="n">LensFlareInputs</span><span class="p">,</span> <span class="n">Outputs</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">UseCustomFlare</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">Outputs</span><span class="p">.</span><span class="n">Texture</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">AddLensFlaresPass</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">View</span><span class="p">,</span> <span class="n">LensFlareInputs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">FScreenPassTexture</span><span class="p">(</span> <span class="n">Outputs</span><span class="p">.</span><span class="n">Texture</span><span class="p">,</span> <span class="n">Outputs</span><span class="p">.</span><span class="n">Rect</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Here is what happens here:</p>
<ul>
<li>We retrieve the cvar value</li>
<li>We generate a default struct for the lens-flare pass results</li>
<li>If the cvar is not 0, we broadcast the signal to trigger the functions that are attached to the delegate</li>
<li>If the cvar is 0 or if the result of the broadcast returned an invalid texture we run the original lens-flare pass of the engine</li>
<li>Otherwise we return a special texture made from the result of our custom fens-flare pass.</li>
</ul>
<p>You can even compile and run the engine/editor. Nothing will have changed visually but we now have a way to hook into the fens-flare pass.</p>
<blockquote>
<p>Like I mentioned I kept the original lens-flare code pass for debug purpose, but on a more mature project I would suggest removing this pass altogether. Especially since it requires compiling shaders that may never be used, etc.</p>
</blockquote>
<hr>
<a id="step_5_custom_subsystem"></a><h2>Step 5: Custom Subsystem</h2>
<p>Now that the hook is in place, we need a place to manage our own rendering code. I initially went with the <strong>Game Instance</strong> class of my project but going this route meant that the lens-flare code wouldn't run until the game itself is running (or it may not be properly updated). I wanted something that would work in any context in-editor. Plus it would create difficulties with the Global Shader references.</p>
<p>The solution I went for instead was to create an <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/" rel="nofollow">Engine Subsystem</a>. Subsystems are singleton managed by the engine itself which can be easily retrieved from anywhere in the game code. There are different type depending on the context they live in. The particularity of the engine subsystem is that is starts and stops with the engine, making it compatible with the editor context.</p>
<p>So create a new class inherited from <strong>EngineSubsystem</strong> in the plugin. Mine is simply called <strong>PostProcessSubsystem</strong>.</p>
<p><strong>PostProcessSubsystem.h</strong></p>
<div class="highlight"><pre><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">"CoreMinimal.h"</span>
<span class="cp">#include</span> <span class="cpf">"PostProcess/PostProcessLensFlares.h" // For PostProcess delegate</span>
<span class="cp">#include</span> <span class="cpf">"PostProcessSubsystem.generated.h"</span>

<span class="n">DECLARE_MULTICAST_DELEGATE_FourParams</span><span class="p">(</span> <span class="n">FPP_LensFlares</span><span class="p">,</span> <span class="n">FRDGBuilder</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">FLensFlareInputs</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">FLensFlareOutputsData</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="k">extern</span> <span class="n">RENDERER_API</span> <span class="n">FPP_LensFlares</span> <span class="n">PP_LensFlares</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">UPostProcessLensFlareAsset</span><span class="p">;</span>

<span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">MYPROJECT_API</span> <span class="nl">UPostProcessSubsystem</span> <span class="p">:</span> <span class="k">public</span> <span class="n">UEngineSubsystem</span>
<span class="p">{</span>
    <span class="n">GENERATED_BODY</span><span class="p">()</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// Init function to setup the delegate and load the data asset</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">FSubsystemCollectionBase</span><span class="o">&amp;</span> <span class="n">Collection</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="c1">// Used for cleanup</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Deinitialize</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="c1">// The reference to the data asset storing the settings</span>
        <span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Transient</span><span class="p">)</span>
        <span class="n">UPostProcessLensFlareAsset</span><span class="o">*</span> <span class="n">PostProcessAsset</span><span class="p">;</span>

        <span class="c1">// Called by engine delegate Render Thread</span>
        <span class="kt">void</span> <span class="nf">RenderLensFlare</span><span class="p">(</span>
            <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> 
            <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span> 
            <span class="k">const</span> <span class="n">FLensFlareInputs</span><span class="o">&amp;</span> <span class="n">Inputs</span><span class="p">,</span> 
            <span class="n">FLensFlareOutputsData</span><span class="o">&amp;</span> <span class="n">Outputs</span> 
        <span class="p">);</span>

        <span class="c1">// Threshold prender pass</span>
        <span class="n">FRDGTextureRef</span> <span class="nf">RenderThreshold</span><span class="p">(</span>
            <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
            <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
        <span class="p">);</span>

        <span class="c1">// Ghosts + Halo render pass</span>
        <span class="n">FRDGTextureRef</span> <span class="nf">RenderFlare</span><span class="p">(</span>
            <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
            <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
        <span class="p">);</span>

        <span class="c1">// Glare render pass</span>
        <span class="n">FRDGTextureRef</span> <span class="nf">RenderGlare</span><span class="p">(</span>
            <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
            <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
        <span class="p">);</span>

        <span class="c1">// Sub-pass for blurring</span>
        <span class="n">FRDGTextureRef</span> <span class="nf">RenderBlur</span><span class="p">(</span>
            <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">Viewport</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">BlurSteps</span>
        <span class="p">);</span>

        <span class="c1">// Cached blending and sampling states</span>
        <span class="c1">// which are re-used across render passes</span>
        <span class="n">FRHIBlendState</span><span class="o">*</span> <span class="n">ClearBlendState</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">FRHIBlendState</span><span class="o">*</span> <span class="n">AdditiveBlendState</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

        <span class="n">FRHISamplerState</span><span class="o">*</span> <span class="n">BilinearClampSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">FRHISamplerState</span><span class="o">*</span> <span class="n">BilinearBorderSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">FRHISamplerState</span><span class="o">*</span> <span class="n">BilinearRepeatSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">FRHISamplerState</span><span class="o">*</span> <span class="n">NearestRepeatSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>Let's review a few things here:</p>
<ul>
<li>At the top of the file we declare the delegate once again to link it to the version from the engine. Then on the next line we declare the object via the extern definition.</li>
<li>The <strong>UPostProcessLensFlareAsset</strong> is just a basic forward declaration.</li>
<li><strong>Initialize()</strong> and <strong>Deinitialize()</strong> are the default function from subsystems, which we override as we will need to setup a few things.</li>
<li>The <strong>PostProcessAsset</strong> will be our reference to the asset in the content browser from which we will retrieve our rendering parameters.</li>
<li><strong>RenderLensFlare</strong>, <strong>RenderThreshold</strong>, <strong>RenderFlare</strong>, <strong>RenderGlare</strong> and <strong>RenderBlur</strong> are the various rendering function we are gonna use to render the different passes.</li>
<li><strong>FRHIBlendState</strong> and <strong>FRHISamplerState</strong> are several parameters that are gonna be used across the passes. There are declared here to be more easily shareable.</li>
</ul>
<hr>
<p><strong>PostProcessSubsystem.cpp</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"PostProcessSubsystem.h"</span>
<span class="cp">#include</span> <span class="cpf">"PostProcessLensFlareAsset.h"</span>

<span class="cp">#include</span> <span class="cpf">"RenderGraph.h"</span>
<span class="cp">#include</span> <span class="cpf">"ScreenPass.h"</span>
<span class="cp">#include</span> <span class="cpf">"PostProcess/PostProcessLensFlares.h"</span>

<span class="k">namespace</span>
<span class="p">{</span>
    <span class="c1">// TODO_SHADER_SCREENPASS</span>

    <span class="c1">// TODO_SHADER_RESCALE</span>

    <span class="c1">// TODO_SHADER_DOWNSAMPLE</span>

    <span class="c1">// TODO_SHADER_KAWASE</span>

    <span class="c1">// TODO_SHADER_CHROMA</span>

    <span class="c1">// TODO_SHADER_GHOSTS</span>

    <span class="c1">// TODO_SHADER_HALO</span>

    <span class="c1">// TODO_SHADER_GLARE</span>

    <span class="c1">// TODO_SHADER_MIX</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span> <span class="n">FSubsystemCollectionBase</span><span class="o">&amp;</span> <span class="n">Collection</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Super</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span> <span class="n">Collection</span> <span class="p">);</span>

    <span class="c1">//--------------------------------</span>
    <span class="c1">// Delegate setup</span>
    <span class="c1">//--------------------------------</span>
    <span class="n">FPP_LensFlares</span><span class="o">::</span><span class="n">FDelegate</span> <span class="n">Delegate</span> <span class="o">=</span> <span class="n">FPP_LensFlares</span><span class="o">::</span><span class="n">FDelegate</span><span class="o">::</span><span class="n">CreateLambda</span><span class="p">(</span>
        <span class="p">[</span><span class="o">=</span><span class="p">](</span> <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span> <span class="k">const</span> <span class="n">FLensFlareInputs</span><span class="o">&amp;</span> <span class="n">Inputs</span><span class="p">,</span> <span class="n">FLensFlareOutputsData</span><span class="o">&amp;</span> <span class="n">Outputs</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RenderLensFlare</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">View</span><span class="p">,</span> <span class="n">Inputs</span><span class="p">,</span> <span class="n">Outputs</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="n">ENQUEUE_RENDER_COMMAND</span><span class="p">(</span><span class="n">BindRenderThreadDelegates</span><span class="p">)([</span><span class="n">Delegate</span><span class="p">](</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PP_LensFlares</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">Delegate</span><span class="p">);</span>
    <span class="p">});</span>


    <span class="c1">//--------------------------------</span>
    <span class="c1">// Data asset loading</span>
    <span class="c1">//--------------------------------</span>
    <span class="n">FString</span> <span class="n">Path</span> <span class="o">=</span> <span class="s">"PostProcessLensFlareAsset'/CustomPostProcess/DefaultLensFlare.DefaultLensFlare'"</span><span class="p">;</span>

    <span class="n">PostProcessAsset</span> <span class="o">=</span> <span class="n">LoadObject</span><span class="o">&lt;</span><span class="n">UPostProcessLensFlareAsset</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">*</span><span class="n">Path</span> <span class="p">);</span>
    <span class="n">check</span><span class="p">(</span><span class="n">PostProcessAsset</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">Deinitialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ClearBlendState</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">AdditiveBlendState</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">BilinearClampSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">BilinearBorderSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">BilinearRepeatSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">NearestRepeatSampler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The <strong>namespace</strong> is used to declare our global shaders without producing any conflicts with any existing ones on the engine side. The <strong>TODOs</strong> here will be replaced by actual code in the next steps.</p>
<p>Bellow that, the <strong>Initialize()</strong> function does two big things:</p>
<ul>
<li>The <strong>delegate</strong> setup is done during this part. It's where we define which internal function will called when the delegate broadcast is triggered by the engine. This is done by building the delegate object via a lambda function and then using the <strong>ENQUEUE_RENDER_COMMAND</strong> to register things together.</li>
<li>Next is the loading of the Data Asset that was created earlier. Since the function is not part of a constructor, I use the <strong>LoadObject()</strong> helper to load the asset instead of <strong>FObjectFinder</strong>. This is where you need to replace the path with yours.</li>
</ul>
<blockquote>
<p>I have been told that the way I setup and connect the delegate here may not be thread safe. I didn't encounter any crashes related to that issue myself, but be aware that this code may not be suited for production as-is.<br>
  A suggestion I received to fix this problem (which I may do in the future and update the article) is to move the rendering code into a sub-class and store it in a thread safe pointer (<strong>TSharedPtr</strong>) made with <strong>CreateShared()</strong>.</p>
</blockquote>
<hr>
<a id="step_6_utility_functions"></a><h2>Step 6: Utility Functions</h2>
<p>Each render pass use the same basics and the original engine code has a tendency of copy/pasting the same code. So to cleanup and make things easier for iteration I factored some code into more convenient to use functions that are then used by each pass. The following functions are added as-is in the <strong>PostProcessSubsystem.cpp</strong> (without the need to declare them in the header).</p>
<hr>
<p>The goal of this function is to compute the sub-region size and output a scale to rescale the buffer. This will be useful in-editor during the Threshold pass. Most of the code is copy pasted from the engine itself (see the comment).</p>
<div class="highlight"><pre><span class="n">FVector2D</span> <span class="nf">GetInputViewportSize</span><span class="p">(</span> <span class="k">const</span> <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">Input</span><span class="p">,</span> <span class="k">const</span> <span class="n">FIntPoint</span><span class="o">&amp;</span> <span class="n">Extent</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Based on</span>
    <span class="c1">// GetScreenPassTextureViewportParameters()</span>
    <span class="c1">// Engine/Source/Runtime/Renderer/Private/ScreenPass.cpp</span>

    <span class="n">FVector2D</span> <span class="n">ExtentInverse</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">Extent</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">Extent</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>

    <span class="n">FVector2D</span> <span class="n">RectMin</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">Min</span><span class="p">);</span>
    <span class="n">FVector2D</span> <span class="n">RectMax</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">Max</span><span class="p">);</span>

    <span class="n">FVector2D</span> <span class="n">Min</span> <span class="o">=</span> <span class="n">RectMin</span> <span class="o">*</span> <span class="n">ExtentInverse</span><span class="p">;</span>
    <span class="n">FVector2D</span> <span class="n">Max</span> <span class="o">=</span> <span class="n">RectMax</span> <span class="o">*</span> <span class="n">ExtentInverse</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">Max</span> <span class="o">-</span> <span class="n">Min</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<hr>
<p>Next is the most important function: it's the actual draw that will be registered to the Render Graph:</p>
<div class="highlight"><pre><span class="c1">// The function that draw a shader into a given RenderGraph texture</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TShaderParameters</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TShaderClassVertex</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TShaderClassPixel</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">DrawShaderPass</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FString</span><span class="o">&amp;</span> <span class="n">PassName</span><span class="p">,</span>
        <span class="n">TShaderParameters</span><span class="o">*</span> <span class="n">PassParameters</span><span class="p">,</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">TShaderClassVertex</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">,</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">TShaderClassPixel</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">,</span>
        <span class="n">FRHIBlendState</span><span class="o">*</span> <span class="n">BlendState</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">Viewport</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">FScreenPassPipelineState</span> <span class="n">PipelineState</span><span class="p">(</span><span class="n">VertexShader</span><span class="p">,</span> <span class="n">PixelShader</span><span class="p">,</span> <span class="n">BlendState</span><span class="p">);</span>

    <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AddPass</span><span class="p">(</span>
        <span class="n">FRDGEventName</span><span class="p">(</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"%s"</span><span class="p">),</span> <span class="o">*</span><span class="n">PassName</span> <span class="p">),</span>
        <span class="n">PassParameters</span><span class="p">,</span>
        <span class="n">ERDGPassFlags</span><span class="o">::</span><span class="n">Raster</span><span class="p">,</span>
        <span class="p">[</span><span class="n">PixelShader</span><span class="p">,</span> <span class="n">PassParameters</span><span class="p">,</span> <span class="n">Viewport</span><span class="p">,</span> <span class="n">PipelineState</span><span class="p">]</span> <span class="p">(</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RHICmdList</span><span class="p">.</span><span class="n">SetViewport</span><span class="p">(</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Viewport</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Viewport</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="mf">1.0f</span>
        <span class="p">);</span>

        <span class="n">SetScreenPassPipelineState</span><span class="p">(</span><span class="n">RHICmdList</span><span class="p">,</span> <span class="n">PipelineState</span><span class="p">);</span>

        <span class="n">SetShaderParameters</span><span class="p">(</span>
            <span class="n">RHICmdList</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">.</span><span class="n">GetPixelShader</span><span class="p">(),</span>
            <span class="o">*</span><span class="n">PassParameters</span>
        <span class="p">);</span>

        <span class="n">DrawRectangle</span><span class="p">(</span>
            <span class="n">RHICmdList</span><span class="p">,</span>                             <span class="c1">// FRHICommandList</span>
            <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>                             <span class="c1">// float X, float Y</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Width</span><span class="p">(),</span>   <span class="n">Viewport</span><span class="p">.</span><span class="n">Height</span><span class="p">(),</span>  <span class="c1">// float SizeX, float SizeY</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">X</span><span class="p">,</span>     <span class="n">Viewport</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span>     <span class="c1">// float U, float V</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Width</span><span class="p">(),</span>                       <span class="c1">// float SizeU</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Height</span><span class="p">(),</span>                      <span class="c1">// float SizeV</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Size</span><span class="p">(),</span>                        <span class="c1">// FIntPoint TargetSize</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Size</span><span class="p">(),</span>                        <span class="c1">// FIntPoint TextureSize</span>
            <span class="n">PipelineState</span><span class="p">.</span><span class="n">VertexShader</span><span class="p">,</span>             <span class="c1">// const TShaderRefBase VertexShader</span>
            <span class="n">EDrawRectangleFlags</span><span class="o">::</span><span class="n">EDRF_Default</span>       <span class="c1">// EDrawRectangleFlags Flags</span>
        <span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>

<p>This is a template function because in order to register a pass in RDG you need to build a lambda function and pass to it a Vertex and Pixel shader. Because of the way those are built, there is no parent class to cast from, etc. Therefor the argument type passed to the function much match.</p>
<p>The parameters themselves are pretty basic, it's mostly the properties that will be used to define the render region and which shader will be used to draw something.</p>
<ul>
<li><strong>FScreenPassPipelineState</strong> is used to define how the rendering will be performed. It can be used to setup the Stencil mask, etc. In our case it's only to change the blending mode (over, add, sub, max, etc).</li>
<li><strong>AddPass()</strong> is used to register a pass via a Lambda function attached to it.</li>
<li><strong>FRDGEventName()</strong> is used to give a name to the pass, which will appear in a graphic debugger (like RenderDoc)</li>
<li><strong>RHICmdList</strong> is used to send command to the RHI (<strong>R</strong>endering <strong>H</strong>ardware <strong>I</strong>nterface aka the graphic API abstraction layer). In this case <strong>SetViewport()</strong> is used to define which area of the target buffer is gonna be drawn.</li>
<li><strong>SetShaderParameters()</strong> is pretty explicit, shader parameter are defined before hand and then passed on via this function.</li>
<li><strong>DrawRectangle()</strong> is the final function. It's a helper to draw a quad on a buffer without having to build the mesh data ourselves. All the information passed to it only serve the purpose of defining where and at which size the quad should be drawn. The quad size is independent from the UV size which can be useful for example when drawing a sub-region of the buffer as the quad would only cover the updated area and the UV scaled to adjust to the actual buffer size. However in our case the quad size and its UVs won't differ as we will always update the full buffer.</li>
</ul>
<hr>
<a id="step_7_main_render_function"></a><h2>Step 7: Main Render Function</h2>
<p>We can now dive into the actual rendering work. As shown previously in the <strong>Initialize()</strong> function, the delegate is associated with the <strong>RenderLensFlare()</strong> function.</p>
<p>Let's start first by adding a few "tools": I added a few console variables that will be used to skip some steps of the rendering process to help debug effects. </p>
<p>I also added a new GPU stat event via <strong>DECLARE_GPU_STAT</strong> to see the render time of the effect via the live GPU profiler of the engine. For more information see the <a href="https://docs.unrealengine.com/4.26/en-US/TestingAndOptimization/PerformanceAndProfiling/GPU/" rel="nofollow">official documentation</a>.</p>
<div class="highlight"><pre><span class="n">TAutoConsoleVariable</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">CVarLensFlareRenderBloom</span><span class="p">(</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">"r.LensFlare.RenderBloom"</span><span class="p">),</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 0: Don't mix Bloom into lens-flare</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 1: Mix the Bloom into the lens-flare"</span><span class="p">),</span>
    <span class="n">ECVF_RenderThreadSafe</span><span class="p">);</span>

<span class="n">TAutoConsoleVariable</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">CVarLensFlareRenderFlarePass</span><span class="p">(</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">"r.LensFlare.RenderFlare"</span><span class="p">),</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 0: Don't render flare pass</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 1: Render flare pass (ghosts and halos)"</span><span class="p">),</span>
    <span class="n">ECVF_RenderThreadSafe</span><span class="p">);</span>

<span class="n">TAutoConsoleVariable</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">CVarLensFlareRenderGlarePass</span><span class="p">(</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">"r.LensFlare.RenderGlare"</span><span class="p">),</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 0: Don't render glare pass</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">TEXT</span><span class="p">(</span><span class="s">" 1: Render flare pass (star shape)"</span><span class="p">),</span>
    <span class="n">ECVF_RenderThreadSafe</span><span class="p">);</span>

<span class="n">DECLARE_GPU_STAT</span><span class="p">(</span><span class="n">LensFlaresFroyok</span><span class="p">)</span>
</pre></div>

<hr>
<p>Let's dive into the actual function now.</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderLensFlare</span><span class="p">(</span>
    <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FLensFlareInputs</span><span class="o">&amp;</span> <span class="n">Inputs</span><span class="p">,</span> 
    <span class="n">FLensFlareOutputsData</span><span class="o">&amp;</span> <span class="n">Outputs</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="n">Inputs</span><span class="p">.</span><span class="n">Bloom</span><span class="p">.</span><span class="n">IsValid</span><span class="p">());</span>
    <span class="n">check</span><span class="p">(</span><span class="n">Inputs</span><span class="p">.</span><span class="n">HalfSceneColor</span><span class="p">.</span><span class="n">IsValid</span><span class="p">());</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">PostProcessAsset</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">RDG_GPU_STAT_SCOPE</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">LensFlaresFroyok</span><span class="p">)</span>
    <span class="n">RDG_EVENT_SCOPE</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="s">"LensFlaresFroyok"</span><span class="p">);</span>

<span class="p">[...]</span>
</pre></div>

<p>The checks here are to be sure we don't run the rendering pass on invalid data. We also check that the Data Asset is valid. Then we register the GPU stat event. This is done here because <strong>RenderLensFlare()</strong> is ran on the render thread.</p>
<hr>
<p>Next is the setup of a few variables that are re-used between some of the passes followed by the actual rendering functions call:</p>
<div class="highlight"><pre><span class="p">[...]</span>

    <span class="k">const</span> <span class="n">FScreenPassTextureViewport</span> <span class="n">BloomViewport</span><span class="p">(</span><span class="n">Inputs</span><span class="p">.</span><span class="n">Bloom</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">FVector2D</span> <span class="n">BloomInputViewportSize</span> <span class="o">=</span> <span class="n">GetInputViewportSize</span><span class="p">(</span> <span class="n">BloomViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">,</span> <span class="n">BloomViewport</span><span class="p">.</span><span class="n">Extent</span> <span class="p">);</span>

    <span class="k">const</span> <span class="n">FScreenPassTextureViewport</span> <span class="nf">SceneColorViewport</span><span class="p">(</span><span class="n">Inputs</span><span class="p">.</span><span class="n">HalfSceneColor</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">FVector2D</span> <span class="n">SceneColorViewportSize</span> <span class="o">=</span> <span class="n">GetInputViewportSize</span><span class="p">(</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">,</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Extent</span> <span class="p">);</span>

    <span class="c1">// Input</span>
    <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">HalfSceneColor</span><span class="p">.</span><span class="n">Texture</span><span class="p">;</span>
    <span class="n">FIntRect</span> <span class="n">InputRect</span> <span class="o">=</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">;</span>

    <span class="c1">// Outputs</span>
    <span class="n">FRDGTextureRef</span> <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">HalfSceneColor</span><span class="p">.</span><span class="n">Texture</span><span class="p">;</span>
    <span class="n">FIntRect</span> <span class="n">OutputRect</span> <span class="o">=</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">;</span>

    <span class="c1">// States</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">ClearBlendState</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Blend modes from:</span>
        <span class="c1">// '/Engine/Source/Runtime/RenderCore/Private/ClearQuad.cpp'</span>
        <span class="c1">// '/Engine/Source/Runtime/Renderer/Private/PostProcess/PostProcessMaterial.cpp'</span>
        <span class="n">ClearBlendState</span> <span class="o">=</span> <span class="n">TStaticBlendState</span><span class="o">&lt;&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
        <span class="n">AdditiveBlendState</span> <span class="o">=</span> <span class="n">TStaticBlendState</span><span class="o">&lt;</span><span class="n">CW_RGB</span><span class="p">,</span> <span class="n">BO_Add</span><span class="p">,</span> <span class="n">BF_One</span><span class="p">,</span> <span class="n">BF_One</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>

        <span class="n">BilinearClampSampler</span> <span class="o">=</span> <span class="n">TStaticSamplerState</span><span class="o">&lt;</span><span class="n">SF_Bilinear</span><span class="p">,</span> <span class="n">AM_Clamp</span><span class="p">,</span> <span class="n">AM_Clamp</span><span class="p">,</span> <span class="n">AM_Clamp</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
        <span class="n">BilinearBorderSampler</span> <span class="o">=</span> <span class="n">TStaticSamplerState</span><span class="o">&lt;</span><span class="n">SF_Bilinear</span><span class="p">,</span> <span class="n">AM_Border</span><span class="p">,</span> <span class="n">AM_Border</span><span class="p">,</span> <span class="n">AM_Border</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
        <span class="n">BilinearRepeatSampler</span> <span class="o">=</span> <span class="n">TStaticSamplerState</span><span class="o">&lt;</span><span class="n">SF_Bilinear</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
        <span class="n">NearestRepeatSampler</span> <span class="o">=</span> <span class="n">TStaticSamplerState</span><span class="o">&lt;</span><span class="n">SF_Point</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
    <span class="p">}</span>


    <span class="c1">// TODO_RESCALE</span>


    <span class="c1">////////////////////////////////////////////////////////////////////////</span>
    <span class="c1">// Render passes</span>
    <span class="c1">////////////////////////////////////////////////////////////////////////</span>
    <span class="n">FRDGTextureRef</span> <span class="n">ThresholdTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">FRDGTextureRef</span> <span class="n">FlareTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">FRDGTextureRef</span> <span class="n">GlareTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">ThresholdTexture</span> <span class="o">=</span> <span class="n">RenderThreshold</span><span class="p">(</span>
        <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">InputTexture</span><span class="p">,</span>
        <span class="n">InputRect</span><span class="p">,</span>
        <span class="n">View</span>
    <span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">CVarLensFlareRenderFlarePass</span><span class="p">.</span><span class="n">GetValueOnRenderThread</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FlareTexture</span> <span class="o">=</span> <span class="n">RenderFlare</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">ThresholdTexture</span><span class="p">,</span>
            <span class="n">InputRect</span><span class="p">,</span>
            <span class="n">View</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">CVarLensFlareRenderGlarePass</span><span class="p">.</span><span class="n">GetValueOnRenderThread</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">GlareTexture</span> <span class="o">=</span> <span class="n">RenderGlare</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">ThresholdTexture</span><span class="p">,</span>
            <span class="n">InputRect</span><span class="p">,</span>
            <span class="n">View</span>
        <span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// TODO_MIX</span>


    <span class="c1">////////////////////////////////////////////////////////////////////////</span>
    <span class="c1">// Final Output</span>
    <span class="c1">////////////////////////////////////////////////////////////////////////</span>
    <span class="n">Outputs</span><span class="p">.</span><span class="n">Texture</span> <span class="o">=</span> <span class="n">OutputTexture</span><span class="p">;</span>
    <span class="n">Outputs</span><span class="p">.</span><span class="n">Rect</span>    <span class="o">=</span> <span class="n">OutputRect</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// End RenderLensFlare()</span>
</pre></div>

<p>Same as the shaders, the <strong>TODOs</strong> here will be covered in the next steps.</p>
<p>The <strong>FScreenPassTextureViewport</strong> and <strong>FVector2D</strong> are used to compute the input buffers properties. This is followed by <strong>FRDGTextureRef OutputTexture</strong> which is the output texture that will be stored in the <strong>Outputs</strong> struct and fed back to the engine. <strong>FRDGTextureRef</strong> are simply pointers to RDG textures.</p>
<p>Next is the initialization of the various states. They are initialized here because we need access to the RHI which is only available via the render thread.</p>
<p>The rest should be pretty much self-explanatory. Notice that some render function call are but behind if condition which look at the cvar states. This is how the newly declared cvars can drive the rendering passes.</p>
<hr>
<p>We now have the main render function in place, so let's add the sub-steps below:</p>
<div class="highlight"><pre><span class="n">FRDGTextureRef</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderBlur</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">Viewport</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">BlurSteps</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// TODO_BLUR</span>
<span class="p">}</span>

<span class="n">FRDGTextureRef</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderThreshold</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
        <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// TODO_THRESHOLD</span>

    <span class="c1">// TODO_THRESHOLD_BLUR</span>
<span class="p">}</span>

<span class="n">FRDGTextureRef</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderFlare</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
        <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// TODO_FLARE_CHROMA</span>

    <span class="c1">// TODO_FLARE_GHOSTS</span>

    <span class="c1">// TODO_FLARE_HALO</span>
<span class="p">}</span>

<span class="n">FRDGTextureRef</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderGlare</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
        <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// TODO_GLARE</span>
<span class="p">}</span>
</pre></div>

<hr>
<a id="step_8_common_shader"></a><h2>Step 8: Common Shader</h2>
<blockquote>
<p>The next steps focus on replacing the TODOs that were left off.<br>
  The way things are presented is that <strong>each TODO</strong> mentioned will be <strong>replaced</strong> by the code sitting just below it in this step and the others following.</p>
</blockquote>
<p>We now need to setup a common shader. In order to render in our buffer, we need at least a Vertex and Pixel shader. While the pixel shader will be different for each pass, the vertex shader will be mostly the same for all passes since we will be only rendering a quad.</p>
<p><strong>TODO_SHADER_SCREENPASS</strong></p>
<div class="highlight"><pre>    <span class="c1">// RDG buffer input shared by all passes</span>
    <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">SHADER_PARAMETER_RDG_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">InputTexture</span><span class="p">)</span>
        <span class="n">RENDER_TARGET_BINDING_SLOTS</span><span class="p">()</span>
    <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

    <span class="c1">// The vertex shader to draw a rectangle.</span>
    <span class="k">class</span> <span class="nc">FCustomScreenPassVS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FCustomScreenPassVS</span><span class="p">);</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="nf">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">FCustomScreenPassVS</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="n">FCustomScreenPassVS</span><span class="p">(</span><span class="k">const</span> <span class="n">ShaderMetaType</span><span class="o">::</span><span class="n">CompiledShaderInitializerType</span><span class="o">&amp;</span> <span class="n">Initializer</span><span class="p">)</span>
                <span class="o">:</span> <span class="n">FGlobalShader</span><span class="p">(</span><span class="n">Initializer</span><span class="p">)</span>
            <span class="p">{}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FCustomScreenPassVS</span><span class="p">,</span> <span class="s">"/CustomShaders/ScreenPass.usf"</span><span class="p">,</span> <span class="s">"CustomScreenPassVS"</span><span class="p">,</span> <span class="n">SF_Vertex</span><span class="p">);</span>
</pre></div>

<p>On the first lines, the <strong>BEGIN_SHADER_PARAMETER_STRUCT</strong> macro allows to define a series of properties as shader parameters. Like in HLSL or GLSL, this macro allows to build a struct with its own set of parameters to feed to a shader program later. The first macro simply defines the name of the struct and anything after that until <strong>END_SHADER_PARAMETER_STRUCT</strong> is the list of properties associated to it.<br>
<strong>SHADER_PARAMETER_RDG_TEXTURE</strong> is a texture input for RDG buffers. Render targets and other Texture2D types use a different macro. <strong>RENDER_TARGET_BINDING_SLOTS</strong> adds complementary parameters to ensure the buffer can be attached to the shader. For more information, the macro definitions can be found in <strong>Engine/Source/Runtime/RenderCore/Public/ShaderParameterMacros.h</strong>.</p>
<p>A global shader is basically a C++ class that inherits from <strong>FGlobalShader</strong>. Then to specify the actual HLSL file to load to compile the shader program, we use the macro <strong>IMPLEMENT_GLOBAL_SHADER</strong> which takes four arguments:</p>
<ul>
<li><strong>the C++ class</strong>: the one we created just above</li>
<li><strong>the symbolic path</strong>: this is the location of the usf file but based on the symbolic path we defined in the module.</li>
<li><strong>the function name</strong>: this is the name of the function in the shader file that we want to load.</li>
<li><strong>the shader type</strong>: like in any other language, you need to specify if you are loading a Vertex shader, Pixel shader, etc. This is an enum that specify which kind of program it is.</li>
</ul>
<blockquote>
<p>You can notice that the shader name ends with VS, this stands for <strong>V</strong>ertex <strong>S</strong>hader. You will see PS (pixel Shader) and GS (geometry Shader) later on as well. Also if you want to know more about global shaders, check out the official <a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/Rendering/ShaderDevelopment/AddingGlobalShaders/" rel="nofollow">Unreal Engine documentation</a>.</p>
</blockquote>
<hr>
<p>Now for the shader file itself:</p>
<p><strong>ScreenPass.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="kt">void</span> <span class="nf">CustomScreenPassVS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">float4</span> <span class="nl">InPosition</span> <span class="p">:</span> <span class="n">ATTRIBUTE0</span><span class="p">,</span>
    <span class="n">in</span> <span class="n">float2</span> <span class="nl">InTexCoord</span> <span class="p">:</span> <span class="n">ATTRIBUTE1</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">OutUVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float4</span> <span class="nl">OutPosition</span> <span class="p">:</span> <span class="n">SV_POSITION</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">DrawRectangle</span><span class="p">(</span><span class="n">InPosition</span><span class="p">,</span> <span class="n">InTexCoord</span><span class="p">,</span> <span class="n">OutPosition</span><span class="p">,</span> <span class="n">OutUVAndScreenPos</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>It basically just call an existing engine function to build a quad. Nothing special.</p>
<hr>
<a id="step_9_rescale_pass"></a><h2>Step 9: Rescale Pass</h2>
<p>The <strong>rescale</strong> pass is our first "real" rendering pass (but it can be optional). If you recall the original lens-flare description I wrote, the rendering of the effect is done in a sub-region in some cases (notably in-editor). </p>
<p>At first I tried to keep my code as-is but this complicated quite a lot the following passes as the input buffers had to be adjusted with custom UV coordinates. In order to simplify the code, I choose to add an optional render pass at the beginning of the main rendering pass to compensate the sub-region rendering. Basically what the code does is a copy of the sub-region in a buffer of the same size as the region. This eliminates the need to manipulate UVs afterward.</p>
<p>In editor this translate to the same visual result and same performance as long as the rendering size doesn't change. The only different is that switching to fullscreen or resizing the viewport can lead to some stutters because of the buffer reallocations, but to me this is an acceptable trade-off.</p>
<p><strong>TODO_SHADER_RESCALE</strong></p>
<div class="highlight"><pre>    <span class="cp">#if WITH_EDITOR</span>
    <span class="c1">// Rescale shader</span>
    <span class="k">class</span> <span class="nc">FLensFlareRescalePS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareRescalePS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareRescalePS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">InputViewportSize</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareRescalePS</span><span class="p">,</span> <span class="s">"/CustomShaders/Rescale.usf"</span><span class="p">,</span> <span class="s">"RescalePS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
    <span class="cp">#endif</span>
</pre></div>

<p>I use the "<strong>#if WITH_EDITOR</strong>" define to ensure the code here is only available when compiling with the editor support. This means that when shipping the project in the future, this part will be discarded at compilation time.</p>
<p>Like I demonstrated in the previous step, we start by declaring a new class inheriting <strong>FGlobalShader</strong>. The big difference here is the use of new macros to define a few parameters:</p>
<ul>
<li><strong>SHADER_PARAMETER_STRUCT_INCLUDE</strong>: references the first shader struct we made. We use it here to add the buffer texture input.</li>
<li><strong>SHADER_PARAMETER_SAMPLER</strong>: this declares a new sampler parameter. Samplers can be shared between any type of texture, buffers, etc (as long as they are 2D).</li>
<li><strong>SHADER_PARAMETER</strong>: this declares a parameter of the given type and then its name. Here I use a <em>FVector2D</em> that will translate into a <em>float2</em> in the HLSL file.</li>
<li>In <strong>IMPLEMENT_GLOBAL_SHADER</strong> you can notice that I'm using <strong>SF_Pixel</strong> this time since it's a Pixel shader.</li>
</ul>
<p>This shader doesn't need much parameters: we only need the buffer, a sampler to read it and a float2 to rescale the input image.</p>
<hr>
<p><strong>Rescale.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="kt">void</span> <span class="nf">RescalePS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float4</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">InputViewportSize</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Here we simply render the input buffer into the target buffer, but rescaling the UVs to fill the buffer based on the region size with the help of <strong>InputViewportSize</strong>.</p>
<hr>
<p>We now have our first shader to use, so let's see how to actually render it from the code:</p>
<p><strong>TODO_RESCALE</strong></p>
<div class="highlight"><pre>    <span class="cp">#if WITH_EDITOR</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span>  <span class="o">!=</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Extent</span><span class="p">.</span><span class="n">X</span>
    <span class="o">||</span>  <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">!=</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Extent</span><span class="p">.</span><span class="n">Y</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareRescale"</span><span class="p">);</span>

        <span class="c1">// Build target buffer</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">Desc</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">HalfSceneColor</span><span class="p">.</span><span class="n">Texture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
        <span class="n">Desc</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">Desc</span><span class="p">.</span><span class="n">Extent</span>     <span class="o">=</span> <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">Desc</span><span class="p">.</span><span class="n">Format</span>     <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
        <span class="n">Desc</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Transparent</span><span class="p">);</span>
        <span class="n">FRDGTextureRef</span> <span class="n">RescaleTexture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Desc</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Setup shaders</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareRescalePS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

        <span class="c1">// Setup shader parameters</span>
        <span class="n">FLensFlareRescalePS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FLensFlareRescalePS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>       <span class="o">=</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">HalfSceneColor</span><span class="p">.</span><span class="n">Texture</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">RescaleTexture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputViewportSize</span>       <span class="o">=</span> <span class="n">SceneColorViewportSize</span><span class="p">;</span>

        <span class="c1">// Render shader into buffer</span>
        <span class="n">DrawShaderPass</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">PassName</span><span class="p">,</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">VertexShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">ClearBlendState</span><span class="p">,</span>
            <span class="n">SceneColorViewport</span><span class="p">.</span><span class="n">Rect</span>
        <span class="p">);</span>

        <span class="c1">// Assign result before end of scope</span>
        <span class="n">InputTexture</span> <span class="o">=</span> <span class="n">RescaleTexture</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cp">#endif</span>
</pre></div>

<p>As well as the shader declaration, this code is under a define to be skipped in shipped build. Next the rendering code is wrapped inside a <strong>if()</strong> block to avoid triggering this rendering pass all the time. The condition basically evaluate the region size (<strong>Rect</strong>) against the buffer size (<strong>Extent</strong>) so that the rescale happens only if they don't match.</p>
<p>On the actual rendering code, there are 3 main blocks:</p>
<ul>
<li><strong>Texture creation</strong>: I'm taking a shortcut here, because we aren't actually building a texture/buffer, just telling RDG to do it for us. When the RDG compile the graph later on, it will generate new or reuse buffers for us.<br>
<strong>GrahpBuilder</strong> is the instance of RDG that allows us to register commands and <strong>GraphBuilder.CreateTexture()</strong> is the function that allows us to build a texture. We feed it a description which basically tells which properties the buffer will have.<br>
It's possible to save some time by re-using the description of an existing buffer and then adjusting a few settings. That's what I'm doing here with the <strong>HalfSceneColor</strong>. This has the advantage of having a description with the right rendering flags set to it so that we don't have to fiddle with that (which can be quickly complicated).</li>
<li><strong>Shader parameters</strong>: next we create two shader instances, for both the vertex and pixel shader. We do so by filling <strong>TShaderMapRef</strong> which the Shader class we want.<br>
Then for the actual parameters we simply use the <strong>GraphBuilder</strong> once again to build an object on which we assign the parameters with the values we want.</li>
<li><strong>Draw</strong>: finally we call <strong>DrawShaderPass()</strong> with all the necessary variables to request a rendering to the GraphBuilder. You can check again how this function works in <a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#step_x_utility_functions">the utility function step</a>.</li>
</ul>
<p>I want to elaborate a bit on the <strong>FRenderTargetBinding</strong> and the parameter assignment: as we saw in the shader, we reference a parameter struct in which the buffer input is itself referenced. This is also where we define in which buffer we want to draw the result of the shader. This is why I'm using <strong>PassParameters-&gt;Pass.</strong> to access the struct parameters.<br>
<strong>InputTexture</strong> is obviously the texture we want to read, and <strong>RenderTargets[0]</strong> the buffer in which we want to write.<br>
<strong>FRenderTargetBinding</strong> is a special object to indicate which buffer we want to write into and how because <strong>ERenderTargetLoadAction</strong> can be used to specify if we want to overwrite the buffer or accumulate into (additive blending).<br>
In most cases I use <strong>ENoAction</strong> because we render RGB value only and the shader doesn't need accumulation. So both a Clear (reset to 0) or Load (read existing pixels before blend) are not needed.</p>
<p>Finally I assign the newly created buffer to the variable <strong>InputTexture</strong> so that next passes can use it.</p>
<hr>
<a id="step_10_downsample_and_threshold_pass"></a><h2>Step 10: Downsample and Threshold Pass</h2>
<p>Now that we have a buffer ready to be used (rescaled or not) it is time to process it like seen in the diagram. The goal is to focus only on bright areas that could reflect more light than expected in the lens. Since we are dealing with HDR values it's quite easy to rise the level of what should be taken into account or not (since bright lights often have high emissive values). </p>
<p>In the original Unreal Engine method, the threshold is binary which led to flickers/instabilities. I went instead with a fading threshold to smooth out values. Sadly this wasn't enough: <strong>moving the camera could still lead to flickers</strong> simply because the buffer is too small and we are dealing with HDR values (jumping from one pixel to another, like stairs with too big steps).</p>
<p>Here is what the result of the threshold looks like as-is and with additional filtering (without any bloom):</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/ue4_custom/filter_comparison.webm" type="video/webm"></video><br>
(<strong>No custom filtering</strong> vs <strong>Downsampling</strong> vs <strong>Downsampling+Blur</strong>)</p>
<p>This is why I looked into ways to <strong>stabilize the buffer</strong> and smooth things even further because otherwise the aliasing would have been very obvious and jarring to the eyes. Downsampling with a custom filter improve quite a lot the quality of the ghosts but it isn't enough, which is why a slight blur pass is also required. It is particularly visible on the arm of the character at the bottom right of the video above.</p>
<p>It is important to understand how critical this threshold pass is: all the following effect are built over it. So if this pass has artifacts, aliasing, or stability issues they will be visible and sometimes even exacerbated in the following passes.</p>
<hr>
<p>The first solution I tried was actually blurring the result of the threshold but I didn't find it conclusive enough. This is when I remembered a presentation on <strong>Call of Duty: Advanced Warfare</strong> by <strong>Activision</strong> which faced similar issues on their Bloom generation:</p>
<p class="img-centered"><video autoplay="" loop="" muted="" playsinline="" preload="true"><source src="resources/cod/bloom_codfilter.webm" type="video/webm"></video></p>
<p>In their case Bloom is generated by downscaling multiple times the original input buffer. At some point pixel information is hit or miss. So when moving the camera you obtain flickers because of aliasing issues. Their solution was to average with specific weights neighbor pixels to stabilize the final value even during movement:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/cod/cod_13taps_filter.png" rel="nofollow" target="_blank"><img alt="COD filter" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_cod_13taps_filter.jpg"></a></p>
<hr>
<p>So let's make our own downsample pass based on this method:</p>
<p><strong>TODO_SHADER_DOWNSAMPLE</strong></p>
<div class="highlight"><pre>    <span class="c1">// Downsample shader</span>
    <span class="k">class</span> <span class="nc">FDownsamplePS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FDownsamplePS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FDownsamplePS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">InputSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">ThresholdLevel</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">ThresholdRange</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FDownsamplePS</span><span class="p">,</span> <span class="s">"/CustomShaders/DownsampleThreshold.usf"</span><span class="p">,</span> <span class="s">"DownsampleThresholdPS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<p><strong>DownsampleThreshold.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="n">float2</span> <span class="n">InputSize</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">ThresholdLevel</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">ThresholdRange</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">DownsampleThresholdPS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float3</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">InPixelSize</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">InputSize</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">,</span><span class="mf">0.0f</span> <span class="p">);</span>

    <span class="c1">// 4 central samples</span>
    <span class="n">float2</span> <span class="n">CenterUV_1</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">CenterUV_2</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">CenterUV_3</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">CenterUV_4</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">);</span>

    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">CenterUV_1</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">CenterUV_2</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">CenterUV_3</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">CenterUV_4</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">(</span><span class="n">Color</span> <span class="o">/</span> <span class="mf">4.0f</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="c1">// 3 row samples</span>
    <span class="n">Color</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">,</span><span class="mf">0.0f</span> <span class="p">);</span>

    <span class="n">float2</span> <span class="n">RowUV_1</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">RowUV_2</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">RowUV_3</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">);</span>

    <span class="n">float2</span> <span class="n">RowUV_4</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">RowUV_5</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">RowUV_6</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>

    <span class="n">float2</span> <span class="n">RowUV_7</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">RowUV_8</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">RowUV_9</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">InPixelSize</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">2.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">);</span>

    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_1</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_2</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_3</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_4</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_5</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_6</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_7</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_8</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">RowUV_9</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Color</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="c1">// Threshold</span>
    <span class="kt">float</span> <span class="n">Luminance</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">ThresholdScale</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span> <span class="p">(</span><span class="n">Luminance</span> <span class="o">-</span> <span class="n">ThresholdLevel</span><span class="p">)</span> <span class="o">/</span> <span class="n">ThresholdRange</span> <span class="p">);</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*=</span> <span class="n">ThresholdScale</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>As you can see here, first is the 13 samples (with the corresponding weights) then is the threshold which works by specify a level and a range for the fade in/out. The threshold is applied based on the pixel luminance which is computed via a dot product.</p>
<p>Now we just need to add the C++ code to run that shader:</p>
<p><strong>TODO_THRESHOLD</strong></p>
<div class="highlight"><pre>    <span class="n">RDG_EVENT_SCOPE</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="s">"ThresholdPass"</span><span class="p">);</span>

    <span class="n">FRDGTextureRef</span> <span class="n">OutputTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">FIntRect</span> <span class="n">Viewport</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">;</span>
    <span class="n">FIntRect</span> <span class="n">Viewport2</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">);</span>
    <span class="n">FIntRect</span> <span class="n">Viewport4</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="p">);</span>
</pre></div>

<p>Since we are inside the <strong>RenderThreshold()</strong> function we can take the opportunity to add a dedicated event for profiling performances later. Then we setup the buffer that will be returned from the function and finally we set a few <strong>FIntRect</strong> as size reference for the intermediate buffer we are gonna build and render.</p>
<hr>
<div class="highlight"><pre>    <span class="p">{</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareDownsample"</span><span class="p">);</span>

        <span class="c1">// Build texture</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">Description</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Extent</span>  <span class="o">=</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Format</span>  <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Black</span><span class="p">);</span>
        <span class="n">FRDGTextureRef</span> <span class="n">Texture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Description</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Render shader</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FDownsamplePS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

        <span class="n">FDownsamplePS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FDownsamplePS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>       <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">Texture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSize</span>               <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span> <span class="n">Viewport2</span><span class="p">.</span><span class="n">Size</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">ThresholdLevel</span>          <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">ThresholdLevel</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">ThresholdRange</span>          <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">ThresholdRange</span><span class="p">;</span>

        <span class="n">DrawShaderPass</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">PassName</span><span class="p">,</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">VertexShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">ClearBlendState</span><span class="p">,</span>
            <span class="n">Viewport4</span>
        <span class="p">);</span>

        <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">Texture</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>Very similar setup to the rescale pass, which we are gonna see for the other rendering pass too. There is not much new to say here other than paying attention to a few little details:</p>
<ul>
<li><strong>InputSize</strong> is set to <strong>Viewport2</strong> because that's the resolution of the input buffer (the scene color at half the resolution of the viewport)</li>
<li><strong>DrawShaderPass()</strong> and <strong>Texture</strong> resolution is set at <strong>Viewport4</strong> since we are downsampling, so we divide the previous resolution by two.</li>
<li>Then <strong>Texture</strong> is assigned to <strong>OutputTexture</strong> before we exit the temporary scope.</li>
</ul>
<p>You can notice that the parameters value are retrieved from the <strong>PostProcessAsset</strong> that we referenced earlier in the code.</p>
<hr>
<p>Now that we have downsample pass, we can add the blur:</p>
<p><strong>TODO_THRESHOLD_BLUR</strong></p>
<div class="highlight"><pre>    <span class="p">{</span>
        <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">RenderBlur</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">OutputTexture</span><span class="p">,</span>
            <span class="n">View</span><span class="p">,</span>
            <span class="n">Viewport2</span><span class="p">,</span>
            <span class="mi">1</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">OutputTexture</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// End of RenderThreshold()</span>
</pre></div>

<p>The details on how this function works is in the next step.<br>
Notice here the argument <strong>1</strong> passed to the function, this means only one pass of blur is performed. Since additional passes are expensive, and given we already did a custom downsample pass, blurring further isn't needed.</p>
<hr>
<a id="step_11_blur_function"></a><h2>Step 11: Blur Function</h2>
<p>I spent a long time trying out different blur methods:</p>
<ul>
<li><strong>Box blur</strong>: too blocky, not good enough quality</li>
<li><strong>Circular blur</strong>: good for simple bokeh, wrong pattern for general blurring.</li>
<li><strong>Gaussian blur</strong>: the initial versions I tried required to compute mipmaps which implies quite a few additional passes. (I also had quality/filtering issues but maybe it was my fault.)</li>
</ul>
<p>I ended up choosing the <strong>Dual Kawase</strong> method. It is an improvement over the original Kawase method that emulates a gaussian blur while remaining very fast to compute. The name of the method comes from <strong>Masaki Kawase</strong> who presented it at GDC (Game Developers Conference) initially.</p>
<p>In a few words, this blur method works by doing multiple passes where each pixel samples its neighbors. The blur strength therefore comes from the number of passes performed:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/kawase/kawase_original.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_kawase_original.jpg"></a> </p>
<p>The dual version improve that process by taking advantage of the GPU native bilinear sampling: instead of keeping the buffer at the same size, each pass downsample the previous results. Then in the middle the opposite is done with upsampling passes. The down and then up process allow to take advantage of bilinear interpolation when reading pixel to process a lot more information at once.<br>
This means that we can reduce the number of total passes needed and improve the fillrate by processing lower resolutions:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/kawase/kawase_dual.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_kawase_dual.jpg"></a></p>
<hr>
<p>Because we are going to re-use this blur method a few times, I ended up moving the blur process into its own function <strong>RenderBlur()</strong>:</p>
<p><strong>TODO_BLUR</strong></p>
<div class="highlight"><pre><span class="n">FRDGTextureRef</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderBlur</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">Viewport</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">BlurSteps</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Shader setup</span>
    <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span>  <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
    <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FKawaseBlurDownPS</span><span class="o">&gt;</span>    <span class="n">PixelShaderDown</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
    <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FKawaseBlurUpPS</span><span class="o">&gt;</span>      <span class="n">PixelShaderUp</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

    <span class="c1">// Data setup</span>
    <span class="n">FRDGTextureRef</span> <span class="n">PreviousBuffer</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">FRDGTextureDesc</span><span class="o">&amp;</span> <span class="n">InputDescription</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">FString</span> <span class="n">PassDownName</span>  <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Down"</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">FString</span> <span class="n">PassUpName</span>    <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Up"</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">int32</span> <span class="n">ArraySize</span> <span class="o">=</span> <span class="n">BlurSteps</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Viewport resolutions</span>
    <span class="c1">// Could have been a bit more clever and avoid duplicate</span>
    <span class="c1">// sizes for upscale passes but heh... it works.</span>
    <span class="n">int32</span> <span class="n">Divider</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">TArray</span><span class="o">&lt;</span><span class="n">FIntRect</span><span class="o">&gt;</span> <span class="n">Viewports</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">int32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ArraySize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FIntRect</span> <span class="n">NewRect</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="n">Divider</span><span class="p">,</span>
            <span class="n">Viewport</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="n">Divider</span>
        <span class="p">);</span>

        <span class="n">Viewports</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span> <span class="n">NewRect</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">BlurSteps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Divider</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">Divider</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">[...]</span>
</pre></div>

<p>The blur function starts with various preparations. Since the process downsample then upsample the input buffer when need different buffer sizes. The loop here basically generate these sizes based on the number of passes and the resolution that was based in the arguments.</p>
<p><strong>BlurSteps</strong> is the input argument that defines how many down then up passes should be done. Calling the function with <strong>1</strong> therefore means one down and one up (so two passes in total).</p>
<hr>
<p>Next is the rendering loop:</p>
<div class="highlight"><pre>    <span class="c1">// Render</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">int32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ArraySize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Build texture</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">BlurDesc</span> <span class="o">=</span> <span class="n">InputDescription</span><span class="p">;</span>
        <span class="n">BlurDesc</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">BlurDesc</span><span class="p">.</span><span class="n">Extent</span> <span class="o">=</span> <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">BlurDesc</span><span class="p">.</span><span class="n">Format</span> <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
        <span class="n">BlurDesc</span><span class="p">.</span><span class="n">NumMips</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">BlurDesc</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Transparent</span><span class="p">);</span>

        <span class="n">FVector2D</span> <span class="n">ViewportResolution</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span>
            <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Width</span><span class="p">(),</span>
            <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Height</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span> <span class="o">=</span>
            <span class="n">FString</span><span class="p">(</span><span class="s">"KawaseBlur"</span><span class="p">)</span>
            <span class="o">+</span>  <span class="n">FString</span><span class="o">::</span><span class="n">Printf</span><span class="p">(</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"_%i_"</span><span class="p">),</span> <span class="n">i</span> <span class="p">)</span>
            <span class="o">+</span>  <span class="p">(</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">BlurSteps</span><span class="p">)</span> <span class="o">?</span> <span class="nl">PassDownName</span> <span class="p">:</span> <span class="n">PassUpName</span> <span class="p">)</span>
            <span class="o">+</span>  <span class="n">FString</span><span class="o">::</span><span class="n">Printf</span><span class="p">(</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"_%ix%i"</span><span class="p">),</span> <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Width</span><span class="p">(),</span> <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Height</span><span class="p">()</span> <span class="p">);</span>

        <span class="n">FRDGTextureRef</span> <span class="n">Buffer</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">BlurDesc</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Render shader</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BlurSteps</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FKawaseBlurDownPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassDownParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FKawaseBlurDownPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">PassDownParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>       <span class="o">=</span> <span class="n">PreviousBuffer</span><span class="p">;</span>
            <span class="n">PassDownParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
            <span class="n">PassDownParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
            <span class="n">PassDownParameters</span><span class="o">-&gt;</span><span class="n">BufferSize</span>              <span class="o">=</span> <span class="n">ViewportResolution</span><span class="p">;</span>

            <span class="n">DrawShaderPass</span><span class="p">(</span>
                <span class="n">GraphBuilder</span><span class="p">,</span>
                <span class="n">PassName</span><span class="p">,</span>
                <span class="n">PassDownParameters</span><span class="p">,</span>
                <span class="n">VertexShader</span><span class="p">,</span>
                <span class="n">PixelShaderDown</span><span class="p">,</span>
                <span class="n">ClearBlendState</span><span class="p">,</span>
                <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">FKawaseBlurUpPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassUpParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FKawaseBlurUpPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">PassUpParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>         <span class="o">=</span> <span class="n">PreviousBuffer</span><span class="p">;</span>
            <span class="n">PassUpParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
            <span class="n">PassUpParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>              <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
            <span class="n">PassUpParameters</span><span class="o">-&gt;</span><span class="n">BufferSize</span>                <span class="o">=</span> <span class="n">ViewportResolution</span><span class="p">;</span>

            <span class="n">DrawShaderPass</span><span class="p">(</span>
                <span class="n">GraphBuilder</span><span class="p">,</span>
                <span class="n">PassName</span><span class="p">,</span>
                <span class="n">PassUpParameters</span><span class="p">,</span>
                <span class="n">VertexShader</span><span class="p">,</span>
                <span class="n">PixelShaderUp</span><span class="p">,</span>
                <span class="n">ClearBlendState</span><span class="p">,</span>
                <span class="n">Viewports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">PreviousBuffer</span> <span class="o">=</span> <span class="n">Buffer</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PreviousBuffer</span><span class="p">;</span>
</pre></div>

<p>RDG doesn't allow to re-use shader parameters, this is why each pass use <strong>AllocParameters()</strong> to build new parameters for each rendering call.</p>
<hr>
<p>Now that we have the rendering code, let's setup the shader:</p>
<p><strong>TODO_SHADER_KAWASE</strong></p>
<div class="highlight"><pre>    <span class="c1">// Blur shader (use Dual Kawase method)</span>
    <span class="k">class</span> <span class="nc">FKawaseBlurDownPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FKawaseBlurDownPS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FKawaseBlurDownPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">FKawaseBlurUpPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FKawaseBlurUpPS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FKawaseBlurUpPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FKawaseBlurDownPS</span><span class="p">,</span> <span class="s">"/CustomShaders/DualKawaseBlur.usf"</span><span class="p">,</span> <span class="s">"KawaseBlurDownsamplePS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FKawaseBlurUpPS</span><span class="p">,</span> <span class="s">"/CustomShaders/DualKawaseBlur.usf"</span><span class="p">,</span> <span class="s">"KawaseBlurUpsamplePS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<hr>
<p><strong>DualKawaseBlur.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="n">float2</span> <span class="n">BufferSize</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">KawaseBlurDownsamplePS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float4</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">HalfPixel</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">BufferSize</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="n">float2</span> <span class="n">DirDiag1</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Top left</span>
    <span class="n">float2</span> <span class="n">DirDiag2</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Top right</span>
    <span class="n">float2</span> <span class="n">DirDiag3</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Bottom right</span>
    <span class="n">float2</span> <span class="n">DirDiag4</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Bottom left</span>

    <span class="n">float3</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">4.0f</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag1</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag2</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag3</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag4</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">Color</span> <span class="o">/</span> <span class="mf">8.0f</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">KawaseBlurUpsamplePS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float4</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">HalfPixel</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">BufferSize</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="n">float2</span> <span class="n">DirDiag1</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Top left</span>
    <span class="n">float2</span> <span class="n">DirDiag2</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Top right</span>
    <span class="n">float2</span> <span class="n">DirDiag3</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Bottom right</span>
    <span class="n">float2</span> <span class="n">DirDiag4</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span> <span class="c1">// Bottom left</span>
    <span class="n">float2</span> <span class="n">DirAxis1</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="mf">0.0f</span> <span class="p">);</span>        <span class="c1">// Left</span>
    <span class="n">float2</span> <span class="n">DirAxis2</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="mf">0.0f</span> <span class="p">);</span>        <span class="c1">// Right</span>
    <span class="n">float2</span> <span class="n">DirAxis3</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span>         <span class="c1">// Top</span>
    <span class="n">float2</span> <span class="n">DirAxis4</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="n">HalfPixel</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span>         <span class="c1">// Bottom</span>

    <span class="n">float3</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">);</span>

    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag1</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag2</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag3</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirDiag4</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirAxis1</span> <span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirAxis2</span> <span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirAxis3</span> <span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">;</span>
    <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">DirAxis4</span> <span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">Color</span> <span class="o">/</span> <span class="mf">12.0f</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The downsample function performs four samples here in four directions (axis aligned) at a distance of half a pixel (of the given buffer resolution). The upsample function does height samples because it includes diagonals directions and applies different weights.</p>
<blockquote>
<p>Something to be aware of is that since the Kawase blur works by reading neighbors pixels, it means that for two identical images but at different resolution, one of them will need more passes to reach the same level of blur visually.<br>
  This means that in various passes I used a specific size that fits well a 1080p resolution, but if your game render above (say 4K) you may need to adjust the intensity by increasing the number of passes to reach the same visual parity.</p>
</blockquote>
<hr>
<a id="step_12_ghost_pass"></a><h2>Step 12: Ghost Pass</h2>
<p>We can now do the first visual pass and build up the ghosts. The idea is actually pretty simple and divided into a few steps:</p>
<ul>
<li><strong>Chromatic shift</strong>: this applies a bit of chromatic aberration on the result of the threshold pass.</li>
<li><strong>Ghost loop</strong>: this draw multiple times the previous result at different scales, creating the ghost effect.</li>
<li><strong>Halo</strong>: this draw reads the threshold result (and not the chromatic one) to deform it and create a halo effect.</li>
</ul>
<p>All of this will be done inside the <strong>RenderFlare()</strong> function.</p>
<hr>
<a id="chroma_shift_subpass"></a><h3>Chroma Shift Subpass</h3>
<p><strong>TODO_SHADER_CHROMA</strong></p>
<div class="highlight"><pre>    <span class="c1">// Chromatic shift shader</span>
    <span class="k">class</span> <span class="nc">FLensFlareChromaPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareChromaPS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareChromaPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">ChromaShift</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareChromaPS</span><span class="p">,</span> <span class="s">"/CustomShaders/Chroma.usf"</span><span class="p">,</span> <span class="s">"ChromaPS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<hr>
<p><strong>Chroma.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="kt">float</span> <span class="n">ChromaShift</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">ChromaPS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float3</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">float2</span> <span class="n">CenterPoint</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span> <span class="p">);</span>
    <span class="n">float2</span> <span class="n">UVr</span> <span class="o">=</span> <span class="p">(</span><span class="n">UV</span> <span class="o">-</span> <span class="n">CenterPoint</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">+</span> <span class="n">ChromaShift</span><span class="p">)</span> <span class="o">+</span> <span class="n">CenterPoint</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">UVb</span> <span class="o">=</span> <span class="p">(</span><span class="n">UV</span> <span class="o">-</span> <span class="n">CenterPoint</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">-</span> <span class="n">ChromaShift</span><span class="p">)</span> <span class="o">+</span> <span class="n">CenterPoint</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UVr</span> <span class="p">).</span><span class="n">r</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span>  <span class="p">).</span><span class="n">g</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UVb</span> <span class="p">).</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<hr>
<p><strong>TODO_FLARE_CHROMA</strong></p>
<div class="highlight"><pre>    <span class="n">RDG_EVENT_SCOPE</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="s">"FlarePass"</span><span class="p">);</span>

    <span class="n">FRDGTextureRef</span> <span class="n">OutputTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">FIntRect</span> <span class="n">Viewport</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">;</span>
    <span class="n">FIntRect</span> <span class="n">Viewport2</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">);</span>
    <span class="n">FIntRect</span> <span class="n">Viewport4</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="p">);</span>
</pre></div>

<p>Like in the threshold function, we have to setup a few things before starting to render things. Then we can perform the chromatic shift pass:</p>
<div class="highlight"><pre>    <span class="n">FRDGTextureRef</span> <span class="n">ChromaTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareChromaGhost"</span><span class="p">);</span>

        <span class="c1">// Build buffer</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">Description</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Extent</span>  <span class="o">=</span> <span class="n">Viewport2</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Format</span>  <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Black</span><span class="p">);</span>
        <span class="n">ChromaTexture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Description</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Shader parameters</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareChromaPS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

        <span class="n">FLensFlareChromaPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FLensFlareChromaPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>       <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">ChromaTexture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearBorderSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">ChromaShift</span>             <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GhostChromaShift</span><span class="p">;</span>

        <span class="c1">// Render</span>
        <span class="n">DrawShaderPass</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">PassName</span><span class="p">,</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">VertexShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">ClearBlendState</span><span class="p">,</span>
            <span class="n">Viewport2</span>
        <span class="p">);</span>
    <span class="p">}</span>
</pre></div>

<p>Notice how the variable <strong>ChromaTexture</strong> sits outside the scope. Since we aren't chaining the renders this time, we need an additional buffer to combine things later.</p>
<hr>
<a id="ghost_subpass"></a><h3>Ghost Subpass</h3>
<p>Now that the chromatic shift is done, we can perform the loop to draw it in sequence and create the ghost effect. </p>
<p>The shader is rather simple since it's a basic loop. The only peculiar thing is that it uses a few custom masks in order to hide the ghosts at specific location on the screen.</p>
<hr>
<p><strong>TODO_SHADER_GHOSTS</strong></p>
<div class="highlight"><pre>    <span class="c1">// Ghost shader</span>
    <span class="k">class</span> <span class="nc">FLensFlareGhostsPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGhostsPS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareGhostsPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_ARRAY</span><span class="p">(</span><span class="n">FVector4</span><span class="p">,</span> <span class="n">GhostColors</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                <span class="n">SHADER_PARAMETER_ARRAY</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">GhostScales</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Intensity</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGhostsPS</span><span class="p">,</span> <span class="s">"/CustomShaders/Ghosts.usf"</span><span class="p">,</span> <span class="s">"GhostsPS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<p>Note here a new type of parameters with <strong>SHADER_PARAMETER_ARRAY</strong>, this macro allows to define an array parameter for the shader. This macro takes three arguments: the data type, the variable name, and the size of the array (specified between square brackets).<br>
In this case the number of ghosts to draw is fixed (height are defined in the Data Asset).</p>
<hr>
<p><strong>Ghosts.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="n">float4</span> <span class="n">GhostColors</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">GhostScales</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">Intensity</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">GhostsPS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float4</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">);</span>

    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Skip ghost if size is basically 0</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">abs</span><span class="p">(</span><span class="n">GhostColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span> <span class="o">*</span> <span class="n">GhostScales</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.0001f</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">float2</span> <span class="n">NewUV</span> <span class="o">=</span> <span class="p">(</span><span class="n">UV</span> <span class="o">-</span> <span class="mf">0.5f</span><span class="p">)</span> <span class="o">*</span> <span class="n">GhostScales</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="c1">// Local mask</span>
            <span class="kt">float</span> <span class="n">DistanceMask</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">-</span> <span class="n">distance</span><span class="p">(</span> <span class="n">float2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">NewUV</span> <span class="p">);</span>
            <span class="kt">float</span> <span class="n">Mask</span>  <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.9f</span><span class="p">,</span> <span class="n">DistanceMask</span> <span class="p">);</span>
            <span class="kt">float</span> <span class="n">Mask2</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span> <span class="mf">0.75f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="n">DistanceMask</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">0.95f</span> <span class="o">+</span> <span class="mf">0.05f</span><span class="p">;</span>

            <span class="n">Color</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">NewUV</span> <span class="o">+</span> <span class="mf">0.5f</span> <span class="p">).</span><span class="n">rgb</span>
                    <span class="o">*</span> <span class="n">GhostColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rgb</span>
                    <span class="o">*</span> <span class="n">GhostColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span>
                    <span class="o">*</span> <span class="n">Mask</span> <span class="o">*</span> <span class="n">Mask2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">float2</span> <span class="n">ScreenPos</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ScreenborderMask</span> <span class="o">=</span> <span class="n">DiscMask</span><span class="p">(</span><span class="n">ScreenPos</span> <span class="o">*</span> <span class="mf">0.9f</span><span class="p">);</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">Color</span> <span class="o">*</span> <span class="n">ScreenborderMask</span> <span class="o">*</span> <span class="n">Intensity</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Below is a comparison of what the masking operations are doing. The local mask is used to make the ghosts bright in their middle but faded on their outside border. This an artistic choice I made so that looking at light source directly would feel bright and looking away would be less intrusive. Then the screen border mask simply ensure that there is no seam visible that would make the effect ugly.</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/ghosts_comparisons_1.jpg"><br>
(No masking at all)</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/ghosts_comparisons_2.jpg"><br>
(Local masking, applied in the loop on each ghost)</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/ghosts_comparisons_3.jpg"><br>
(Masking at the borders of the screen)</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/ghosts_comparisons_4.jpg"><br>
(Combined with bloom)</p>
<hr>
<p><strong>TODO_FLARE_GHOSTS</strong></p>
<div class="highlight"><pre>    <span class="p">{</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareGhosts"</span><span class="p">);</span>

        <span class="c1">// Build buffer</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">Description</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Extent</span>  <span class="o">=</span> <span class="n">Viewport2</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Format</span>  <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Transparent</span><span class="p">);</span>
        <span class="n">FRDGTextureRef</span> <span class="n">Texture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Description</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Shader parameters</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareGhostsPS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

        <span class="n">FLensFlareGhostsPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FLensFlareGhostsPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>       <span class="o">=</span> <span class="n">ChromaTexture</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">Texture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearBorderSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Intensity</span>               <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GhostIntensity</span><span class="p">;</span>

        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost1</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost2</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost3</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost4</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost5</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost6</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost7</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostColors</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost8</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>

        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost1</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost2</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost3</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost4</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost5</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost6</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost7</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GhostScales</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Ghost8</span><span class="p">.</span><span class="n">Scale</span><span class="p">;</span>

        <span class="c1">// Render</span>
        <span class="n">DrawShaderPass</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">PassName</span><span class="p">,</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">VertexShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">ClearBlendState</span><span class="p">,</span>
            <span class="n">Viewport2</span>
        <span class="p">);</span>

        <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">Texture</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>Nothing special once again apart from the way the array parameters are assigned. It's a basic static array, so it would be possible to build a for loop to assign values. This is not the case here because the data asset doesn't use an array (<a href="https://www.froyok.fr/blog/2021-04-fixing-ue4-flares/page.html" rel="nofollow">to avoid this bug</a>).</p>
<hr>
<a id="halo_subpass"></a><h3>Halo Subpass</h3>
<p>The halo effect is based on John Chapman's article which I briefly mentioned when talking about Cyberpunk 2077 above:</p>
<p class="img-centered"><img alt="John Chapman Flares" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/chapman_halo_2.jpg"></p>
<p>Roughly the idea is to build a direction vector to distort the UV coordinates. This push bright light sitting at the center of the screen toward the edges. </p>
<p>I tweaked this idea further by distorting the UVs with a fish eye effects which pushes information even further toward the screen edges. The reason why is because I wanted to get a very thin halo most of the time and avoid too much overlapping with the ghosts we added previously.</p>
<hr>
<p>Some example of regular halo (left) vs fisheye halo (right):</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/fisheye_example_1_off.jpg" rel="nofollow" target="_blank"><img alt="fisheye" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_fisheye_example_1_off.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/fisheye_example_1_on.jpg" rel="nofollow" target="_blank"><img alt="fisheye" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_fisheye_example_1_on.jpg"></a><br>
<a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/fisheye_example_2_off.jpg" rel="nofollow" target="_blank"><img alt="fisheye" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_fisheye_example_2_off.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/fisheye_example_2_on.jpg" rel="nofollow" target="_blank"><img alt="fisheye" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_fisheye_example_2_on.jpg"></a><br>
<a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/fisheye_example_3_off.jpg" rel="nofollow" target="_blank"><img alt="fisheye" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_fisheye_example_3_off.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/fisheye_example_3_on.jpg" rel="nofollow" target="_blank"><img alt="fisheye" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_fisheye_example_3_on.jpg"></a></p>
<hr>
<p><strong>TODO_SHADER_HALO</strong></p>
<div class="highlight"><pre>    <span class="k">class</span> <span class="nc">FLensFlareHaloPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareHaloPS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareHaloPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Width</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Mask</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Compression</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Intensity</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">ChromaShift</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareHaloPS</span><span class="p">,</span> <span class="s">"/CustomShaders/Halo.usf"</span><span class="p">,</span> <span class="s">"HaloPS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<p>Only note I would give here is that as you can see there is a few float parameters. It could be tempting to merge theme together as FVectors for example but it's actually not necessary as RDG do this kind of parameter grouping/batching automatically.</p>
<hr>
<p><strong>Halo.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="n">float2</span> <span class="nf">FisheyeUV</span><span class="p">(</span> <span class="n">float2</span> <span class="n">UV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">Compression</span><span class="p">,</span> <span class="kt">float</span> <span class="n">Zoom</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">NegPosUV</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">UV</span> <span class="o">-</span> <span class="mf">1.0f</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">Scale</span> <span class="o">=</span> <span class="n">Compression</span> <span class="o">*</span> <span class="n">atan</span><span class="p">(</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">Compression</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="n">RadiusDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">NegPosUV</span><span class="p">)</span> <span class="o">*</span> <span class="n">Scale</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">RadiusDirection</span> <span class="o">=</span> <span class="n">Compression</span> <span class="o">*</span> <span class="n">tan</span><span class="p">(</span> <span class="n">RadiusDistance</span> <span class="o">/</span> <span class="n">Compression</span> <span class="p">)</span> <span class="o">*</span> <span class="n">Zoom</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">Phi</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">(</span> <span class="n">NegPosUV</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">NegPosUV</span><span class="p">.</span><span class="n">x</span> <span class="p">);</span>

    <span class="n">float2</span> <span class="n">NewUV</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>  <span class="n">RadiusDirection</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">Phi</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="n">RadiusDirection</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">Phi</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="p">);</span>
    <span class="n">NewUV</span> <span class="o">=</span> <span class="n">NewUV</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">NewUV</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">[...]</span>
</pre></div>

<p>This Fisheye function that distort UVs is based on <a href="https://www.shadertoy.com/view/tstBDl" rel="nofollow">this shadertoy</a> with slight adjustments to be able to easily scale the effect.</p>
<div class="highlight"><pre><span class="p">[...]</span>

<span class="kt">float</span> <span class="n">Width</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Mask</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Compression</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Intensity</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">ChromaShift</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">HaloPS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float3</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">float2</span> <span class="n">CenterPoint</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span> <span class="p">);</span>

    <span class="c1">// UVs</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">FishUV</span> <span class="o">=</span> <span class="n">FisheyeUV</span><span class="p">(</span> <span class="n">UV</span><span class="p">,</span> <span class="n">Compression</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">);</span>

    <span class="c1">// Distortion vector</span>
    <span class="n">float2</span> <span class="n">HaloVector</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span> <span class="n">CenterPoint</span> <span class="o">-</span> <span class="n">UV</span> <span class="p">)</span> <span class="o">*</span> <span class="n">Width</span><span class="p">;</span>

    <span class="c1">// Halo mask</span>
    <span class="kt">float</span> <span class="n">HaloMask</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span> <span class="n">UV</span><span class="p">,</span> <span class="n">CenterPoint</span> <span class="p">);</span>
    <span class="n">HaloMask</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">HaloMask</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">);</span>
    <span class="n">HaloMask</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span> <span class="n">Mask</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="n">HaloMask</span> <span class="p">);</span>

    <span class="c1">// Screen border mask</span>
    <span class="n">float2</span> <span class="n">ScreenPos</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ScreenborderMask</span> <span class="o">=</span> <span class="n">DiscMask</span><span class="p">(</span><span class="n">ScreenPos</span><span class="p">);</span>
    <span class="n">ScreenborderMask</span> <span class="o">*=</span> <span class="n">DiscMask</span><span class="p">(</span><span class="n">ScreenPos</span> <span class="o">*</span> <span class="mf">0.8f</span><span class="p">);</span>
    <span class="n">ScreenborderMask</span> <span class="o">=</span> <span class="n">ScreenborderMask</span> <span class="o">*</span> <span class="mf">0.95</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">;</span> <span class="c1">// Scale range</span>

    <span class="c1">// Chroma offset</span>
    <span class="n">float2</span> <span class="n">UVr</span> <span class="o">=</span> <span class="p">(</span><span class="n">FishUV</span> <span class="o">-</span> <span class="n">CenterPoint</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">+</span> <span class="n">ChromaShift</span><span class="p">)</span> <span class="o">+</span> <span class="n">CenterPoint</span> <span class="o">+</span> <span class="n">HaloVector</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">UVg</span> <span class="o">=</span> <span class="n">FishUV</span> <span class="o">+</span> <span class="n">HaloVector</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">UVb</span> <span class="o">=</span> <span class="p">(</span><span class="n">FishUV</span> <span class="o">-</span> <span class="n">CenterPoint</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">-</span> <span class="n">ChromaShift</span><span class="p">)</span> <span class="o">+</span> <span class="n">CenterPoint</span> <span class="o">+</span> <span class="n">HaloVector</span><span class="p">;</span>

    <span class="c1">// Sampling</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UVr</span> <span class="p">).</span><span class="n">r</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UVg</span> <span class="p">).</span><span class="n">g</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UVb</span> <span class="p">).</span><span class="n">b</span><span class="p">;</span>

    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*=</span> <span class="n">ScreenborderMask</span> <span class="o">*</span> <span class="n">HaloMask</span> <span class="o">*</span> <span class="n">Intensity</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>

<p>Like mentioned above, all the work is done by altering the UV coordinates. The fish eye UVs are computed first, then the HaloVector compute a direction from the center of the screen. It gets added to the new UV coordinates when sampling happens.</p>
<p>Contrary to the Ghosts, the chroma effect is done in the same shader via three separate samples. At the end the result is masked out with a few custom masks to hide some artifacts. Note the <strong>DiscMask()</strong> function which is a function provided by Unreal shader system which allows to generate a radial/vignette type of masking. To avoid the mask flushing out too much colors, its range is scaled to avoid value that goes to pure black.</p>
<hr>
<p><strong>TODO_FLARE_HALO</strong></p>
<div class="highlight"><pre>    <span class="p">{</span>
        <span class="c1">// Render shader</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareHalo"</span><span class="p">);</span>

        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareHaloPS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

        <span class="n">FLensFlareHaloPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FLensFlareHaloPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span>       <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">OutputTexture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ELoad</span><span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearBorderSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Intensity</span>               <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">HaloIntensity</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Width</span>                   <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">HaloWidth</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Mask</span>                    <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">HaloMask</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Compression</span>             <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">HaloCompression</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">ChromaShift</span>             <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">HaloChromaShift</span><span class="p">;</span>

        <span class="n">DrawShaderPass</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">PassName</span><span class="p">,</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">VertexShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">AdditiveBlendState</span><span class="p">,</span>
            <span class="n">Viewport2</span>
        <span class="p">);</span>
    <span class="p">}</span>
</pre></div>

<p>This rendering pass is slightly different from the previous one we saw: this time we don't build a new buffer, instead we write into the previous one in additive mode which already contains the Ghosts.<br>
It wouldn't make sense to to that into an intermediate buffer just to copy it back over the Ghosts afterward. So it's faster and cheaper to simply draw over the existing content. Since we are in additive more and lens-flares are lighting information, this works well.</p>
<p>Therefore, this is what the <strong>FRenderTargetBinding()</strong> use <strong>OutputTexture</strong> with the <strong>ERenderTargetLoadAction::ELoad</strong> and that <strong>DrawShaderPass()</strong> is called with <strong>AdditiveBlendState</strong>.</p>
<hr>
<p>We are not yet done: because of the way the UVs are distorted, some artifacts or aliasing can very noticeable:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/halo_artifacts_1.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_halo_artifacts_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/halo_artifacts_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_halo_artifacts_2.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/halo_artifacts_3.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_halo_artifacts_3.jpg"></a></p>
<p>I tried several solutions to solve this issue (like generating mipmaps on the input buffer to get better interpolation) but didn't find anything better than simply blurring the final result. Blurring the Ghosts combined with the Halo buffer has also the advantage of fitting everything together.</p>
<p>To do so, we can simply call again the blur function (once again with a single pass):</p>
<div class="highlight"><pre>    <span class="p">{</span>
        <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">RenderBlur</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">OutputTexture</span><span class="p">,</span>
            <span class="n">View</span><span class="p">,</span>
            <span class="n">Viewport2</span><span class="p">,</span>
            <span class="mi">1</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">OutputTexture</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// End of RenderFlare()</span>
</pre></div>

<hr>
<a id="step_13_glare_pass"></a><h2>Step 13: Glare Pass</h2>
<p>This pass is heavily inspired from Batman, because I found it to be very clever, fast, good enough and with plenty of artistic controls to produce interesting results.</p>
<blockquote>
<p>Another method to generate glares is to perform several directional blurs from the input buffer and to combine them to create these light streak, like demonstrated by <a href="http://genderi.org/frame-buffer-postprocessing-effects-in-double-s-t-e-a-l-wreckl.html" rel="nofollow">Masaki Kawase in this presentation</a>.<br>
<a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/kawase/glare_kawase_1.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_glare_kawase_1.jpg"></a> <a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/kawase/glare_kawase_2.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_glare_kawase_2.jpg"></a><br>
  The reason why I didn't go with this method is that it is harder to control colors, sizes and that it requires a large amount of passes. Plus by the nature of the process, little details can easily be lost in the process.</p>
</blockquote>
<p>I iterated a long time on it because it proved hard to get something both performant and good looking.<br>
I initially built a version on the same idea as Unreal bokeh blur: draw an instanced and stretched quad for each pixel to build the star shape. Only one quad is drawn per pixel, therefore in order to make a star shape at least 3 quads are required (which once crossed give 6 branches). This is achieved by grouping pixels in two by two blocks, each block having 3 dedicated quads.<br>
This proved the idea could work but performances still weren't good. There was some overhead in the way the quads were being emitted on the GPU which led to a high fixed cost even when nothing should be drawn. (Also it turned out a similar idea had been <a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/papers/realtime_rendering_glare_images_using_vertex_texture_fetch_on_gpu.pdf" rel="nofollow">tried in the past</a>).</p>
<hr>
<p>So I went with a slightly different approach by splitting the process: </p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/schematic_capture.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_schematic_capture.jpg"></a><br>
(The Pixel shader is combined with the Geometry shader in this schematic for readability)</p>
<p>Instead of rendering quads directly, we use points (one per group of four pixels).<br>
In the Vertex shader multiple pixels are sampled around the point location. The results are combined and the luminance is computed. Then a geometry shader follow up and emit three quads if the previous luminance is high enough.</p>
<p>Nothing is rasterized if no point is deemed "<strong>valid</strong>" (aka bright enough). The base cost of emitting the points is very low. All the work is now within the Geometry shader and it can be easily skipped. The final cost now end-up being the overdraw when having lots of quads overlapping each other.</p>
<p>Here is the sampling pattern of each point:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_sampling_pattern.jpg"><br>
(Squares are pixels, dots are sampling positions)</p>
<p>Basically, for a block of two by two pixels, read the information at the center and at each corner of the block. Because we are reading pixels with bilinear interpolation we can aggregate lots of information. The pixel values are mixed with a more important weight at the center.<br>
This pattern has the advantage of making transition and camera movement more stable. Otherwise the Glare effect would pulsate/flicker as seen in the Threshold pass.<br>
After some trial and error I came up with this custom pattern which remains cheap (only 5 reading) while being good enough visually. I haven't found a way to stabilize further the effect without loosing too much information and luminosity.</p>
<p>Because we need three shaders for implementing the Glare effect (Vertex, Geometry and Pixel), it means this pass will be built a bit differently from the previous ones.</p>
<hr>
<p><strong>TODO_SHADER_GLARE</strong></p>
<div class="highlight"><pre>    <span class="c1">// Glare shader pass</span>
    <span class="k">class</span> <span class="nc">FLensFlareGlareVS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGlareVS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareGlareVS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FIntPoint</span><span class="p">,</span> <span class="n">TileCount</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector4</span><span class="p">,</span> <span class="n">PixelSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">FLensFlareGlareGS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGlareGS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareGlareGS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector4</span><span class="p">,</span> <span class="n">PixelSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">BufferRatio</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">GlareIntensity</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">GlareDivider</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector4</span><span class="p">,</span> <span class="n">GlareTint</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_ARRAY</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">GlareScales</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">FLensFlareGlarePS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGlarePS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareGlarePS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">GlareSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">GlareTexture</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGlareVS</span><span class="p">,</span> <span class="s">"/CustomShaders/Glare.usf"</span><span class="p">,</span> <span class="s">"GlareVS"</span><span class="p">,</span> <span class="n">SF_Vertex</span><span class="p">);</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGlareGS</span><span class="p">,</span> <span class="s">"/CustomShaders/Glare.usf"</span><span class="p">,</span> <span class="s">"GlareGS"</span><span class="p">,</span> <span class="n">SF_Geometry</span><span class="p">);</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareGlarePS</span><span class="p">,</span> <span class="s">"/CustomShaders/Glare.usf"</span><span class="p">,</span> <span class="s">"GlarePS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<p>Most of the shader setup here is similar to the previous ones we saw. There is a new macro we didn't see until now which is <strong>SHADER_PARAMETER_TEXTURE</strong>: it allows us to declare a generic texture to plug into the shader. Like you would do in regular materials in the content browser.</p>
<p>The texture we are gonna connect is the line mask from the data asset (visible in the geometry shader part of the schematic above).</p>
<hr>
<p>Let's jump into the <strong>RenderGlare()</strong> function to add the rendering steps. I ill cover the shader themselves just after.</p>
<p><strong>TODO_GLARE</strong></p>
<div class="highlight"><pre><span class="n">FRDGTextureRef</span> <span class="n">UPostProcessSubsystem</span><span class="o">::</span><span class="n">RenderGlare</span><span class="p">(</span>
        <span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span>
        <span class="n">FRDGTextureRef</span> <span class="n">InputTexture</span><span class="p">,</span>
        <span class="n">FIntRect</span><span class="o">&amp;</span> <span class="n">InputRect</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">View</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">RDG_EVENT_SCOPE</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="s">"GlarePass"</span><span class="p">);</span>

    <span class="n">FRDGTextureRef</span> <span class="n">OutputTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">FIntRect</span> <span class="n">Viewport4</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="p">);</span>

<span class="p">[...]</span>
</pre></div>

<hr>
<p>Let's continue with the actual rendering:</p>
<div class="highlight"><pre><span class="p">[...]</span>

    <span class="c1">// Only render the Glare if its intensity is different from 0</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareIntensity</span> <span class="o">&gt;</span> <span class="n">SMALL_NUMBER</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareGlare"</span><span class="p">);</span>

        <span class="c1">// This compute the number of point that will be drawn</span>
        <span class="c1">// Since we want one point for 2 by 2 pixel block we just </span>
        <span class="c1">// need to divide the resolution by two to get this value.</span>
        <span class="n">FIntPoint</span> <span class="n">TileCount</span> <span class="o">=</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">TileCount</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">TileCount</span><span class="p">.</span><span class="n">X</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">TileCount</span><span class="p">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">TileCount</span><span class="p">.</span><span class="n">Y</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">int32</span> <span class="n">Amount</span> <span class="o">=</span> <span class="n">TileCount</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">TileCount</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>

        <span class="c1">// Compute the ratio between the width and height</span>
        <span class="c1">// to know how to adjust the scaling of the quads.</span>
        <span class="c1">// (This assume width is bigger than height.)</span>
        <span class="n">FVector2D</span> <span class="n">BufferRatio</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span>
            <span class="kt">float</span><span class="p">(</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="p">)</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="p">),</span>
            <span class="mf">1.0f</span>
        <span class="p">);</span>

        <span class="c1">// Build the buffer</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">Description</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Extent</span>  <span class="o">=</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Format</span>  <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Transparent</span><span class="p">);</span>
        <span class="n">FRDGTextureRef</span> <span class="n">GlareTexture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Description</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Setup a few other variables that will </span>
        <span class="c1">// be needed by the shaders.</span>
        <span class="n">FVector4</span> <span class="n">PixelSize</span> <span class="o">=</span> <span class="n">FVector4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">PixelSize</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">PixelSize</span><span class="p">.</span><span class="n">Y</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">PixelSize</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="n">PixelSize</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
        <span class="n">PixelSize</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">PixelSize</span><span class="p">.</span><span class="n">Y</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>

        <span class="n">FVector2D</span> <span class="n">BufferSize</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span> <span class="n">Description</span><span class="p">.</span><span class="n">Extent</span> <span class="p">);</span>
<span class="p">[...]</span>
</pre></div>

<p>The rendering pass is inside an if block to easily discard its computation if the intensity is deemed too low. No need to render something that won't be visible in the end. Then we follow up with the setup of a few variables.</p>
<p>Like the comment mentions, the amount of points that will be drawn is driven by the resolution of the buffer in which we are gonna draw the quads. However since we want to draw only 1 point per 2 by 2 pixel blocks we divide the resolution in two.</p>
<hr>
<p>Next is the shader parameters setup:</p>
<div class="highlight"><pre><span class="p">[...]</span>

        <span class="c1">// Setup shader</span>
        <span class="n">FCustomLensFlarePassParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FCustomLensFlarePassParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputTexture</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">GlareTexture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">EClear</span><span class="p">);</span>

        <span class="c1">// Vertex shader</span>
        <span class="n">FLensFlareGlareVS</span><span class="o">::</span><span class="n">FParameters</span> <span class="n">VertexParameters</span><span class="p">;</span>
        <span class="n">VertexParameters</span><span class="p">.</span><span class="n">Pass</span> <span class="o">=</span> <span class="o">*</span><span class="n">PassParameters</span><span class="p">;</span>
        <span class="n">VertexParameters</span><span class="p">.</span><span class="n">InputSampler</span> <span class="o">=</span> <span class="n">BilinearBorderSampler</span><span class="p">;</span>
        <span class="n">VertexParameters</span><span class="p">.</span><span class="n">TileCount</span> <span class="o">=</span> <span class="n">TileCount</span><span class="p">;</span>
        <span class="n">VertexParameters</span><span class="p">.</span><span class="n">PixelSize</span> <span class="o">=</span> <span class="n">PixelSize</span><span class="p">;</span>
        <span class="n">VertexParameters</span><span class="p">.</span><span class="n">BufferSize</span> <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>

        <span class="c1">// Geometry shader</span>
        <span class="n">FLensFlareGlareGS</span><span class="o">::</span><span class="n">FParameters</span> <span class="n">GeometryParameters</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">BufferSize</span> <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">BufferRatio</span> <span class="o">=</span> <span class="n">BufferRatio</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">PixelSize</span> <span class="o">=</span> <span class="n">PixelSize</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">GlareIntensity</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareIntensity</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">GlareTint</span> <span class="o">=</span> <span class="n">FVector4</span><span class="p">(</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareTint</span> <span class="p">);</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">GlareScales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareScale</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">GlareScales</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareScale</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">GlareScales</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareScale</span><span class="p">.</span><span class="n">Z</span><span class="p">;</span>
        <span class="n">GeometryParameters</span><span class="p">.</span><span class="n">GlareDivider</span> <span class="o">=</span> <span class="n">FMath</span><span class="o">::</span><span class="n">Max</span><span class="p">(</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareDivider</span><span class="p">,</span> <span class="mf">0.01f</span> <span class="p">);</span>

        <span class="c1">// Pixel shader</span>
        <span class="n">FLensFlareGlarePS</span><span class="o">::</span><span class="n">FParameters</span> <span class="n">PixelParameters</span><span class="p">;</span>
        <span class="n">PixelParameters</span><span class="p">.</span><span class="n">GlareSampler</span> <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
        <span class="n">PixelParameters</span><span class="p">.</span><span class="n">GlareTexture</span> <span class="o">=</span> <span class="n">GWhiteTexture</span><span class="o">-&gt;</span><span class="n">TextureRHI</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareLineMask</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">FTextureRHIRef</span> <span class="n">TextureRHI</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">GlareLineMask</span><span class="o">-&gt;</span><span class="n">Resource</span><span class="o">-&gt;</span><span class="n">TextureRHI</span><span class="p">;</span>
            <span class="n">PixelParameters</span><span class="p">.</span><span class="n">GlareTexture</span> <span class="o">=</span> <span class="n">TextureRHI</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareGlareVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareGlareGS</span><span class="o">&gt;</span> <span class="n">GeometryShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareGlarePS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

<span class="p">[...]</span>
</pre></div>

<p>Straightforward shader setup here for most of it. The only particularity here is that for the first time we plug a 2D texture (and not a RDG buffer) into the parameters. </p>
<p>Since the texture in the data asset can be invalid, <strong>GlareTexture</strong> is set with the default engine texture <strong>GWhiteTexture</strong>, then we assign the resource if it is valid. This allows swapping resources in-editor without crashing the render process because for a short time the assigned texture is null (which is not authorized by the engine).</p>
<hr>
<p>Now for the actual rendering pass:</p>
<div class="highlight"><pre><span class="p">[...]</span>

        <span class="c1">// Required for Lambda capture</span>
        <span class="n">FRHIBlendState</span><span class="o">*</span> <span class="n">BlendState</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">AdditiveBlendState</span><span class="p">;</span>

        <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AddPass</span><span class="p">(</span>
            <span class="n">RDG_EVENT_NAME</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">),</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">ERDGPassFlags</span><span class="o">::</span><span class="n">Raster</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">VertexShader</span><span class="p">,</span> <span class="n">VertexParameters</span><span class="p">,</span>
                <span class="n">GeometryShader</span><span class="p">,</span> <span class="n">GeometryParameters</span><span class="p">,</span>
                <span class="n">PixelShader</span><span class="p">,</span> <span class="n">PixelParameters</span><span class="p">,</span>
                <span class="n">BlendState</span><span class="p">,</span> <span class="n">Viewport4</span><span class="p">,</span> <span class="n">Amount</span>
            <span class="p">]</span> <span class="p">(</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">RHICmdList</span><span class="p">.</span><span class="n">SetViewport</span><span class="p">(</span>
                    <span class="n">Viewport4</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
                    <span class="n">Viewport4</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Viewport4</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="mf">1.0f</span>
                <span class="p">);</span>

                <span class="n">FGraphicsPipelineStateInitializer</span> <span class="n">GraphicsPSOInit</span><span class="p">;</span>
                <span class="n">RHICmdList</span><span class="p">.</span><span class="n">ApplyCachedRenderTargets</span><span class="p">(</span><span class="n">GraphicsPSOInit</span><span class="p">);</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">BlendState</span> <span class="o">=</span> <span class="n">BlendState</span><span class="p">;</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">RasterizerState</span> <span class="o">=</span> <span class="n">TStaticRasterizerState</span><span class="o">&lt;&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">DepthStencilState</span> <span class="o">=</span> <span class="n">TStaticDepthStencilState</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="n">CF_Always</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">BoundShaderState</span><span class="p">.</span><span class="n">VertexDeclarationRHI</span> <span class="o">=</span> <span class="n">GEmptyVertexDeclaration</span><span class="p">.</span><span class="n">VertexDeclarationRHI</span><span class="p">;</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">BoundShaderState</span><span class="p">.</span><span class="n">VertexShaderRHI</span> <span class="o">=</span> <span class="n">VertexShader</span><span class="p">.</span><span class="n">GetVertexShader</span><span class="p">();</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">BoundShaderState</span><span class="p">.</span><span class="n">GeometryShaderRHI</span> <span class="o">=</span> <span class="n">GeometryShader</span><span class="p">.</span><span class="n">GetGeometryShader</span><span class="p">();</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">BoundShaderState</span><span class="p">.</span><span class="n">PixelShaderRHI</span> <span class="o">=</span> <span class="n">PixelShader</span><span class="p">.</span><span class="n">GetPixelShader</span><span class="p">();</span>
                <span class="n">GraphicsPSOInit</span><span class="p">.</span><span class="n">PrimitiveType</span> <span class="o">=</span> <span class="n">PT_PointList</span><span class="p">;</span>
                <span class="n">SetGraphicsPipelineState</span><span class="p">(</span><span class="n">RHICmdList</span><span class="p">,</span> <span class="n">GraphicsPSOInit</span><span class="p">);</span>

                <span class="n">SetShaderParameters</span><span class="p">(</span><span class="n">RHICmdList</span><span class="p">,</span> <span class="n">VertexShader</span><span class="p">,</span> <span class="n">VertexShader</span><span class="p">.</span><span class="n">GetVertexShader</span><span class="p">(),</span> <span class="n">VertexParameters</span><span class="p">);</span>
                <span class="n">SetShaderParameters</span><span class="p">(</span><span class="n">RHICmdList</span><span class="p">,</span> <span class="n">GeometryShader</span><span class="p">,</span> <span class="n">GeometryShader</span><span class="p">.</span><span class="n">GetGeometryShader</span><span class="p">(),</span> <span class="n">GeometryParameters</span><span class="p">);</span>
                <span class="n">SetShaderParameters</span><span class="p">(</span><span class="n">RHICmdList</span><span class="p">,</span> <span class="n">PixelShader</span><span class="p">,</span> <span class="n">PixelShader</span><span class="p">.</span><span class="n">GetPixelShader</span><span class="p">(),</span> <span class="n">PixelParameters</span><span class="p">);</span>

                <span class="n">RHICmdList</span><span class="p">.</span><span class="n">SetStreamSource</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">RHICmdList</span><span class="p">.</span><span class="n">DrawPrimitive</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Amount</span> <span class="p">);</span>
            <span class="p">});</span>

        <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">GlareTexture</span><span class="p">;</span>

    <span class="p">}</span> <span class="c1">// End of if()</span>

    <span class="k">return</span> <span class="n">OutputTexture</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// End of RenderGlare()</span>
</pre></div>

<p>The important things to note here:</p>
<ul>
<li>Because <strong>AddPass()</strong> is setup via a Lambda function, we have to use an intermediate variable <strong>BlendState</strong> to make it "capturable" by the Lambda. Referencing directly the member variable would otherwise lead to a compilation error. (Don't ask me why, this is C++ shenanigans that I don't care about.)</li>
<li>Since this time we are drawing points and not triangles, we set the <strong>PrimitiveType</strong> to <strong>PT_PointList</strong>. In the <strong>DrawPrimitive()</strong> we also specify that only one vertex is drawn per instance (second argument).</li>
<li>We reference the Geometry shader the same way as the Vertex and Pixel ones, via the dedicated member variable <strong>GeometryShaderRHI</strong> of the <strong>FGraphicsPipelineStateInitializer</strong>. Of course we also call the parameters setup for this specific shader too as well.</li>
</ul>
<hr>
<p>Time to dive into the actual shader. In <strong>Glare.usf</strong> we end-up with three functions for each shader type. Refer to the comments in the code for the details. Let's start with the <strong>Vertex shader</strong>:</p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="n">uint2</span> <span class="n">TileCount</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">GlareIntensity</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">GlareScales</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">float4</span> <span class="n">GlareTint</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">BufferSize</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">PixelSize</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">BufferRatio</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">GlareDivider</span><span class="p">;</span>
<span class="n">SamplerState</span> <span class="n">GlareSampler</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">GlareTexture</span><span class="p">;</span>

<span class="c1">// This struct is used to pass information from the</span>
<span class="c1">// Vertex shader to the Geometry shader.</span>
<span class="k">struct</span> <span class="n">FVertexToGeometry</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="nl">Position</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="nl">Color</span>    <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="nl">Luminance</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
    <span class="n">uint</span> <span class="nl">ID</span>         <span class="p">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">GlareVS</span><span class="p">(</span>
    <span class="n">uint</span> <span class="nl">VId</span> <span class="p">:</span> <span class="n">SV_VertexID</span><span class="p">,</span>
    <span class="n">uint</span> <span class="nl">IId</span> <span class="p">:</span> <span class="n">SV_InstanceID</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">FVertexToGeometry</span> <span class="n">Output</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// TilePos is the position of the point based on its ID. </span>
    <span class="c1">// Since we know how many points will be drawn in total </span>
    <span class="c1">// (because its defined from the code), we can figure out </span>
    <span class="c1">// how many points will be draw per line and therefor their </span>
    <span class="c1">// coordinates. From this we can compute the UV coordinate </span>
    <span class="c1">// of the point.</span>
    <span class="n">float2</span> <span class="n">TilePos</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="n">IId</span> <span class="o">%</span> <span class="n">TileCount</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">IId</span> <span class="o">/</span> <span class="n">TileCount</span><span class="p">.</span><span class="n">x</span> <span class="p">);</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">TilePos</span> <span class="o">/</span> <span class="n">BufferSize</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">;</span>

    <span class="c1">// Coords and Weights are local positions and intensities for </span>
    <span class="c1">// the pixels we are gonna sample. Since we have one point </span>
    <span class="c1">// for four pixels (two by two) we want to sample multiple </span>
    <span class="c1">// times the buffer to avoid missing information which </span>
    <span class="c1">// would create holes or artifacts.</span>
    <span class="c1">// This pattern doesn't sample exactly the 4 pixels in a block</span>
    <span class="c1">// but instead sample in the middle and at the corners to take</span>
    <span class="c1">// advantage of bilinear sampling to average more values.</span>
    <span class="k">const</span> <span class="n">float2</span> <span class="n">Coords</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">1.0f</span> <span class="p">),</span>
        <span class="n">float2</span><span class="p">(</span>  <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">1.0f</span> <span class="p">),</span>

        <span class="n">float2</span><span class="p">(</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span> <span class="p">),</span>

        <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="p">),</span>
        <span class="n">float2</span><span class="p">(</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="p">)</span>
    <span class="p">};</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">Weights</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mf">0.175</span><span class="p">,</span> <span class="mf">0.175</span><span class="p">,</span>
            <span class="mf">0.3</span><span class="p">,</span>
        <span class="mf">0.175</span><span class="p">,</span> <span class="mf">0.175</span>
    <span class="p">};</span>

    <span class="c1">// Since the UV coordinate is the middle position of the top right</span>
    <span class="c1">// pixel in the 2x2 block, we offset it to get the middle of the block.</span>
    <span class="c1">// Then in the loop we use the local offsets to go sample neighbor pixels.</span>
    <span class="n">float2</span> <span class="n">CenterUV</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">PixelSize</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span> <span class="p">);</span>

    <span class="n">float3</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="mf">0.0f</span><span class="p">,</span><span class="mf">0.0f</span><span class="p">);</span>

    <span class="n">UNROLL</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="n">CurrentUV</span> <span class="o">=</span> <span class="n">CenterUV</span> <span class="o">+</span> <span class="n">Coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">PixelSize</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">1.5f</span><span class="p">;</span>
        <span class="n">Color</span> <span class="o">+=</span> <span class="n">Weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Texture2DSampleLevel</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">CurrentUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Output</span><span class="p">.</span><span class="n">Luminance</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span> <span class="n">Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">);</span>
    <span class="n">Output</span><span class="p">.</span><span class="n">ID</span>       <span class="o">=</span> <span class="n">IId</span><span class="p">;</span>
    <span class="n">Output</span><span class="p">.</span><span class="n">Color</span>    <span class="o">=</span> <span class="n">Color</span><span class="p">;</span>
    <span class="n">Output</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span> <span class="n">TilePos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">TilePos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>

<span class="p">[...]</span>
</pre></div>

<hr>
<p>Now we continue with the <strong>Geometry shader</strong>:</p>
<div class="highlight"><pre><span class="p">[...]</span>

<span class="c1">// Same as with the Vertex shader, this struct is used to</span>
<span class="c1">// pass information computed by the Geometry shader into</span>
<span class="c1">// the Fragment/Pixel shader.</span>
<span class="k">struct</span> <span class="n">FGeometryToPixel</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="nl">Position</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="nl">UV</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="nl">Color</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This function goal is to figure out the actual position</span>
<span class="c1">// (in range 0-1) of a given vertex based on the original</span>
<span class="c1">// point position. This function also take into account</span>
<span class="c1">// the angle and scale of the quad to compute the target</span>
<span class="c1">// position of the final vertex.</span>
<span class="n">float4</span> <span class="nf">ComputePosition</span><span class="p">(</span> <span class="n">float2</span> <span class="n">TilePos</span><span class="p">,</span> <span class="n">float2</span> <span class="n">UV</span><span class="p">,</span> <span class="n">float2</span> <span class="n">Scale</span><span class="p">,</span> <span class="kt">float</span> <span class="n">Angle</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Compute the position of the quad based on the ID</span>
    <span class="c1">// Some multiply/divide by two magic to get the proper coordinates</span>
    <span class="n">float2</span> <span class="n">BufferPosition</span> <span class="o">=</span> <span class="p">(</span><span class="n">TilePos</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mf">0.25f</span><span class="p">,</span> <span class="mf">0.25f</span><span class="p">))</span> <span class="o">/</span> <span class="n">BufferSize</span><span class="p">;</span>
    <span class="n">BufferPosition</span> <span class="o">=</span> <span class="mf">4.0f</span> <span class="o">*</span> <span class="n">BufferPosition</span> <span class="o">-</span> <span class="mf">1.0f</span><span class="p">;</span>

    <span class="c1">// Center the quad in the middle of the screen</span>
    <span class="n">float2</span> <span class="n">NewPosition</span> <span class="o">=</span> <span class="mf">2.0f</span> <span class="o">*</span> <span class="p">(</span><span class="n">UV</span> <span class="o">-</span> <span class="mf">0.5f</span><span class="p">);</span>

    <span class="c1">// Scale the quad</span>
    <span class="n">NewPosition</span> <span class="o">*=</span> <span class="n">Scale</span><span class="p">;</span>

    <span class="c1">// Rotate th equad</span>
    <span class="kt">float</span> <span class="n">Sinus</span>         <span class="o">=</span> <span class="n">sin</span><span class="p">(</span> <span class="n">Angle</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="n">Cosinus</span>       <span class="o">=</span> <span class="n">cos</span><span class="p">(</span> <span class="n">Angle</span> <span class="p">);</span>
    <span class="n">float2</span> <span class="n">RotatedPosition</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>
        <span class="p">(</span><span class="n">NewPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">Cosinus</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">NewPosition</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">Sinus</span><span class="p">),</span>
        <span class="p">(</span><span class="n">NewPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">Sinus</span><span class="p">)</span>   <span class="o">+</span> <span class="p">(</span><span class="n">NewPosition</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">Cosinus</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">// Scale quad to compensate the buffer ratio</span>
    <span class="n">RotatedPosition</span> <span class="o">*=</span> <span class="n">BufferRatio</span><span class="p">;</span>

    <span class="c1">// Position quad where pixel is in the buffer</span>
    <span class="n">RotatedPosition</span> <span class="o">+=</span> <span class="n">BufferPosition</span> <span class="o">*</span> <span class="n">float2</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">);</span>

    <span class="c1">// Build final vertex position</span>
    <span class="n">float4</span> <span class="n">OutPosition</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span> <span class="n">RotatedPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">RotatedPosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">OutPosition</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is the main function and maxvertexcount is a required keyword </span>
<span class="c1">// to indicate how many vertices the Geometry shader will produce.</span>
<span class="c1">// (12 vertices = 3 quads, 4 vertices per quad)</span>
<span class="p">[</span><span class="n">maxvertexcount</span><span class="p">(</span><span class="mi">12</span><span class="p">)]</span>
<span class="kt">void</span> <span class="n">GlareGS</span><span class="p">(</span>
    <span class="n">point</span> <span class="n">FVertexToGeometry</span> <span class="n">Inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">inout</span> <span class="n">TriangleStream</span><span class="o">&lt;</span><span class="n">FGeometryToPixel</span><span class="o">&gt;</span> <span class="n">OutStream</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// It's (apparently) not possible to access to</span>
    <span class="c1">// the FVertexToGeometry struct members directly,</span>
    <span class="c1">// so it needs to be put into an intermediate</span>
    <span class="c1">// variable like this.</span>
    <span class="n">FVertexToGeometry</span> <span class="n">Input</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">Input</span><span class="p">.</span><span class="n">Luminance</span> <span class="o">&gt;</span> <span class="mf">0.1f</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="n">PointUV</span> <span class="o">=</span> <span class="n">Input</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">BufferSize</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">MaxSize</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">BufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span>

        <span class="c1">// Final quad color</span>
        <span class="n">float3</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">Input</span><span class="p">.</span><span class="n">Color</span> <span class="o">*</span> <span class="n">GlareTint</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">GlareTint</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">GlareIntensity</span><span class="p">;</span>

        <span class="c1">// Compute the scale of the glare quad.</span>
        <span class="c1">// The divider is used to specify the referential point of</span>
        <span class="c1">// which light is bright or not and normalize the result.</span>
        <span class="kt">float</span> <span class="n">LuminanceScale</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span> <span class="n">Input</span><span class="p">.</span><span class="n">Luminance</span> <span class="o">/</span> <span class="n">GlareDivider</span> <span class="p">);</span>

        <span class="c1">// Screen space mask to make the glare shrink at screen borders</span>
        <span class="kt">float</span> <span class="n">Mask</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span> <span class="n">PointUV</span> <span class="o">-</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">)</span> <span class="p">);</span>
        <span class="n">Mask</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">-</span> <span class="n">saturate</span><span class="p">(</span> <span class="n">Mask</span> <span class="o">*</span> <span class="mf">2.0f</span> <span class="p">);</span>
        <span class="n">Mask</span> <span class="o">=</span> <span class="n">Mask</span> <span class="o">*</span> <span class="mf">0.6f</span> <span class="o">+</span> <span class="mf">0.4f</span><span class="p">;</span>

        <span class="n">float2</span> <span class="n">Scale</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>
            <span class="n">LuminanceScale</span> <span class="o">*</span> <span class="n">Mask</span><span class="p">,</span>
            <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">min</span><span class="p">(</span> <span class="n">BufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">.</span><span class="n">y</span> <span class="p">))</span> <span class="o">*</span> <span class="mf">4.0f</span>
        <span class="p">);</span>

        <span class="c1">// Setup rotation angle</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">Angle30</span> <span class="o">=</span> <span class="mf">0.523599f</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">Angle60</span> <span class="o">=</span> <span class="mf">1.047197f</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">Angle90</span> <span class="o">=</span> <span class="mf">1.570796f</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">Angle150</span> <span class="o">=</span> <span class="mf">2.617994f</span><span class="p">;</span>

        <span class="c1">// Additional rotation based on screen position to add </span>
        <span class="c1">// more variety and make the glare rotate with the camera.</span>
        <span class="kt">float</span> <span class="n">AngleOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PointUV</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mf">2.0f</span> <span class="o">-</span> <span class="mf">1.0f</span><span class="p">)</span> <span class="o">*</span> <span class="n">Angle30</span><span class="p">;</span>

        <span class="kt">float</span> <span class="n">AngleBase</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">AngleOffset</span> <span class="o">+</span> <span class="n">Angle90</span><span class="p">,</span>
            <span class="n">AngleOffset</span> <span class="o">+</span> <span class="n">Angle30</span><span class="p">,</span> <span class="c1">// 90 - 60</span>
            <span class="n">AngleOffset</span> <span class="o">+</span> <span class="n">Angle150</span> <span class="c1">// 90 + 60</span>
        <span class="p">};</span>

        <span class="c1">// Quad UV coordinates of each vertex</span>
        <span class="c1">// Used as well to know which vertex of the quad is</span>
        <span class="c1">// being computed (by its position).</span>
        <span class="c1">// The order is important to ensure the triangles</span>
        <span class="c1">// will be front facing and therefore visible.</span>
        <span class="k">const</span> <span class="n">float2</span> <span class="n">QuadCoords</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">float2</span><span class="p">(</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span> <span class="p">),</span>
            <span class="n">float2</span><span class="p">(</span>  <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span> <span class="p">),</span>
            <span class="n">float2</span><span class="p">(</span>  <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">1.0f</span> <span class="p">),</span>
            <span class="n">float2</span><span class="p">(</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">1.0f</span> <span class="p">)</span>
        <span class="p">};</span>

        <span class="c1">// Generate 3 quads</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Emit a quad by producing 4 vertices</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">GlareScales</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0001f</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">float2</span> <span class="n">QuadScale</span> <span class="o">=</span> <span class="n">Scale</span> <span class="o">*</span> <span class="n">GlareScales</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="kt">float</span> <span class="n">QuadAngle</span> <span class="o">=</span> <span class="n">AngleBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="n">FGeometryToPixel</span> <span class="n">Vertex0</span><span class="p">;</span>
                <span class="n">FGeometryToPixel</span> <span class="n">Vertex1</span><span class="p">;</span>
                <span class="n">FGeometryToPixel</span> <span class="n">Vertex2</span><span class="p">;</span>
                <span class="n">FGeometryToPixel</span> <span class="n">Vertex3</span><span class="p">;</span>

                <span class="n">Vertex0</span><span class="p">.</span><span class="n">UV</span> <span class="o">=</span> <span class="n">QuadCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">Vertex1</span><span class="p">.</span><span class="n">UV</span> <span class="o">=</span> <span class="n">QuadCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">Vertex2</span><span class="p">.</span><span class="n">UV</span> <span class="o">=</span> <span class="n">QuadCoords</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
                <span class="n">Vertex3</span><span class="p">.</span><span class="n">UV</span> <span class="o">=</span> <span class="n">QuadCoords</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

                <span class="n">Vertex0</span><span class="p">.</span><span class="n">Color</span> <span class="o">=</span> <span class="n">Color</span><span class="p">;</span>
                <span class="n">Vertex1</span><span class="p">.</span><span class="n">Color</span> <span class="o">=</span> <span class="n">Color</span><span class="p">;</span>
                <span class="n">Vertex2</span><span class="p">.</span><span class="n">Color</span> <span class="o">=</span> <span class="n">Color</span><span class="p">;</span>
                <span class="n">Vertex3</span><span class="p">.</span><span class="n">Color</span> <span class="o">=</span> <span class="n">Color</span><span class="p">;</span>

                <span class="n">Vertex0</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">ComputePosition</span><span class="p">(</span> <span class="n">Input</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">Vertex0</span><span class="p">.</span><span class="n">UV</span><span class="p">,</span> <span class="n">QuadScale</span><span class="p">,</span> <span class="n">QuadAngle</span> <span class="p">);</span>
                <span class="n">Vertex1</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">ComputePosition</span><span class="p">(</span> <span class="n">Input</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">Vertex1</span><span class="p">.</span><span class="n">UV</span><span class="p">,</span> <span class="n">QuadScale</span><span class="p">,</span> <span class="n">QuadAngle</span> <span class="p">);</span>
                <span class="n">Vertex2</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">ComputePosition</span><span class="p">(</span> <span class="n">Input</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">Vertex2</span><span class="p">.</span><span class="n">UV</span><span class="p">,</span> <span class="n">QuadScale</span><span class="p">,</span> <span class="n">QuadAngle</span> <span class="p">);</span>
                <span class="n">Vertex3</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">ComputePosition</span><span class="p">(</span> <span class="n">Input</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">Vertex3</span><span class="p">.</span><span class="n">UV</span><span class="p">,</span> <span class="n">QuadScale</span><span class="p">,</span> <span class="n">QuadAngle</span> <span class="p">);</span>

                <span class="c1">// Produce a strip of Polygon. A triangle is</span>
                <span class="c1">// just 3 vertex produced in a row which end-up</span>
                <span class="c1">// connected, the last vertex re-use two previous</span>
                <span class="c1">// ones to build the second triangle.</span>
                <span class="c1">// This is why Vertex3 is not the last one, to ensure</span>
                <span class="c1">// the triangle is built with the right points.</span>
                <span class="n">OutStream</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">Vertex0</span><span class="p">);</span>
                <span class="n">OutStream</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">Vertex1</span><span class="p">);</span>
                <span class="n">OutStream</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">Vertex3</span><span class="p">);</span>
                <span class="n">OutStream</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">Vertex2</span><span class="p">);</span>

                <span class="c1">// Finish the strip and end the primitive generation</span>
                <span class="n">OutStream</span><span class="p">.</span><span class="n">RestartStrip</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[...]</span>
</pre></div>

<hr>
<p>Finally here is the <strong>Pixel shader</strong> where we combine the glare texture with the color sampled in the original buffer:</p>
<div class="highlight"><pre><span class="p">[...]</span>

<span class="kt">void</span> <span class="n">GlarePS</span><span class="p">(</span>
    <span class="n">FGeometryToPixel</span> <span class="n">Input</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float3</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">Mask</span> <span class="o">=</span> <span class="n">Texture2DSampleLevel</span><span class="p">(</span><span class="n">GlareTexture</span><span class="p">,</span> <span class="n">GlareSampler</span><span class="p">,</span> <span class="n">Input</span><span class="p">.</span><span class="n">UV</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">Mask</span> <span class="o">*</span> <span class="n">Input</span><span class="p">.</span><span class="n">Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<hr>
<a id="step_14_final_mixing_pass"></a><h2>Step 14: Final Mixing Pass</h2>
<p>All our render passes are done, now it is time to combine them together with the Bloom. Let's build the shader first:</p>
<p><strong>TODO_SHADER_MIX</strong></p>
<div class="highlight"><pre>    <span class="c1">// Final bloom mix shader</span>
    <span class="k">class</span> <span class="nc">FLensFlareBloomMixPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span>
    <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DECLARE_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareBloomMixPS</span><span class="p">);</span>
            <span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FLensFlareBloomMixPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>

            <span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FParameters</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">SHADER_PARAMETER_STRUCT_INCLUDE</span><span class="p">(</span><span class="n">FCustomLensFlarePassParameters</span><span class="p">,</span> <span class="n">Pass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_RDG_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">BloomTexture</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_RDG_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">GlareTexture</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">GradientTexture</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">GradientSampler</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector4</span><span class="p">,</span> <span class="n">Tint</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">InputViewportSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FVector2D</span><span class="p">,</span> <span class="n">PixelSize</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FIntVector</span><span class="p">,</span> <span class="n">MixPass</span><span class="p">)</span>
                <span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Intensity</span><span class="p">)</span>
            <span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>

            <span class="k">static</span> <span class="kt">bool</span> <span class="n">ShouldCompilePermutation</span><span class="p">(</span><span class="k">const</span> <span class="n">FGlobalShaderPermutationParameters</span><span class="o">&amp;</span> <span class="n">Parameters</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">IsFeatureLevelSupported</span><span class="p">(</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Platform</span><span class="p">,</span> <span class="n">ERHIFeatureLevel</span><span class="o">::</span><span class="n">SM5</span><span class="p">);</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">IMPLEMENT_GLOBAL_SHADER</span><span class="p">(</span><span class="n">FLensFlareBloomMixPS</span><span class="p">,</span> <span class="s">"/CustomShaders/Mix.usf"</span><span class="p">,</span> <span class="s">"MixPS"</span><span class="p">,</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</pre></div>

<hr>
<p><strong>Mix.usf</strong></p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"Shared.ush"</span>

<span class="n">Texture2D</span> <span class="n">BloomTexture</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">GlareTexture</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">GradientTexture</span><span class="p">;</span>
<span class="n">SamplerState</span> <span class="n">GradientSampler</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">Intensity</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">Tint</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">BufferSize</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">PixelSize</span><span class="p">;</span>
<span class="n">int3</span> <span class="n">MixPass</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">MixPS</span><span class="p">(</span>
    <span class="n">in</span> <span class="n">noperspective</span> <span class="n">float4</span> <span class="nl">UVAndScreenPos</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
    <span class="n">out</span> <span class="n">float4</span> <span class="nl">OutColor</span> <span class="p">:</span> <span class="n">SV_Target0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">);</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//---------------------------------------</span>
    <span class="c1">// Add Bloom</span>
    <span class="c1">//---------------------------------------</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">MixPass</span><span class="p">.</span><span class="n">x</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">BloomTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="o">*</span> <span class="n">InputViewportSize</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//---------------------------------------</span>
    <span class="c1">// Add Flares, Glares mixed with Tint/Gradient</span>
    <span class="c1">//---------------------------------------</span>
    <span class="n">float3</span> <span class="n">Flares</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">);</span>

    <span class="c1">// Flares</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">MixPass</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Flares</span> <span class="o">+=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Glares</span>
    <span class="c1">// Do 4 samples in a square pattern to smooth the</span>
    <span class="c1">// glare pass result and hide a few artifacts.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">MixPass</span><span class="p">.</span><span class="n">z</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">float2</span> <span class="n">Coords</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span>
            <span class="n">float2</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span>
            <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">),</span>
            <span class="n">float2</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="n">float3</span> <span class="n">GlareColor</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">);</span>

        <span class="n">UNROLL</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">float2</span> <span class="n">OffsetUV</span> <span class="o">=</span> <span class="n">UV</span> <span class="o">+</span> <span class="n">PixelSize</span> <span class="o">*</span> <span class="n">Coords</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">GlareColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="mf">0.25f</span> <span class="o">*</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">GlareTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">OffsetUV</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Flares</span> <span class="o">+=</span> <span class="n">GlareColor</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">float2</span> <span class="n">Center</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span> <span class="p">);</span>
    <span class="n">float2</span> <span class="n">GradientUV</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span>
        <span class="n">saturate</span><span class="p">(</span> <span class="n">distance</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span> <span class="n">Center</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0f</span> <span class="p">),</span>
        <span class="mf">0.0f</span>
    <span class="p">);</span>
    <span class="n">float3</span> <span class="n">Gradient</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span> <span class="n">GradientTexture</span><span class="p">,</span> <span class="n">GradientSampler</span><span class="p">,</span> <span class="n">GradientUV</span> <span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="c1">// Final mix</span>
    <span class="n">OutColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">Flares</span> <span class="o">*</span> <span class="n">Gradient</span> <span class="o">*</span> <span class="n">Tint</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">Intensity</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Here we simply add together the bloom, ghosts and glare. The final look is tinted with a 1D gradient texture in screen space at the end to add some colored details overall.</p>
<p>Because some passes may be invalid, they are put behind an if() condition, where MixPass act as boolean that is set on the code see (see below).</p>
<p>You can notice that the glare is read with 4 samples, this is to hide some aliasing and smooth out its look. Taking advantage once again of the bilinear interpolation.</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/glare_filter_off.webp"> <img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/glare_filter_on.webp"><br>
(1 sample vs 4 samples at corners)</p>
<hr>
<p>Now let's go back inside <strong>RenderLensFlare()</strong> to implement the final mixing process:</p>
<p><strong>TODO_MIX</strong></p>
<div class="highlight"><pre><span class="p">[...]</span>

    <span class="p">{</span>
        <span class="k">const</span> <span class="n">FString</span> <span class="n">PassName</span><span class="p">(</span><span class="s">"LensFlareMix"</span><span class="p">);</span>

        <span class="n">FIntRect</span> <span class="n">MixViewport</span> <span class="o">=</span> <span class="n">FIntRect</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">View</span><span class="p">.</span><span class="n">ViewRect</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">);</span>

        <span class="n">FVector2D</span> <span class="n">BufferSize</span> <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span> <span class="n">MixViewport</span><span class="p">.</span><span class="n">Width</span><span class="p">(),</span> <span class="n">MixViewport</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="p">);</span>

        <span class="c1">// Create buffer</span>
        <span class="n">FRDGTextureDesc</span> <span class="n">Description</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">Bloom</span><span class="p">.</span><span class="n">Texture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Extent</span> <span class="o">=</span> <span class="n">MixViewport</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">Format</span> <span class="o">=</span> <span class="n">PF_FloatRGBA</span><span class="p">;</span>
        <span class="n">Description</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Transparent</span><span class="p">);</span>
        <span class="n">FRDGTextureRef</span> <span class="n">MixTexture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Description</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>

        <span class="c1">// Shader parameters</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCustomScreenPassVS</span><span class="o">&gt;</span> <span class="n">VertexShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>
        <span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FLensFlareBloomMixPS</span><span class="o">&gt;</span> <span class="n">PixelShader</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">ShaderMap</span><span class="p">);</span>

        <span class="n">FLensFlareBloomMixPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">PassParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FLensFlareBloomMixPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">MixTexture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ENoAction</span><span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span>            <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GradientTexture</span>         <span class="o">=</span> <span class="n">GWhiteTexture</span><span class="o">-&gt;</span><span class="n">TextureRHI</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GradientSampler</span>         <span class="o">=</span> <span class="n">BilinearClampSampler</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">BufferSize</span>              <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">PixelSize</span>               <span class="o">=</span> <span class="n">FVector2D</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">)</span> <span class="o">/</span> <span class="n">BufferSize</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">InputViewportSize</span>       <span class="o">=</span> <span class="n">BloomInputViewportSize</span><span class="p">;</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Tint</span>                    <span class="o">=</span> <span class="n">FVector4</span><span class="p">(</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Tint</span> <span class="p">);</span>
        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Intensity</span>               <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Intensity</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Gradient</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">FTextureRHIRef</span> <span class="n">TextureRHI</span> <span class="o">=</span> <span class="n">PostProcessAsset</span><span class="o">-&gt;</span><span class="n">Gradient</span><span class="o">-&gt;</span><span class="n">Resource</span><span class="o">-&gt;</span><span class="n">TextureRHI</span><span class="p">;</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GradientTexture</span> <span class="o">=</span> <span class="n">TextureRHI</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>

<p>At this point you should get a sense of déjà vu here given how common that setup is. Nothing special to mention.</p>
<hr>
<p>Continuing the function:</p>
<div class="highlight"><pre>        <span class="c1">// Plug in buffers</span>
        <span class="k">const</span> <span class="n">int32</span> <span class="n">MixBloomPass</span> <span class="o">=</span> <span class="n">CVarLensFlareRenderBloom</span><span class="p">.</span><span class="n">GetValueOnRenderThread</span><span class="p">();</span>

        <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">MixPass</span> <span class="o">=</span> <span class="n">FIntVector</span><span class="p">(</span>
            <span class="p">(</span><span class="n">Inputs</span><span class="p">.</span><span class="n">bCompositeWithBloom</span> <span class="o">&amp;&amp;</span> <span class="n">MixBloomPass</span><span class="p">),</span>
            <span class="p">(</span><span class="n">FlareTexture</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">),</span>
            <span class="p">(</span><span class="n">GlareTexture</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">bCompositeWithBloom</span> <span class="o">&amp;&amp;</span> <span class="n">MixBloomPass</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">BloomTexture</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">.</span><span class="n">Bloom</span><span class="p">.</span><span class="n">Texture</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">BloomTexture</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">FlareTexture</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span> <span class="o">=</span> <span class="n">FlareTexture</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">Pass</span><span class="p">.</span><span class="n">InputTexture</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">GlareTexture</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GlareTexture</span> <span class="o">=</span> <span class="n">GlareTexture</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">PassParameters</span><span class="o">-&gt;</span><span class="n">GlareTexture</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>

<p>This part focus on making sure the buffers plugged into the shader parameters are valid. Null buffers are not authorized, which is why I choose to setup a IntVector as a group of booleans to know if a buffer is valid or not when sampling it in the shader.</p>
<p>This part could be optimized out by removing all of this if/else chain, but that would mean losing the ability to toggle some effects with the cvars. So adjust the code appropriately if that's what you want.</p>
<hr>
<p>Last bits:</p>
<div class="highlight"><pre>        <span class="c1">// Render</span>
        <span class="n">DrawShaderPass</span><span class="p">(</span>
            <span class="n">GraphBuilder</span><span class="p">,</span>
            <span class="n">PassName</span><span class="p">,</span>
            <span class="n">PassParameters</span><span class="p">,</span>
            <span class="n">VertexShader</span><span class="p">,</span>
            <span class="n">PixelShader</span><span class="p">,</span>
            <span class="n">ClearBlendState</span><span class="p">,</span>
            <span class="n">MixViewport</span>
        <span class="p">);</span>

        <span class="n">OutputTexture</span> <span class="o">=</span> <span class="n">MixTexture</span><span class="p">;</span>
        <span class="n">OutputRect</span> <span class="o">=</span> <span class="n">MixViewport</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="c1">////////////////////////////////////////////////////////////////////////</span>
    <span class="c1">// Final Output</span>
    <span class="c1">////////////////////////////////////////////////////////////////////////</span>
    <span class="n">Outputs</span><span class="p">.</span><span class="n">Texture</span> <span class="o">=</span> <span class="n">OutputTexture</span><span class="p">;</span>
    <span class="n">Outputs</span><span class="p">.</span><span class="n">Rect</span>    <span class="o">=</span> <span class="n">OutputRect</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// end of RenderLensFlare()</span>
</pre></div>

<p>We perform the final render and then assign the output struct the final texture and its size. The rendering process is done and the engine will use our result from now on.</p>
<hr>
<a id="performance_and_optimization"></a><h2>Performance and Optimization</h2>
<p>Now that everything is in place and (should be) running, it's easy to compare timings between the original method and the new one:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/timings_original_1080p.png"><br>
(Original Unreal effect: total ~0.376ms at 1080p)</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/timings_custom_1080p.png"><br>
(New effect: total ~0.65ms at 1080p)</p>
<blockquote>
<p>The performance measured are based on my RX 5600 XT on Linux with Mesa drivers and the Vulkan backend.</p>
</blockquote>
<p>As you can see, the render time is doubled but the effect is much more rich. And for an effect that adds so much to the image without the need of manual work in a scene, I feel it's a good trade-off. We are still below 1ms after all.</p>
<p>I'm pretty sure the default UE4 effect could be optimized by merging the Ghosts generation into a single pass. The bokeh blur is actually quite fast in itself (but has the quality issues I mentioned).</p>
<p>On our side, I think it should be doable to skip the threshold pass and combine it with the downsampled buffer that the engine generates which would save additional time. It won't be as controllable as it is right now which is why I didn't go this way.</p>
<p>I also think some blur pass might be avoided by using more adapted filters when generating/sampling some passes, but as some point I wanted to move on and decided to leave things as-is since performances were already good enough.</p>
<p>Some of the effects could also be moved to compute shaders to take advantage of parallelization/shared memory and speed-up further the rendering time, but I'm not familiar enough with the subject to be sure.</p>
<p>So overall, there still a bit of room for improvement !</p>
<hr>
<a id="conclusion"></a><h2>Conclusion</h2>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/salvatore_ganacci_horse_dance_optim.gif"><br>
It's done !</p>
<p>I didn't expect this subject to take this long to investigate, figure out and even implement. Things started in December 2020 to finish this September 2021. There has been some on and off of course but what a ride !<br>
For the curious minds, take a look at my <a href="https://twitter.com/Froyok/status/1337171200066392065" rel="nofollow">Twitter thread</a> where I shared most of my progress, including the little joys and other strange bugs. The most difficult part ended up being the Glare effect.</p>
<p>I would also like to give special thanks to:<br>
- <a href="https://twitter.com/newincpp" rel="nofollow">Newin</a><br>
- <a href="https://twitter.com/Deathreycg" rel="nofollow">DeathRay</a><br>
- <a href="https://twitter.com/phyronnaz" rel="nofollow">Phy</a><br>
- <a href="https://twitter.com/nicolaswir" rel="nofollow">Nicolas</a><br>
- Christophe S.<br>
- Gael C.</p>
<p>And of course everybody else who made nice comments on my progress during all the development phase. :)</p>
<hr>
<a id="bonus"></a><h2>Bonus</h2>
<p>A little bonus section that focus on a few things I discovered while working on this subject. Hopefully this will be useful for somebody else.</p>
<a id="previewing_rdg_buffers"></a><h3>Previewing RDG Buffers</h3>
<p>When working with shaders, it is often useful to view the result of a render pass isolated to more easily debug the shader behavior. This can be done by doing a frame capture with a graphic debugger like RenderDoc, but this can be a slow process (especially when iterating).<br>
Fortunately the Unreal Engine has a native tool to display textures directly over the viewport. This can be done by running the following console command:</p>
<blockquote>
<p><strong>vis NameOfTheBuffer</strong></p>
</blockquote>
<p>The name of the buffer is the same name that was specified for each render pass in the code. So if we want to see the ghosts, we can call:</p>
<blockquote>
<p><strong>vis LensFlareGhosts</strong></p>
</blockquote>
<p>Which gives the following result:</p>
<p class="img-centered"><a class="img-link " href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/ue4_custom/in_viewport_rdg_buffers.jpg" rel="nofollow" target="_blank"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/th_in_viewport_rdg_buffers.jpg"></a></p>
<p>To clear the viewport, simply call:</p>
<blockquote>
<p><strong>vis none</strong></p>
</blockquote>
<p>For a few more details, check out the <a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Rendering/RenderDependencyGraph/index.html" rel="nofollow">RDG documentation</a>. You can also run the <strong>vis</strong> command as well to print its format.</p>
<a id="generating_mipmaps_with_rdg_buffers"></a><h3>Generating Mipmaps with RDG Buffers</h3>
<p>Several times I mentioned that I had to generate mipmaps to try some things out. While none of my actual code needs it anymore, I initially struggled to figure out the right setup. So I wanted to a least document somewhere how it's done.</p>
<p>There is two things to know in order to get mipmaps: the target buffer must be setup the right way when RDG creates it. Then just ask the engine to generate the mipmaps levels for you after you finished rendering the buffer.<br>
The first step is important because the second one will assert if you didn't configure things properly. The buffer must have a flag that tels the GPU that it can both read and write into it. This is because mipmaps are generated by compute shaders that do both at the same time.</p>
<p>So when building a buffer, add the new flag like so:</p>
<div class="highlight"><pre><span class="n">FRDGTextureDesc</span> <span class="n">Description</span> <span class="o">=</span> <span class="n">InputTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">;</span>
<span class="n">Description</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
<span class="n">Description</span><span class="p">.</span><span class="n">Extent</span>  <span class="o">=</span> <span class="n">Viewport2</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
<span class="n">Description</span><span class="p">.</span><span class="n">Format</span>  <span class="o">=</span> <span class="n">PF_FloatRGB</span><span class="p">;</span>
<span class="n">Description</span><span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">FClearValueBinding</span><span class="p">(</span><span class="n">FLinearColor</span><span class="o">::</span><span class="n">Transparent</span><span class="p">);</span>

<span class="c1">// Number of mips you want to generate.</span>
<span class="n">Description</span><span class="p">.</span><span class="n">NumMips</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">// Flag to tell the engine and GPU this buffer can be both read and write.</span>
<span class="c1">// (The |= append the new flag to the existing list.)</span>
<span class="n">Description</span><span class="p">.</span><span class="n">TargetableFlags</span> <span class="o">|=</span> <span class="n">ETextureCreateFlags</span><span class="o">::</span><span class="n">TexCreate_UAV</span><span class="p">;</span>

<span class="n">FRDGTextureRef</span> <span class="n">Texture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">Description</span><span class="p">,</span> <span class="o">*</span><span class="n">PassName</span><span class="p">);</span>
</pre></div>

<p>Perform you render pass normally afterward (like we did with <strong>DrawShaderPass()</strong>) and then use:</p>
<div class="highlight"><pre><span class="n">FGenerateMips</span><span class="o">::</span><span class="n">Execute</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">Texture</span><span class="p">,</span> <span class="n">BilinearBorderSampler</span> <span class="p">);</span>
</pre></div>

<p><strong>FGenerateMips</strong> is a dedicated class of the engine to build mipmaps for us. You will have to include <strong>GenerateMips.h</strong> to access it.</p>
<p>Regarding the <strong>UAV</strong> flag:</p>
<blockquote>
<p>An unordered access view (UAV) is a view of an unordered access resource (which can include buffers, textures, and texture arrays, though without multi-sampling). A UAV allows temporally unordered read/write access from multiple threads. This means that this resource type can be read/written simultaneously by multiple threads without generating memory conflicts.<br>
  Source: <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/typed-unordered-access-view-loads#overview" rel="nofollow">Microsoft documentation</a>.</p>
</blockquote>
<a id="splitting_code_into_multiple_files"></a><h3>Splitting Code Into Multiple Files</h3>
<p>If you followed this article from start to finish to build your own effect (or the same one) you will end-up with a very, very long file. I found it difficult to manage so I looked into ways to split things up.</p>
<p>I didn't want to make sub-classes to keep the code simple and having multiple .cpp is not really possible (or at least lead to some tedious setup).<br>
Instead, it is possible to have a main .cpp file and have additional .inl file which gets merged together during compilation. What is handy is that you don't have to duplicate includes or anything else since in the end it will act as a single big file.</p>
<p>So in the end I have 4 files:</p>
<ul>
<li>PostProcessSubsystem.h</li>
<li>PostProcessSubsystem.cpp</li>
<li>LensFlareShaders.inl</li>
<li>LensFlareRendering.inl</li>
</ul>
<p>And inside the .cpp file I just add includes after the main ones:</p>
<div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">"LensFlareShaders.inl"</span>
<span class="cp">#include</span> <span class="cpf">"LensFlareRendering.inl"</span>
</pre></div>

<p>Inside <strong>PostProcessSubsystem.cpp</strong> I only have the main module functions (like <strong>Initialize()</strong>) while the actual render functions are all in <strong>LensFlareRendering.inl</strong>. The namespace that contains all the global shader definitions is inside <strong>LensFlareShaders.inl</strong>.</p>
<a id="recompiling_shaders_at_runtime"></a><h3>Recompiling Shaders at Runtime</h3>
<p>In Unreal it is possible to explicitly request the engine to recompile all the shaders (including the global ones). </p>
<p>When iterating on global shaders (.usf) it is very handy to be able to request that at runtime without having to close the game/editor and restart it to force the compilation. This is done by using a little console command. Since I always struggle to find in the official documentation I wanted to note it here:</p>
<div class="highlight"><pre><span class="n">RecompileShaders</span> <span class="n">changed</span>
</pre></div>

<p>This will crawl all the shader files on disk, figure out which one are modified, and recompile them. Make sure to have enabled <strong>r.ShaderDevelopmentMode</strong> for <a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/Rendering/ShaderDevelopment/#retryingoncompileerrors" rel="nofollow">shader debugging</a> in case you want to catch typos and not crash immediately.</p>
<blockquote>
<p>You can also use:<br>
  - <strong>RecompileShaders all</strong>: recompile everything (like first time you run the engine/editor).<br>
  - <strong>RecompileShaders changed</strong>: recompile modified global shader (.usf).<br>
  - <strong>RecompileShaders global</strong>: recompile all global shader (.usf).<br>
  - <strong>RecompileShaders material [name]</strong>: recompile a specific material.<br>
  - <strong>RecompileShaders platform [name]</strong>: recompile changed shaders for a specific platform.</p>
</blockquote>
<a id="changing_cvar_for_debug_ui"></a><h3>Changing Cvar for Debug UI</h3>
<p>It might be useful to execute console commands without passing by the console itself. In my case I have a debug UI which looks like this:</p>
<p class="img-centered"><img alt="" src="./Custom Lens-Flare Post-Process in Unreal Engine _ Froyok - Fabrice Piquet_files/debug_menu.jpg"></p>
<p>When clicking on one of the checkboxes related to the lens-flares it actually executes a console command. This is very handy to debug stuff and do comparisons without having to look at the console to type the command.</p>
<p>So to run a command from your game code, simply call:</p>
<div class="highlight"><pre><span class="k">const</span> <span class="n">FString</span> <span class="n">Command</span> <span class="o">=</span> <span class="s">"yourCommand"</span><span class="p">;</span>
<span class="n">GEngine</span><span class="o">-&gt;</span><span class="n">Exec</span><span class="p">(</span> <span class="n">GetWorld</span><span class="p">(),</span> <span class="o">*</span><span class="n">Command</span> <span class="p">);</span>
</pre></div>

<p>Here is another example with a cvar made during this article:</p>
<div class="highlight"><pre><span class="c1">// bDrawGlare is a boolean from my debug UI class</span>
<span class="k">const</span> <span class="n">FString</span> <span class="n">Command</span> <span class="o">=</span> <span class="s">"r.LensFlare.RenderGlare "</span> <span class="o">+</span> <span class="n">FString</span><span class="o">::</span><span class="n">FromInt</span><span class="p">(</span> <span class="n">bDrawGlare</span> <span class="p">);</span>
<span class="n">GEngine</span><span class="o">-&gt;</span><span class="n">Exec</span><span class="p">(</span> <span class="n">GetWorld</span><span class="p">(),</span> <span class="o">*</span><span class="n">Command</span> <span class="p">);</span>
</pre></div>

<hr>
<a id="bibliography_and_sources"></a><h2>Bibliography and Sources</h2>
<p>Below is a (long) list of various papers, posts and examples that helped the writing of this article:</p>
<p>Games:</p>
<ul>
<li><a href="https://store.steampowered.com/app/108710/Alan_Wake/" rel="nofollow">Alan Wake</a>, Remedy Entertainment, 2010</li>
<li><a href="https://store.steampowered.com/app/24980/Mass_Effect_2_2010/" rel="nofollow">Mass Effect 2</a>, BioWare, 2010</li>
<li><a href="https://store.steampowered.com/app/50300/Spec_Ops_The_Line/" rel="nofollow">Spec Ops: The Line</a>, Yager, 2012</li>
<li><a href="https://store.steampowered.com/app/214490/Alien_Isolation/" rel="nofollow">Alien: Isolation</a>, Creative Assembly, 2014</li>
<li><a href="https://store.steampowered.com/app/208650/Batman_Arkham_Knight/" rel="nofollow">Batman: Arkham Knight</a>, Rocksteady Studios, 2015</li>
<li><a href="https://store.steampowered.com/app/275850/No_Mans_Sky/" rel="nofollow">No Man's Sky</a>, Hello Games, 2016</li>
<li><a href="https://store.steampowered.com/app/1091500/Cyberpunk_2077/" rel="nofollow">Cyberpunk 2077</a>, CD Projekt Red, 2020</li>
<li><a href="https://www.playstation.com/en-us/games/ratchet-and-clank-rift-apart/" rel="nofollow">Ratchet &amp; Clank Rift Apart</a>, Insomniac Games, 2021</li>
</ul>
<p>Papers:</p>
<ul>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/papers/realtime_rendering_glare_images_using_vertex_texture_fetch_on_gpu.pdf" rel="nofollow">"Realtime Rendering of High Quality Glare Images Using Vertex texture Fetch on GPU"</a>, 2006</li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/papers/physically-based-real-time_lens_flare_rendering.pdf" rel="nofollow">"Physically-Based Real-Time Lens Flare Rendering"</a> (<a href="http://resources.mpi-inf.mpg.de/lensflareRendering/" rel="nofollow">mirror</a>), 2011</li>
<li><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/resources/papers/practical_real-time_lens-flare_rendering.pdf" rel="nofollow">"Practical Real-Time lens-flare Rendering"</a>, 2013</li>
<li><a href="https://placeholderart.wordpress.com/2015/01/19/implementation-notes-physically-based-lens-flares/" rel="nofollow">"Implementation Notes: Physically Based Lens Flares"</a>, 2015</li>
</ul>
<p>Articles:</p>
<ul>
<li><a href="https://www.hardware.fr/articles/845-12/etape-10-post-traitement.html" rel="nofollow">"Comprendre le rendu 3D étape par étape avec 3DMark11"</a>, Hardware.fr, 2011</li>
<li><a href="http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html" rel="nofollow">"Pseudo Lens Flare"</a> and <a href="https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html" rel="nofollow">"Screen Space Lens Flare"</a>, John Chapman (<a href="https://twitter.com/_JohnChapman" rel="nofollow">@_JohnChapman</a>), 2013 &amp; 2017</li>
<li><a href="http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare" rel="nofollow">"Next Generation Post Processing in Call of Duty: Advanced Warfare"</a>, Jorge Jimenez, 2014</li>
<li><a href="https://bartwronski.com/2015/03/09/anamorphic-lens-flares-and-visual-effects/" rel="nofollow">"Anamorphic lens flares and visual effects"</a>, Bart Wronski, 2015</li>
<li><a href="https://research.tri-ace.com/s2015.html" rel="nofollow">"Real-time Rendering of Physically Based Optical Effect in Theory and Practice"</a>, Tri-Ace, 2015</li>
<li><a href="http://genderi.org/frame-buffer-postprocessing-effects-in-double-s-t-e-a-l-wreckl.html" rel="nofollow">"Frame Buffer Postprocessing Effects in Double-S.T.E.A.L"</a>, Masaki Kawase, 2018</li>
<li><a href="http://morad.in/2020/04/03/unmasking-arkham-knight/" rel="nofollow">"Unmasking the Arkham Knight"</a>, Balázs Török (<a href="https://twitter.com/m0radin" rel="nofollow">@m0radin</a>), 2020</li>
<li><a href="https://www.shadertoy.com/view/tstBDl" rel="nofollow">"Fisheye Equidistant"</a>, Crucifer, 2020</li>
<li><a href="https://s3.amazonaws.com/download-aws.futuremark.com/3dmark11-technical-guide.pdf" rel="nofollow">"3D Mark 11 Technical Guide"</a>, 3DMark, 2020</li>
<li><a href="https://benui.ca/unreal/subsystem-singleton/" rel="nofollow">"Unreal-style Singletons with Subsystems"</a>, <a href="https://twitter.com/_benui" rel="nofollow">@_benui</a>, 2020</li>
<li><a href="https://scahp.tistory.com/15" rel="nofollow">"Geometry shader in UE4"</a>, 2020</li>
<li><a href="https://docs.otoy.com/cinema4d//PostProcessing.html" rel="nofollow">"Octane for Cinema 4D - Post processing"</a>, OTOY</li>
<li><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Subsystems/index.html" rel="nofollow">"Programming Subsystems"</a>, Unreal Engine Documentation</li>
<li><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Rendering/RenderDependencyGraph/index.html" rel="nofollow">"Render Dependency Graph"</a>, Unreal Engine Documentation</li>
</ul>
<p>Examples:</p>
<ul>
<li><a href="https://www.slrlounge.com/diffraction-aperture-starburst-effects/" rel="nofollow">Diffraction, Aperture, and Starburst Effects</a></li>
<li><a href="https://www.youtube.com/watch?v=flr4lj-zmjA" rel="nofollow">How Aperture Shapes LENS FLARE, and Other Lens Flare Tips</a></li>
<li><a href="https://www.google.com/maps/@42.1327153,8.9742976,3a,75y,168.34h,104.5t/data=!3m6!1e1!3m4!1sObs5BSakcIbvMCTiSHM6PA!2e0!7i13312!8i6656" rel="nofollow">Google Street view</a></li>
<li><a href="https://www.aliexpress.com/item/32816778137.html" rel="nofollow">Star Filter</a></li>
<li><a href="https://www.samhurdphotography.com/the-ring-of-fire/" rel="nofollow">Ring of fire</a></li>
<li><a href="https://en.wikipedia.org/wiki/Star_Trek_(film)" rel="nofollow">Star Trek</a>, 2009</li>
<li><a href="https://en.wikipedia.org/wiki/Lupin_(French_TV_series)" rel="nofollow">Lupin</a>, 2021</li>
</ul>
</div>
</div>
<div id="main-footer">
<p>
╔═══════════════════════════════╗<br>
Froyok - Fabrice Piquet - 2022 <span id="character-flicker">█</span><br>
╚═══════════════════════════════╝
</p>
<br><a href="https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/#page-top" id="link-back-top">Back To Top</a>
</div>


</body></html>